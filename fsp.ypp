%code top {
#include <cstdio>
#include <iostream>
#include <sstream>
#include <cstdlib>
#include <set>
#include <vector>

using namespace std;

}


%code requires {
/* Symbols tables. */
#include "symbols_table.hpp"
}


// Bison fundamentally works by asking flex to get the next token, which it
// returns as an object of type "YYSTYPE".  But tokens could be of any
// arbitrary data type!  So we deal with that in Bison by defining a C union
// holding each of the types of tokens that Flex could return, and have Bison
// use that union instead of "int" for the definition of "YYSTYPE":
%union {
    int int_value;
    float float_value;
    std::string *string_ptr;
    class SymbolValue *sv_ptr;
    struct SvpVec * svpvec_ptr;
    struct Pvec * pvec_ptr;
}


%code {
/* Stuff from flex that bison needs to know about. */
#include "scanner.hpp"


//#define NDEBUG
#include <assert.h>

struct SymbolsTable identifiers; /* Const, Range, Set and Parameter names. */
struct SymbolsTable local_processes; /* Names of local processes. */
struct SymbolsTable processes; /* Names of global processes. */

/* Main actions table. */
struct ActionsTable actions("Global actions table");

#include "lts.hpp"


#include "context.hpp"
static struct ContextsSetStack css;
#define current_contexts css.top()

/* Inline utilities. */
#include "utils.hpp"


/* Storage for a list of parameters identifiers to remove from the 
   identifiers table when a process definition has been completed. */
vector<string *> parameters;


/* Fix unresolved ProcessNode references due to cyclic processes. */
static void fix_unresolved_references(ProcessNode * pnp, void * opaque);


/* Left contains a SetValue*, while right is the result of 'action_range'. */
SvpVec * indexize_svpvec(SvpVec * left, SvpVec * right)
{
    SvpVec * vp;
    SetValue * setvp;
    SetValue * rsetvp;
    RangeValue * rvp;
    ConstValue * cvp;
    ContextsSet * csp; 
    Context * cxp;

    /* type() and 'variable' is the same for all the elements in 
       action_range. */
    switch (right->v[0]->type()) {
	case SymbolValue::Range:
	    rvp = err_if_not_range(right->v[0]);
	    if (rvp->variable != "") {
		/* In this case each element in action_range is in the
		   form 'var:R', where R is a range_id or a range_expr. */
		csp = new ContextsSet;
		csp->frontier = current_contexts.frontier;
		vp = new SvpVec;
		for (int c=0; c<left->v.size(); c++) {
		    setvp = err_if_not_set(left->v[c]);
		    rvp = err_if_not_range(right->v[c]);
		    for (int j=rvp->low; j<=rvp->high; j++) {
			SetValue * new_setvp = new SetValue(*setvp);
			new_setvp->indexize(j);
			/* When a context spread happens, each new_setvp
			   inherits the rank of the generating setvp. */
			new_setvp->rank = setvp->rank;
			/* Append the new SetValue to associate to this
			   context.*/
			vp->v.push_back(new_setvp);
			/* Create a new context (extending the previous
			   one) */
			cxp = extended_context(current_contexts[c],
				rvp->variable, j);
			csp->append(cxp);
		    }
		}
		cout << "Contexts ramification\n";
		css.update(csp);
		delete left;
		delete right;
		return vp;
	    } else {
		/* In this case each element in action_range is in the
		   form "R", where R is a range_id or a range_expr. */
		for (int c=0; c<left->v.size(); c++) {
		    setvp = err_if_not_set(left->v[c]);
		    rvp = err_if_not_range(right->v[c]);
		    setvp->indexize(rvp->low, rvp->high);
		    /* Rank is inherited. */
		}
		delete right;
		return left;
	    }
	    break;

	case SymbolValue::Const:
	    for (int c=0; c<left->v.size(); c++) {
		setvp = err_if_not_set(left->v[c]);
		cvp = err_if_not_const(right->v[c]);
		setvp->indexize(cvp->value);
		/* Rank is inherited. */
	    }
	    delete right;
	    return left;
	    break;
	case SymbolValue::Set:
	    setvp = err_if_not_set(right->v[0]);
	    if (setvp->variable != "") {
		/* In this case each element in action_range is in the
		   form 'var:R', where R is a set_id or a set_expr. */
		csp = new ContextsSet;
		csp->frontier = current_contexts.frontier;
		/* We need a new SvpVec for a new ContextSet. */
		vp = new SvpVec;
		for (int c=0; c<left->v.size(); c++) {
		    setvp = err_if_not_set(left->v[c]);
		    rsetvp = err_if_not_set(right->v[c]);
		    for (int j=0; j<rsetvp->actions.size(); j++) {
			SetValue * new_setvp = new SetValue(*setvp);
			new_setvp->dotcat(rsetvp->actions[j]);
			/* When a context spread happens, each new_setvp
			   inherits the rank of the generating setvp. */
			new_setvp->rank = setvp->rank;
			/* Append the new SetValue to associate to this
			   context.*/
			vp->v.push_back(new_setvp);
			/* Create a new context (extending the previous
			   one) */
			cxp = extended_context(current_contexts[c],
				rsetvp->variable, rsetvp->actions[j]);
			/* Append the new Context to the new ContextSet. 
			 */
			csp->append(cxp);
		    }
		}
		cout << "Contexts ramification\n";
		css.update(csp);
		delete left;
		delete right;
		return vp;
	    } else {
		for (int c=0; c<left->v.size(); c++) {
		    setvp = err_if_not_set(left->v[c]);
		    rsetvp = err_if_not_set(right->v[c]);
		    /* Create a new SetValue that combines setvp and
		       rsetvp. No context ramification happens here. */
		    setvp->indexize(*rsetvp);
		    /* Rank is inherited. */
		}
		delete right;
		return left;
	    }
	    break;

	default:
	    cerr << "I should not reach this point.\n";
	    assert(0);
	    exit(1);
    }
}


static struct ProcessNode fakenode;
static void init_fakenode()
{
    vector<ProcessEdge> cv;
    struct ProcessEdge e;
    struct FrontierElement fe;
    vector<FrontierElement> frontier;

    /* The fakenode must have a child for each contexts. In this way the 
       actions associated to the rule 'prefix_actions-->action_labels' can
       correctly expand each context and return a ProcessNode* for each
       child. */
    fe.pnp = &fakenode;
    for (int c=0; c<current_contexts.size(); c++) {
	e.dest = NULL;
	e.rank = c;	/* The child will combine with the c-th context. */
	e.action = 0;	/* Not significant. */
	cv.push_back(e);
	/* Put the child in the frontier. */
	fe.child = c;
	frontier.push_back(fe);
    }
    fakenode.children = cv;
    current_contexts.frontier = frontier;
}

static void print_forest()
{
    cout << "Current ProcessNode forest:\n";
    for (int i=0; i<fakenode.children.size(); i++)
	if (fakenode.children[i].dest)
	    fakenode.children[i].dest->print(&actions);
}


struct AliasElement {
    /* Process name */
    string name;
    /* True if the process have ever been assigned an alias
       (eg. P[3] = T[12][18]). */
    bool assigned;

    AliasElement(const string& nm, bool l) : name(nm), assigned(l) { }
};

/* The purpose of this data structure is to store a list of sets. Each
   sets must contain all the process names that are aliases with each
   other. */
struct Aliases {
    vector< vector<AliasElement> > groups;

    /* When calling insert(left, right), the translator wants to say: Ehy,
       I've found something like 'left = right', where both left and right
       are process names (e.g. when parsing "P = P[0], P[i:R] = (...).", the
       translator will call insert("P","P[0]") ). */
    void insert(const string& left, const string& right) {
	int left_index = -1;
	bool left_was_assigned = false;
	int right_index = -1;
	int index;

	/* Firstly we look up both process names to discover what sets they
	   are contained in (if any). */
	for (int i=0; i<groups.size(); i++)
	    for (int j=0; j<groups[i].size(); j++) {
		if (groups[i][j].name == left) {
		    left_index = i;
		    left_was_assigned = groups[i][j].assigned;
		    groups[i][j].assigned = true;
		}
		if (groups[i][j].name == right)
		    right_index = i;
	}

	if (left_index != -1 && left_was_assigned) {
	    errstream << "$$Process " << left << " defined twice";
	    semantic_error();
	}

	if (left_index == -1 && right_index == -1) {
	    /* Neither 'left' nor 'right' was found. We create another set
	       that will contain both of them. */
	    vector<AliasElement> v;
	    groups.push_back(v);
	    index = groups.size() - 1;
	} else if (left_index == -1 && right_index != -1) {
	    /* The alias 'left' will added to the same set of 'right'. */
	    index = right_index;
	} else if (left_index != -1 && right_index == -1) {
	    /* The alias 'right' will added to the same set of 'left'. */
	    index = left_index;
	} else {
	    /* Both names were found. If they aren't already in the same
	       set we merge the two sets. */
	    if (left_index != right_index) {
		/* Merge the two sets. */
		for (int j=0; j<groups[right_index].size(); j++)
		    groups[left_index].push_back(groups[right_index][j]);
		groups.erase(groups.begin() + right_index);
	    }
	}

	/* Do the real insertion work if necessary (see above). */
	if (left_index == -1)
	    groups[index].push_back(AliasElement(left, true));
	if (right_index == -1)
	    groups[index].push_back(AliasElement(right, false));
    }

    /* Tell the data structure to insert all the aliases in the SymbolsTable
       'pt'. The translator will call this function when it wants to move
       the aliases collected during the translation into a process symbols
       table. */
    void fill_process_table(SymbolsTable& pt) {
	for (int i=0; i<groups.size(); i++) {
	    int found = 0;
	    int index = -1;
	    SymbolValue * svp;
	    ProcessValue * pvp;

	    /* For each set, we have to find the unique process (if any) that
	       is already in 'pt', e.g. a process that has been defined as a
	       proper process (with a non-NULL ProcessNode*) and not just as
	       an alias. */
	    for (int j=0; j<groups[i].size(); j++) {
		if (pt.lookup(groups[i][j].name, svp)) {
		    found++;
		    index = j;
		} else if (!groups[i][j].assigned) {
		    /* We make sure that every non-properly-defined process
		       has been assigned somewhere as an alias.*/
		    errstream << "$* Process " << groups[i][j].name
			<< " undefined";
		    semantic_error();
		}
	    }
	    assert(found <= 1);
	    if (found == 0) {
		cerr << "Warning, aliases cycle found: {";
		for (int j=0; j<groups[i].size(); j++)
		    cerr << groups[i][j].name << ", ";
		cerr << "}\n";
		cerr << "    A new STOP process will be associated to these aliases\n";
		pvp = new ProcessValue;
		pvp->pnp = new ProcessNode;
		svp = pvp;
		pt.insert(groups[i][0].name, svp);
		index = 0;
	    }
	    pvp = err_if_not_process(svp);
	    for (int j=0; j<groups[i].size(); j++)
		if (j != index) {
		    ProcessValue * npvp = new ProcessValue;

		    npvp->pnp = pvp->pnp;
		    if (!pt.insert(groups[i][j].name, npvp)) {
			/* This really can't happen. */
			errstream << "Impossible duplicate (BUG)\n";
			semantic_error();
		    }
		    cout << "Process " << groups[i][j].name << " defined (" << npvp->pnp << ")\n";
		}
	}
    }

    void clear() {
	groups.clear();
    }

    void print() {
	cout << "Aliases:\n";
	for (int i=0; i<groups.size(); i++)
	    for (int j=0; j<groups[i].size(); j++)
		cout << i << ": " << groups[i][j].name << ", " << groups[i][j].assigned << "\n";
    }
};

static struct Aliases aliases;


#define DEBUG 1
#if (DEBUG==2)
#define SHH(x) cout<< "SHH >> " << x << "\n";
#define OUT(x) cout<<"OUT:"; x
#define IN(x) cout<<"IN:"; x
#define PROX(x)
#define PROP(x)
#elif (DEBUG==1)
#define SHH(x)
#define OUT(x)
#define IN(x)
#define PROX(x) cout<<"PROX: ";x;cout<<"\n"
#define PROP(x) cout<<"PROP:==============================================================\n      " << x << "\n"
#else
#define SHH(x)
#define OUT(x)
#define IN(x)
#define PROP(x)
#define PROX(x)
#endif


void yyerror(const char *s);
}


// define the "terminal symbol" token types I'm going to use (in CAPS
// by convention), and associate each with a field of the union:

%token IF THEN ELSE
%token WHEN
%token CONST RANGE SET
%token ARROW
%token DOTDOT
%token END STOP ERROR
%token PROPERTY PROGRESS MENU
%token FORALL
%token SHARING
%token OR AND EQUAL NOTEQUAL LOE GOE LSHIFT RSHIFT
%token <int_value> INTEGER
%token <float_value> FLOAT
%token <string_ptr> UpperCaseID
%token <string_ptr> LowerCaseID

%type <svpvec_ptr> simple_expression
%type <svpvec_ptr> base_expr expression unary_expr multiplicative_expr
%type <svpvec_ptr>  additive_expr shift_expr relational_expr equality_expr
%type <svpvec_ptr> bitand_expr bitxor_expr bitor_expr and_expr or_expr

%type <string_ptr> variable constant_id range_id set_id range_or_set_id
%type <string_ptr> parameter_id process_id progress_id menu_id
%type <string_ptr> const_range_set_parameter_id

%type <svpvec_ptr> set set_elements set_expr
%type <svpvec_ptr> action_labels
%type <svpvec_ptr> alphabet_extension_OPT
%type <svpvec_ptr> action_range guard_OPT
%type <svpvec_ptr> range_expr
%type <svpvec_ptr> index_ranges_OPT index_ranges indices_OPT indices

%type <pvec_ptr> choice action_prefix prefix_actions
%type <pvec_ptr> process_body local_process local_process_defs 
%type <pvec_ptr> local_process_def
%type <pvec_ptr> sequential_composition base_local_process else_OPT
%type <pvec_ptr> seq_process_list process_ref

/* Generate a Generic LR parser, instead of a standard LR parser. We need
   this to resolve conflicts at runtime. */
%glr-parser

/* Name of the parser implementation file. */
%output "parser.cpp"

/* Create a parser header file. This is needed because we define yylex()
   in another source file (the FLEX generated scanner source file). */
%defines

/* Write an extra output file containing verbose descriptions of the parser
    states and what is done for each type of lookahead token in that state
%verbose
*/



%%

/* Start symbol: an arbitrary long list of fsp_definitions */
fsp_description:
    fsp_definition
    | fsp_description fsp_definition
    ;

/* All the possible type of fsp_definitions */
fsp_definition:
    constant_def
    | range_def
    | set_def
    | property_def
    | progress_def
    | menu_def
    | process_def
    | composite_def
    ;


/* Action labels TODO: fix */
action_labels:
    LowerCaseID {
	SHH("action_labels --> LowerCaseID");
	SvpVec * vp;
	SetValue * setvp; 

	vp = new SvpVec;
	vp->shared = false;
	for (int c=0; c<current_contexts.size(); c++) {
	    setvp = new SetValue;
	    *setvp += *$1;
	    /* We assign a different rank to each setvp in vp (and so one
	       per context). Note that this assignment happens before
	       parsing anithing else in the composite action. For istance,
	       if we have to parse 'a[i:R][S][i+1]', this action is executed
	       as soon as 'a' is parsed, and so before parsing the rest
	       of the composite action. */
	    setvp->rank = c;
	    vp->v.push_back(setvp);
	}
	delete $1;
	$$ = vp;
	OUT(vp->print());
    }
    | set {
	SHH("action_labels --> set");
	$$ = $1;
	OUT($$->print());
    }
    | action_labels '.' LowerCaseID {
	SHH("action_labels --> action_labels . LowerCaseID");
	IN($1->print());
	SetValue * setvp;

	assert($1->v.size() == current_contexts.size());
	for (int c=0; c<$1->v.size(); c++) {
	    setvp = err_if_not_set($1->v[c]);
	    setvp->dotcat(*$3);
	    /* Rank is inherited. */
	}
	delete $3;
	$$ = $1;
    }
    | action_labels '.' set {
	SHH("action_labels --> action_labels . set");
	assert($1->v.size() == $3->v.size() &&
		    $1->v.size() == current_contexts.size());
	SetValue * setvp;
	SetValue * rsetvp;
	for (int c=0; c<$1->v.size(); c++) {
	    setvp = err_if_not_set($1->v[c]);
	    rsetvp = err_if_not_set($3->v[c]);
	    /* Combine setvp with rsetvp. No context ramification
	       happens here. */
	    setvp->dotcat(*rsetvp);
	    /* Rank is inherited. */
	}
	delete $3;
	$$ = $1;
	OUT($$->print());
    }
    | action_labels '[' action_range ']' {
	SHH("action_labels --> action_labels [ action_range ]");
	IN($1->print(); $3->print());

	assert($1->v.size() == $3->v.size() &&
		$1->v.size() == current_contexts.size());
	$$ = indexize_svpvec($1, $3);
	OUT($$->print());
    }
    ;

set:
    set_id {
	SHH("set --> set_id");
	SvpVec * vp = new SvpVec;
	SymbolValue * svp;
	SetValue * setvp;
	if (!identifiers.lookup(*$1, svp)) {
	    errstream << "set " << *$1 << " undeclared";
	    semantic_error();
	}
	delete $1;
	setvp = err_if_not_set(svp);
	svp = svp->clone();
	vp->shared = true;
	for (int c=0; c<current_contexts.size(); c++)
	    vp->v.push_back(svp);
	$$ = vp;
	OUT($$->print());
    }
    | set_expr {
	SHH("set --> set_expr");
	$$ = $1;
	OUT($$->print());
    }
    ;

set_expr:
    '{' set_elements '}' {
	SHH("set_expr --> { set_elements }");
	$2->print();
	$$ = $2;
	OUT($$->print());
    }
    ;

action_range:
    expression {
	SHH("action_range --> expression");
	$$ = $1;
	OUT($$->print());
    }
    | range_expr {
	SHH("action_range --> range_expr");
	$$ = $1;
	OUT($$->print());
    }
    | set_expr {
	SHH("action_range --> set_expr");
	$$ = $1;
	OUT($$->print());
    }
    | variable ':' range_or_set_id {
	SHH("action_range --> variable : range_or_set_id");
	IN(cout << *$1 << ": " << *$3 << "\n");
	SvpVec * vp = new SvpVec;
	SymbolValue * svp;

	if (!identifiers.lookup(*$3, svp)) {
	    errstream << "range/set " << *$3 << " undeclared";
	    semantic_error();
	}
	svp = svp->clone();

	/* Pass the variable name to the upper levels.*/
	svp->setVariable(*$1);
	delete $1;
	vp->shared = true;
	for (int c=0; c<current_contexts.size(); c++)
	    vp->v.push_back(svp);
	$$ = vp;
	OUT($$->print());
    }
    | variable ':' range_expr {
	SHH("action_range --> variable : range_expr");
	IN(cout << *$1 << ": "; $3->print());
	RangeValue * rvp;
	for (int i=0; i<$3->v.size(); i++) {
	    rvp = err_if_not_range($3->v[i]);
	    /* Pass the variable to the upper levels.*/
	    rvp->setVariable(*$1);
	}
	delete $1;
	$$ = $3;
	OUT($$->print());
    }
    | variable ':' set_expr {
	SHH("action_range --> variable : set_expr");
	IN(cout << *$1 << ": "; $3->print());
	SetValue * setvp;
	for (int i=0; i<$3->v.size(); i++) {
	    setvp = err_if_not_set($3->v[i]);
	    /* Pass the variable to the upper levels.*/
	    setvp->setVariable(*$1);
	}
	delete $1;
	$$ = $3;
	OUT($$->print());
    }
    ;

range_expr:
    expression DOTDOT expression {
	SHH("range_expr --> expression .. expression");
	IN($1->print(); $3->print());
	RangeValue * rvp;
	ConstValue * cvp;
	SvpVec * vp = new SvpVec;

	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    rvp = new RangeValue;
	    cvp = err_if_not_const($1->v[i]);
	    rvp->low = cvp->value;
	    cvp = err_if_not_const($3->v[i]);
	    rvp->high = cvp->value;
	    vp->v.push_back(rvp);
	}
	delete $1;
	delete $3;
	$$ = vp;
	OUT($$->print());
    }
    ;


/* Const, Range, Set */
constant_def:
    CONST constant_id '=' simple_expression {
	if ($4->v.size() != 1) {
	    // XXX this should never happen, because we get an "undeclared"
	    errstream << "Illegal use of variables in const declaration";
	    semantic_error();
	}
	ConstValue* cvp = err_if_not_const($4->v[0]);
	$4->detach(0);
	OUT(cout << "Const " << *$2 << "=" << cvp->value << "\n");
	if (!identifiers.insert(*$2, cvp)) {
	    errstream << "const " << *$2 << " declared twice";
	    semantic_error();
	}
	delete $4;
	delete $2;
    };

range_def:
    RANGE range_id '=' simple_expression DOTDOT simple_expression {
	if ($4->v.size() != 1 || $6->v.size() != 1) {
	    // XXX this should never happen, because we get an "undeclared"
	    errstream << "Illegal use of variables in range declaration";
	    semantic_error();
	}
	RangeValue* rvp = new RangeValue;
	ConstValue * cvp1 = err_if_not_const($4->v[0]);
	ConstValue * cvp2 = err_if_not_const($6->v[0]);
	OUT(cout << "Range " << *$2 << "[" << cvp1->value << ", " << cvp2->value << "]\n");
	rvp->low = cvp1->value;
	rvp->high = cvp2->value;
	//delete cvp1; // done below
	//delete cvp2;
	delete $4;
	delete $6;
	if (!identifiers.insert(*$2, rvp)) {
	    errstream << "range " << *$2 << " declared twice";
	    semantic_error();
	}
	delete $2;
    };

set_def:
    SET set_id '=' '{' set_elements '}' {
	OUT(cout << "Set\n"; $5->print());
	// TODO convert from SvpVec to SetValue
	if (!identifiers.insert(*$2, $5->v[0])) {
	    errstream << "set " << *$2 << " declared twice";
	    semantic_error();
	}
	$5->detach(0);
	delete $5;
	delete $2;
    };

set_elements:
    action_labels {
	SHH("set_elements --> action_labels");
	$$ = $1;
	OUT($$->print());
    }
    | set_elements ',' action_labels {
	SHH("set_elements --> set_elements , action_labels");
	IN($1->print(); $3->print());

	assert($1->v.size() == $3->v.size());
	for (int c=0; c<$1->v.size(); c++) {
	    SetValue * setvp = err_if_not_set($1->v[c]);
	    SetValue * rsetvp = err_if_not_set($3->v[c]);
	    *setvp += *rsetvp;
	}
	delete $3;
	$$ = $1;
	OUT($$->print());
    }
    ;


/* Processes */
process_def:
    process_id param_OPT {
	/* Parameters have been pushed inside the 'param_OPT' rule.
	   A cleaner approach would be to get a list of parameters from
	   the rule and push the parameters into the 'identifiers' table
	   in this action. */
	init_fakenode();
    }
    '=' process_body alphabet_extension_OPT relabel_OPT hiding_OPT '.' {
	SHH("process_def --> ... process_body ...");
	IN(cout<<*$1<< ": "; $5->print(&actions));
	PROP("process_def --> ... process_body ...");
	PROX(cout<<*$1<<" = "; $5->v[0]->print(&actions));

	ProcessBase * pbp = $5->v[0];
	SymbolValue * svp;
	ProcessValue * pvp = NULL;

	assert($5->v.size() == 1);
	if (pbp->unresolved()) {
	    aliases.insert(*$1, 
		    ((UnresolvedProcess* )pbp)->reference);
	    aliases.print();
	} 
	aliases.fill_process_table(local_processes);
	if (pbp->unresolved()) {
	    if(!local_processes.lookup(*$1, svp)) {
		errstream << "process " << *$1 << " undeclared";
		semantic_error();
	    }
	    pvp = err_if_not_process(svp);
	} else {
	    /* Insert a new ProcessValue in the symbol table, attaching the
	       process_body to it. */
	    pvp = new ProcessValue;
	    pvp->pnp = err_if_not_procnode(pbp);
	    if (!local_processes.insert(*$1, pvp)) {
		errstream << "process " << *$1 << " declared twice";
		semantic_error();
	    }
	    cout << "Process " << *$1 << " defined (" << pvp->pnp << ")\n";
	}

	PROX(cout << "<<<<<<<<<<<<<<<<<<<<<<<<<<<< Process " << *$1 << " defined >>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n");

	/* Try to resolve all the undefined references into this process. */
	struct ProcessVisitObject f;
	f.vfp = &fix_unresolved_references;
	f.opaque = &actions;
	pvp->pnp->visit(f);

	PROX(cout<<"resolved: "; pvp->pnp->print(&actions));

	/* Convert the collection of ProcessNodes in an Lts object. */
	Lts lts(pvp->pnp, &actions);

	/* Now we can free the graph pointed by pvp->pnp. */
	freeProcessNodeGraph(pvp->pnp);

	/* Extend the alphabet if is the case. */
	if ($6) {
	    SetValue * setvp;
	    if ($6->v.size() != 1) {
		errstream << "Multiset alphabet extension";
		semantic_error();
	    }
	    setvp = err_if_not_set($6->v[0]);
	    for (int i=0; i<setvp->actions.size(); i++)
		lts.updateAlphabet(actions.insert(setvp->actions[i]));
		delete setvp;
	}

	/* Remove process parameters from the identifiers. */
	for (int i=0; i<parameters.size(); i++) {
	    identifiers.remove(*(parameters[i]));
	    delete parameters[i];
	}
	parameters.clear();

	/* Clear 'local_processes' and 'aliases'. */
	local_processes.clear();
	aliases.clear();

	lts.print();
	lts.graphvizOutput((*$1 += ".gv").c_str());
	delete $1;

	// TODO implement everything is OPT
    }
    ;

process_body:
    local_process {
	SHH("process_body --> local_process");
	$$ = $1;
	OUT($$->print(&actions));
    }
    | local_process ',' local_process_defs {
	SHH("process_body --> local_process , local_process_defs");
	IN($1->print(&actions); $3->print(&actions));
	$$ = $1;
	OUT($$->print(&actions));
    }
    ;

local_process_defs:
    local_process_def {
	SHH("local_process_defs --> local_process_def");
	$$ = $1;
	OUT($$->print(&actions));
    }
    | local_process_defs ',' local_process_def {
	SHH("local_process_defs --> local_process_defs , local_process_def");
	IN($1->print(&actions); $3->print(&actions));
	$$ = $1;
	OUT($$->print(&actions));
    }
    ;

local_process_def:
    process_id index_ranges_OPT '=' {
	cout << "index_ranges_OPT:\n";
	$2->print();
	init_fakenode();
    } local_process {
	SHH("local_process_def --> process_id = local_process");
	IN(cout << *$1 << ": "; $5->print(&actions));
	ProcessValue * pvp;
	SetValue * setvp;
	string procname;

	for (int c=0; c<$2->v.size(); c++) {
	    setvp = err_if_not_set($2->v[c]);
	    for (int j=0; j<setvp->actions.size(); j++) {
		procname = *$1 + setvp->actions[j];
		if ($5->v[c]->unresolved()) {
		    aliases.insert(procname,
			((UnresolvedProcess* )$5->v[c])->reference);
		    aliases.print();
		} else {
		    pvp = new ProcessValue;
		    pvp->pnp = err_if_not_procnode($5->v[c]);
		    if (j)
			pvp->pnp = pvp->pnp->clone();
		    if (!local_processes.insert(procname, pvp)) {
			errstream << "process " << procname
			    << " declared twice";
			semantic_error();
		    }
		    cout << "Process " << procname << " defined (" << pvp->pnp << ")\n";
		}
	    }
	}
	delete $1;
	delete $2;
	$$ = $5;
	OUT($$->print(&actions));
    }
    ;

alphabet_extension_OPT:
    {
	$$ = NULL;
    }
    | '+' set {
	SHH("alphabet_extension_OPT --> + set");
	$$ = $2;
	OUT($$->print());
    }
    ;

local_process:
    base_local_process {
	SHH("local_process --> base_local_process");
	$$ = $1;
	OUT($$->print(&actions));
    }
    | sequential_composition {
/*
	SHH("local_process --> sequential_composition");
	$$ = $1;
	OUT($$->print(&actions));
*/
    }
    | IF expression THEN {
	SHH("local_process --> IF expression THEN (cont)");
	ConstValue * cvp;

	/* Prepare a clone of the current ContextsSet to rule out those
	   contexts that makes 'expression' false. In this way when executing
	   the translation of the following 'local_process', only the
	   selected contexts are expanded, while the others are not
	   translated (e.g. are filtered out). */
	css.push_clone();
	for (int c=0; c<current_contexts.size(); c++) {
	    cvp = err_if_not_const($2->v[c]);
	    if (!cvp->value) {
		current_contexts.rule_out(c);
	    }
	}
    } local_process {
	SHH("local_process --> (cont) local_process (cont)");
	ConstValue * cvp;

	css.pop();
	css.push_clone();
	/* Clean the previous clone and prepare another one for the else
	   branch, in the same way descripted above. */
	for (int c=0; c<current_contexts.size(); c++) {
	    cvp = err_if_not_const($2->v[c]);
	    if (cvp->value)
		current_contexts.rule_out(c);
	}
    } else_OPT {
	SHH("local_process --> (cont) else_OPT");
	IN($2->print(); $5->print(&actions); if ($7) $7->print(&actions));
	Pvec * pvec = new Pvec;
	ConstValue * cvp;

	css.pop();
	/* Clean the previous cloned ContextsSet and fill the return vector
	   *pvec, depending on the truth values contained in $2. */
	for (int c=0; c<current_contexts.size(); c++) {
	    cvp = err_if_not_const($2->v[c]);
	    if (cvp->value)
		pvec->v.push_back($5->v[c]);
	    else if ($7)
		pvec->v.push_back($7->v[c]);
	    else
		/* If $7 == NULL there is no else branch, and so we insert
		   a STOP state. */
		pvec->v.push_back(new ProcessNode);
	}
	delete $2;
	$$ = pvec;
	OUT($$->print(&actions));
    }
    | '(' {
	SHH("local_process --> (   (cont)");
	/* Replicate the CSS stack top so that it can be used by 'choice'. */
	css.push_clone();
	PROX(cout << "CSS height (push) " << css.stack.size());
	PROX(current_contexts.print());
    } choice ')' {
	SHH("local_process --> (cont)  choice )");
	//$3->print();
	$$ = $3;
	OUT($$->print(&actions));
    }
    ;

else_OPT:
    {
	$$ = NULL;
    }
    | ELSE local_process {
	$$ = $2;
    }

base_local_process:
    END {
	SHH("base_local_process --> END");
	Pvec * pvec = new Pvec;
	ProcessNode * pnp = new ProcessNode(ProcessNode::End);

	for (int c=0; c<current_contexts.size(); c++)
	    pvec->v.push_back(pnp);
	$$ = pvec;
	OUT($$->print(&actions));
    }
    | STOP {
	SHH("base_local_process --> STOP");
	Pvec * pvec = new Pvec;
	ProcessNode * pnp = new ProcessNode;

	for (int c=0; c<current_contexts.size(); c++)
	    pvec->v.push_back(pnp);
	$$ = pvec;
	OUT($$->print(&actions));
    }
    | ERROR {
	SHH("base_local_process --> ERROR");
	Pvec * pvec = new Pvec;
	ProcessNode * pnp = new ProcessNode(ProcessNode::Error);

	for (int c=0; c<current_contexts.size(); c++)
	    pvec->v.push_back(pnp);
	$$ = pvec;
	OUT($$->print(&actions));
    }
    | process_id indices_OPT {
	SHH("base_local_process --> process_id indices_OPT");
	SymbolValue * svp;
	Pvec * pvec = new Pvec;
	ProcessBase * pbp;
	SetValue * setvp;
	string name;

	assert($2->v.size() == current_contexts.size());
	for (int c=0; c<$2->v.size(); c++) {
	    setvp = err_if_not_set($2->v[c]);
	    assert(setvp->actions.size() == 1);
	    name = *$1 + setvp->actions[0];
	    cout << "looking for " << name << endl;
	    /* If the process referenced is already defined, return it.
	       Otherwise return a new UnresolvedProcess object, so that the
	       upper level sees that 'name' is unresolved. */
	    if (local_processes.lookup(name, svp))
		pbp = ((ProcessValue *)svp)->pnp;
	    else
		pbp = new UnresolvedProcess(name);
	    pvec->v.push_back(pbp);
	}

	$$ = pvec;
	OUT($$->print(&actions));
    }
    ;

choice:
    action_prefix {
	SHH("choice --> action_prefix");
	/* Pop (and destroy) the replicated top and everything above. */
	css.pop();
	$$ = $1;
	OUT($$->print(&actions));
	PROX(cout << "CSS height = (pop) " << css.stack.size());
    }
    | choice '|' {
	SHH("choice --> choice | (cont)");
	/* Replicate the CSS stack top so that it can be used by
	   'action_prefix'. */
	css.push_clone();
	PROX(cout << "CSS height (push) " << css.stack.size());
	PROX(current_contexts.print());
    } action_prefix {
	SHH("choice --> (cont) action_prefix");
	IN($1->print(&actions); $4->print(&actions));
	/* Pop (and destroy) the replicated top and everything above. */
	css.pop();
	cout << "CSS height = (pop) " << css.stack.size() << "\n";
	$$ = $1;
	OUT($$->print(&actions));
    }
    ;

action_prefix:
    guard_OPT {
	SHH("action_prefix --> guard_OPT (cont)");
	PROP("action_prefix --> guard_OPT (cont)");
	ConstValue * cvp;
	if ($1) {
	    for (int c=0; c<current_contexts.size(); c++) {
		cvp = err_if_not_const($1->v[c]);
		if (!cvp->value)
		    current_contexts.rule_out(c);
	    }
	    cout << "filtered\n"; current_contexts.print();
	}
    } prefix_actions ARROW local_process {
	SHH("action_prefix --> (cont) prefix_actions -> local_process");
	IN($3->print(&actions); $5->print(&actions));
	PROP("action_prefix --> (cont) prefix_actions -> local_process");
	/* If $5 is an istance of ConnectedProcess, it means that its first 
	   nodes have already been connected to the frontier of $3 in the
	   lower level rule 'prefix_actions'. Therefore there is nothing to
	   be done here. */

	for (int i=0; i<current_contexts.frontier.size(); i++) {
	    ProcessNode * pnp = current_contexts.frontier[i].pnp;
	    int child = current_contexts.frontier[i].child;
	    int rank = pnp->children[child].rank;
	    if ($5->v[rank]->connected()) continue;
	    if (!$5->v[rank]->unresolved())
		/* If $5 is not an unresolved reference, we connect the
		   current frontier (e.g. the frontier of $3) to the process
		   $5. */
		pnp->children[child].dest =
		    err_if_not_procnode($5->v[rank]);
	    else
		/* If $5 is an unresolved reference, we scan the current
		   frontier recording the reference itself, so that this
		   reference will be fixed by the upper levels. */
		pnp->children[child].unresolved_reference =
		    ((UnresolvedProcess *)$5->v[rank])->reference;
	}

	//$3->print();
	$$ = $3;
	OUT($$->print(&actions));
	PROX(current_contexts.print(); cout<<"$$ = "; print_forest());
    }
    ;

prefix_actions:
    action_labels {
	SHH("prefix_actions --> action_labels");
	IN($1->print(); current_contexts.print());
	PROP("prefix_actions --> action_labels");
	PROX(cout<<"$1 = "; $1->print());

	/* Note that this is executed (obviously) after $1 has been
	   parsed, and so after all the context ramifications implied by
	   the latter have been executed. */

	/* If the frontier is not empty, it means that, although at the
	   beginning of an 'action_prefix', we are in the middle of
	   a process definition (e.g. "P=(a->b->(c->..." or
	   "P=(a-b->(c->d->P|e->..."). In this case we have consider all
	   the edges in the frontier (e.g. the edge "b").
	 */
	vector<FrontierElement> new_frontier;
	Pvec * pvec = new Pvec;
	ProcessNode * pnp;
	ProcessNode * npnp;
	ProcessEdge e;
	SetValue * setvp;
	int rank;
	int child;
	struct FrontierElement fe;
	bool zero;
	int max_rank = 0;

	zero = true;
	for (int i=0; i<current_contexts.frontier.size(); i++)
	    if (current_contexts.frontier[i].pnp != &fakenode) {
		zero = false;
		break;
	    }

	for (int i=0; i<current_contexts.frontier.size(); i++) {
	    pnp = current_contexts.frontier[i].pnp;
	    child = current_contexts.frontier[i].child;
	    /* If the edge i is NULL-pointing, it means that we are
	       at the beginning of a choice construct (e.g.
	       "P=(a->b->(c->..."): We then create a node for that
	       edge (in our example we create a node for "b"). If the
	       edge is not NULL-pointing, it means that we are in 
	       the middle of a choice construct (e.g.
	       "P=(a-b->(c->d->P|e->...") and so the node has already
	       been created when processing the first choice element.
	       There is no need to create anything.
	     */
	    if (pnp->children[child].dest == NULL)
		pnp->children[child].dest = 
		    new ProcessNode(ProcessNode::Normal);
	    npnp = pnp->children[child].dest;

	    /* Once we get the node pointed by the edge i (npnp), we
	       have to combine that edge with the sets in $1. We
	       have a combination when the rank of the edge is equal
	       to the rank of the set. When we find a combination, we
	       add to npnp a NULL-pointing edge for each element in 
	       the matching set.
	     */
	    rank = pnp->children[child].rank;
	    if (rank > max_rank) max_rank = rank;
	    for (int c=0; c<$1->v.size(); c++) {
		if (current_contexts.is_ruled_out(c)) continue;
		setvp = err_if_not_set($1->v[c]);
		if (setvp->rank == rank) {
		    for (int k=0; k<setvp->actions.size(); k++) {
			e.action = actions.insert(setvp->actions[k]);
			e.dest = NULL;
			/* We set e.rank to the index in the SvpVec
			   $1 of setvp, so that this edge will
			   combine with actions in the next level
			   that have the same rank. */
			e.rank = c;
			npnp->children.push_back(e);
			/* We add the edge to the new frontier, so that
			   it will be used for combination with the next
			   level actions. */
			fe.pnp = npnp;
			fe.child = npnp->children.size() - 1;
			new_frontier.push_back(fe);
		    }
		}
	    }
	}
	/* Update the frontier. */
	current_contexts.frontier = new_frontier;
	if (zero) {
	    assert(max_rank+1 == fakenode.children.size());
	    for (int c=0; c<max_rank+1; c++)
		pvec->v.push_back(fakenode.children[c].dest);
	}
	else {
	    /* Tell the upper level rule (action_prefix) that the beginning
	       of this prefix_actions has already been connected, and so
	       'local_process' results already connected (see above). */
	    ProcessBase * pbp = new ConnectedProcess();
	    for (int c=0; c<max_rank+1; c++)
		pvec->v.push_back(pbp);
	}
	$$ = pvec;
	OUT($$->print(&actions));
	PROX(current_contexts.print(); cout<<"$$ = \n"; print_forest());
    }
    | prefix_actions ARROW action_labels {
	SHH("prefix_actions --> prefix_actions -> action_labels");
	IN($3->print(); current_contexts.print());
	PROP("prefix_actions --> prefix_actions -> action_labels");
	PROX(cout<<"$3 = "; $3->print());
	ProcessNode * pnp;
	ProcessNode * npnp;
	ProcessEdge e;
	SetValue * setvp;
	int rank;
	int child;
	struct FrontierElement fe;
	vector<FrontierElement> new_frontier;

	/* Here we are in the middle of a 'prefix_actions' 
	   (e.g. "...->b->c->d->.."), and so we have to connect each edge in
	   the frontier with the action sets in $3 (e.g. we have a frontier
	   that contains a NULL-pointing edge "c" and $3={{d}}).
	*/
	for (int i=0; i<current_contexts.frontier.size(); i++) {
	    pnp = current_contexts.frontier[i].pnp;
	    child = current_contexts.frontier[i].child;
	    /* Here we have to do the same combination descripted above,
	       but only if the edge in the frontier is NULL-pointing and
	       it has not an unresolved reference associated. If the
	       edge is not NULL-pointing, it means that we are in a 
	       situation like this "...->a->(b->c->...|d->e->...)". In
	       this case pnp is the node which has an edge "b" and an 
	       edge "d", and $3={{e}}: Therefore we don't have to consider
	       the edge "b" for combinations, since it has already been used
	       when processing the previous choice element. We only have to
	       consider "d". If an edge has an unresolved reference, 
	       it means that we are in a situation like this
	       "..a->(b->P|d->e->...)": this case is very similar to the
	       previous one, but here the edge "b" is NULL-pointing,
	       only because of the unresolved reference P: considering it
	       for combinations would be an error. */
	    if (pnp->children[child].dest == NULL &&
		    pnp->children[child].unresolved_reference == "") {
		pnp->children[child].dest = 
		    new ProcessNode(ProcessNode::Normal);
		npnp = pnp->children[child].dest;
		rank = pnp->children[child].rank;
		for (int c=0; c<$3->v.size(); c++) {
		    if (current_contexts.is_ruled_out(c)) continue;
		    setvp = err_if_not_set($3->v[c]);
		    if (setvp->rank == rank) {
			for (int k=0; k<setvp->actions.size(); k++) {
			    e.action = actions.insert(setvp->actions[k]);
			    e.dest = NULL;
			    /* We set e.rank to the index in the SvpVec
			       $3, so that this edge will combine with
			       actions in the next level that have the
			       same rank. */
			    e.rank = c;
			    npnp->children.push_back(e);
			    fe.pnp = npnp;
			    fe.child = npnp->children.size() - 1;
			    new_frontier.push_back(fe);
			}
		    }
		}
	    }
	}
	current_contexts.frontier = new_frontier;
	/* Note that $1 is not used in this action, because we use the
	   frontier stored in current_contexts. As a result, $1 is
	   the result of the previous action (and so a ProcessNode* or a
	   ConnectedProcess*. */
	$$ = $1;
	OUT($$->print(&actions));
	PROX(current_contexts.print(); cout<<"$$ = \n"; print_forest());
    }
    ;

guard_OPT:
    {
	$$ = NULL;
    }
    | WHEN expression {
	SHH("guard_OPT --> WHEN expression");
	for (int i=0; i<$2->v.size(); i++)
	    err_if_not_const($2->v[i]);
	$$ = $2;
	OUT($$->print());
    }
    ;

indices_OPT:
    {
	SvpVec * vp = new SvpVec;
	SetValue * setvp;

	for (int c=0; c<current_contexts.size(); c++) {    
	    setvp = new SetValue;
	    setvp->actions.push_back("");
	    vp->v.push_back(setvp);
	}
	$$ = vp;
    }
    | indices
    ;

indices:
    '[' expression ']' {
	SHH("indices --> [ expression ]");

	SvpVec * vp = new SvpVec;
	SetValue * setvp;
	ConstValue * cvp;

	assert($2->v.size() == current_contexts.size());
	for (int c=0; c<$2->v.size(); c++) {
	    setvp = new SetValue;
	    cvp = err_if_not_const($2->v[c]);
	    setvp->actions.push_back("[" + int2string(cvp->value) + "]");
	    vp->v.push_back(setvp);
	}
	delete $2;
	$$ = vp;
    }
    | indices '[' expression ']' {
	SHH("indices --> indices [ expression ]");
	SetValue * setvp;
	ConstValue * cvp;

	assert($1->v.size() == $3->v.size());
	for (int c=0; c<$3->v.size(); c++) {
	    setvp = err_if_not_set($1->v[c]);
	    cvp = err_if_not_const($3->v[c]);
	    setvp->indexize(cvp->value);
	}
	delete $3;
	$$ = $1;
    }
    ;

index_ranges_OPT:
    {
	SvpVec * vp = new SvpVec;
	SetValue * setvp = new SetValue;
	
	assert(current_contexts.size() == 1);
	setvp->actions.push_back("");
	vp->v.push_back(setvp);
	$$ = vp;
    }
    | index_ranges
    ;

index_ranges:
    '[' action_range ']' {
	SHH("index_ranges --> [ action_range ]");
	IN($2->print());
	SvpVec * vp;
	SetValue * setvp;
	ConstValue * cvp;

	/* Here we are sure to have only the empty context. */
	assert(current_contexts.size() == 1 && $2->v.size() == 1);

	if ($2->v[0]->type() == SymbolValue::Set) {
	    errstream << "Unexpected set";
	    semantic_error();
	}
	setvp = new SetValue;
	setvp->actions.push_back("");
	vp = new SvpVec;
	vp->v.push_back(setvp);
	$$ = indexize_svpvec(vp, $2);

	OUT($$->print());
    }
    | index_ranges '[' action_range ']' {
	SHH("index_ranges --> index_ranges [ action_range ]");
	IN($1->print(); $3->print());

	assert($3->v.size() == $1->v.size());
	if ($3->v[0]->type() == SymbolValue::Set) {
	    errstream << "Unexpected set";
	    semantic_error();
	}
	$$ = indexize_svpvec($1, $3);

	OUT($$->print());
    }
    ;

sequential_composition:
    seq_process_list ';' base_local_process {
	SHH("sequential_composition --> seq_process_list ; \
		base_local_process");
	$$ = $1;
    }
    ;

seq_process_list:
    process_ref {
	SHH("seq_process_list --> process_ref");
	$$ = $1;
    }
    | seq_process_list ';' process_ref {
	SHH("seq_process_list --> seq_process_list ; process_ref");
	$$ = $1;
    }
    ;

process_ref:
    process_id argument_OPT {
	SHH("process_ref --> process_id argument_OPT");
	//TODO
    }
    ;

argument_OPT:
    |'(' argument_list ')' {
	SHH("argument_OPT --> ( argument_list )");
    }
    ;

argument_list:
    expression {
	SHH("argument_list --> expression");
    }
    | argument_list ',' expression {
	SHH("argument_list --> argument_list , expression");
    }
    ;


/* Composite process */
composite_def:
    OR process_id param_OPT '=' composite_body priority_OPT hiding_OPT '.'
    ;

composite_body:
    prefix_label_OPT process_ref relabel_OPT
    | prefix_label_OPT '(' parallel_composition ')' relabel_OPT
    | FORALL ranges composite_body
    | IF expression THEN composite_body
    | IF expression THEN composite_body ELSE composite_body
    ;

parallel_composition:
    composite_body
    | parallel_composition OR composite_body
    ;

prefix_label_OPT:
    | prefix_label
    ;

// TODO add the third option
prefix_label:
    action_labels ':' 
    | action_labels SHARING
    ;

priority_OPT:
    | priority;

priority:
    RSHIFT set
    | LSHIFT set
    ;

ranges_OPT:
    | ranges;

ranges:
    '[' action_range ']'
    | ranges '[' action_range ']'
    ;


/* Parameters */
param_OPT:
    | param {
	SHH("param_OPT -->  param");
    }
    ;

param:
    '(' parameter_list ')' {
	SHH("param -> ( parameter_list )");
    }
    ;

parameter_list:
    parameter {
	SHH("parameter_list --> parameter");
    }
    | parameter_list ',' parameter {
	SHH("parameter_list --> parameter_list , parameter");
    }
    ;

parameter:
    parameter_id '=' expression {
	SHH("parameter --> parameter_id = expression");
	if ($3->v.size() != 1) {
	    // XXX this should never happen..
	    errstream << "Illegal use of variables in parameter declaration";
	    semantic_error();
	}
	ConstValue * cvp = err_if_not_const($3->v[0]);
	$3->detach(0);
	SymbolValue * svp = cvp;
	if (!identifiers.insert(*$1, svp)) {
	    errstream << "identifier " << *$1 << " already declared";
	    semantic_error();
	}
	parameters.push_back($1);
	delete $3;
    }	
    ;


/* Re-Labeling and Hiding */
relabel_OPT:
    | relabel
    ;

relabel:
    '/' '{' relabel_defs '}'
    ;

relabel_defs:
    relabel_def
    | relabel_defs ',' relabel_def
    ;

relabel_def:
    action_labels '/' action_labels
    | FORALL index_ranges '{' relabel_defs '}'
    ;

hiding_OPT:
    | hiding
    ;

hiding:
    '\\' set
    | '@' set
    ;


/* Property, Progress and Menu */
// TODO second form of progress (if S then C)
property_def:
    PROPERTY process_def
    ;

progress_def:
    PROGRESS progress_id ranges_OPT '=' set
    ;

menu_def:
    MENU menu_id '=' set
    ;


/* An expression or a simple_expression: standard operators and priorities. */
expression:
    or_expr {
	SHH("expression --> or_expr");
	$$ = $1;
	OUT($$->print());
    }
    ;

simple_expression:
    additive_expr {
	SHH("simple_expression --> additive_expr");
	$$ = $1;
	OUT($$->print());
    }
    ;

or_expr:
    and_expr
    | or_expr OR and_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = vpl->value || vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

and_expr:
    bitor_expr
    | and_expr AND bitor_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = vpl->value && vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

bitor_expr:
    bitxor_expr
    | bitor_expr '|' bitxor_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value |= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

bitxor_expr:
    bitand_expr
    | bitxor_expr '^' bitand_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value ^= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

bitand_expr:
    equality_expr
    | bitand_expr '&' equality_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value &= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

equality_expr:
    relational_expr
    | equality_expr EQUAL relational_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value == vpr->value);
	}
	delete $3;
	$$ = $1;
    }
    | equality_expr NOTEQUAL relational_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value != vpr->value);
	}
	delete $3;
	$$ = $1;
    }
    ;

relational_expr:
    shift_expr
    | relational_expr '<' shift_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value < vpr->value);
	}
	delete $3;
	$$ = $1;
    }
    | relational_expr '>' shift_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value > vpr->value);
	}
	delete $3;
	$$ = $1;
    }
    | relational_expr LOE shift_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value <= vpr->value);
	}
	delete $3;
	$$ = $1;
    }
    | relational_expr GOE shift_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value >= vpr->value);
	}
	delete $3;
	$$ = $1;
    }
    ;

shift_expr:
    additive_expr
    | shift_expr LSHIFT additive_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value <<= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    | shift_expr RSHIFT additive_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value >>= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

additive_expr:
    multiplicative_expr
    | additive_expr '+' multiplicative_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value += vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    | additive_expr '-' multiplicative_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value -= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

multiplicative_expr:
    unary_expr
    | multiplicative_expr '*' unary_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value *= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    | multiplicative_expr '/' unary_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value /= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    | multiplicative_expr '%' unary_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = vpl->value % vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

unary_expr:
    base_expr
    | '+' base_expr {
	for (int i=0; i<$2->v.size(); i++) {
	    err_if_not_const($2->v[i]);
	}
	$$ = $2;
    }
    | '-' base_expr {
	SvpVec * vp = new SvpVec;
	ConstValue * cvp;
	for (int i=0; i<$2->v.size(); i++) {
	    cvp = err_if_not_const($2->v[i]);
	    cvp->value *= -1;;
	    vp->v.push_back(cvp);
	}
	$$ = vp;
    }
    | '!' base_expr {
	SvpVec * vp = new SvpVec;
	ConstValue * cvp;
	for (int i=0; i<$2->v.size(); i++) {
	    cvp = err_if_not_const($2->v[i]);
	    cvp->value = !(cvp->value);
	    vp->v.push_back(cvp);
	}
	$$ = vp;
    }
    ;

/* TODO: complete base_expr */
base_expr:
    INTEGER {
	SvpVec * vp;
	ConstValue * cvp;

	/* Return a ConstValue* for each context (in non shared mode). */
	vp = new SvpVec;
	vp->shared = false;
	for (int c=0; c<current_contexts.size(); c++) {
	    cvp = new ConstValue;
	    cvp->value = $1;
	    vp->v.push_back(cvp);
	}
	$$ = vp;
    }
    | variable {
	/* Return a ConstValue* for each context (in non shared mode). */
	SvpVec * vp;

	vp = new SvpVec;
	vp->shared = false;
	for (int c=0; c<current_contexts.size(); c++) {
	    SymbolValue * svp;
	    if (!(current_contexts[c]->lookup(*$1, svp))) {
		errstream << "variable " << *$1 << " undeclared\n";
		semantic_error();
	    }
	    svp = svp->clone();
	    vp->v.push_back(svp);
	}
	delete $1;
	$$ = vp;
    }
    | const_range_set_parameter_id {
	SymbolValue * svp;
	SvpVec * vp; 
	
	/* Lookup the identifier and clone the associated object. */
	if (!identifiers.lookup(*$1, svp)) {
	    errstream << "const/range/set/parameter " << *$1
			    << " undeclared";
	    semantic_error();
	}
	delete $1;

	/* Return a ConstValue* for each context (in non shared mode). */
	vp = new SvpVec;
	vp->shared = false;
	for (int c=0; c<current_contexts.size(); c++)
	    vp->v.push_back(svp->clone());
	$$ = vp;
    }
    | '(' expression ')' { $$ = $2; }
    ;

/* Some useful alias for LowerCaseID and UpperCaseID. */
variable: LowerCaseID;
constant_id: UpperCaseID;
range_id: UpperCaseID;
set_id: UpperCaseID;
range_or_set_id: set_id;
const_range_set_parameter_id: set_id;
parameter_id: UpperCaseID;
process_id: UpperCaseID;
progress_id: UpperCaseID;
menu_id: UpperCaseID;

%%

static void fix_unresolved_references(ProcessNode * pnp, void * opaque)
{
    ActionsTable * atp = (ActionsTable *)opaque;

    for (int i=0; i<pnp->children.size(); i++) {
	ProcessEdge& e = pnp->children[i];
	SymbolValue * svp;
	if (e.dest == NULL) {
	    cout << "Unref " << pnp << ": " << actions.reverse[e.action]
		<< " -> " << e.unresolved_reference << "\n";				
	    if (!local_processes.lookup(e.unresolved_reference, svp)) {
		errstream << "Local process " << pnp << ": "
		    << e.unresolved_reference << " undeclared\n";
		semantic_error();
	    }
	    e.dest = ((ProcessValue *)svp)->pnp;
	}
    }
}


int parser()
{
    FILE *fin = fopen("input", "r");
    if (!fin) {
	cout << "I can't open 'input'!" << endl;
	return -1;
    }

    /* Initialize shared data structures: A stack containing a single
       ContextsSet. This set contains a single empty Context and an
       empty frontier. */
    ContextsSet * csp = new ContextsSet;
    csp->append(new Context);
    css.push(csp);


    /* Set flex to read from it instead of defaulting to STDIN. */
    yyin = fin;

    /* Parse through the input until there is no more. */
    do {
	yyparse();
    } while (!feof(yyin));
    
    return 0;
}

void yyerror(const char *s) {
    cout << "Syntax error:" << s << endl;
    // might as well halt now:
    exit(-1);
}

