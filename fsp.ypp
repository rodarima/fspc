%{
#include <cstdio>
#include <iostream>
#include <sstream>
#include <cstdlib>
#include <set>
#include <vector>

using namespace std;

/* Stuff from flex that bison needs to know about. */
extern int yylex();
extern FILE * yyin;

/* Symbols tables. */
#include "strings_table.hpp"
//TODO define these tables here.. move from fspc.cpp
extern struct SymbolsTable identifiers;
extern struct SymbolsTable processes;

/* Main actions table. */
struct ActionsTable actions("Global actions table");

#include "lts.hpp"


#include "context.hpp"

/* Stack of context sets. */
struct ContextsSetStack {
    vector<ContextsSet *> stack;
    int csstop;

    ContextsSetStack() : csstop(-1) { }
    void push(ContextsSet * ctxset) {
	stack.push_back(ctxset);
	csstop++;
    }
    void pop() {
	stack.pop_back();
	csstop--;
    }
    ContextsSet& top() { return *(stack.back()); }
};

struct ContextsSetStack css;
#define current_contexts css.top()


/* Storage for a list of parameters identifiers to remove from the 
   identifiers table when a process definition has been completed. */
vector<string *> parameters;


/* Fix unresolved ProcessNode references due to cyclic processes. */
void fix_unresolved_references(ProcessNode * pnp, void * opaque);


/* For semantic errors */
stringstream errstream;

void semantic_error()
{
    cout << "Semantic error: " << errstream.str() << "\n";
    exit(-1);
}

/* Helper function used to get a ConstValue* from a SymbolValue*. If the
   object pointed is not a constant, a semantic error is issued. */
inline ConstValue* err_if_not_const(SymbolValue * svp)
{
    if (svp->type() != SymbolValue::Const) {
	errstream << "Const expected";
	semantic_error();
    }

    return (ConstValue *)svp;
}

inline RangeValue* err_if_not_range(SymbolValue * svp)
{
    if (svp->type() != SymbolValue::Range) {
	errstream << "Range expected";
	semantic_error();
    }

    return (RangeValue *)svp;
}

inline SetValue* err_if_not_set(SymbolValue * svp)
{
    if (svp->type() != SymbolValue::Set) {
	errstream << "Set expected";
	semantic_error();
    }

    return (SetValue *)svp;
}


string int2string(int x)
{
    stringstream sstr;
    sstr << x;
    return sstr.str();
}

void yyerror(const char *s);
%}

// Bison fundamentally works by asking flex to get the next token, which it
// returns as an object of type "YYSTYPE".  But tokens could be of any
// arbitrary data type!  So we deal with that in Bison by defining a C union
// holding each of the types of tokens that Flex could return, and have Bison
// use that union instead of "int" for the definition of "YYSTYPE":
%union {
    int int_value;
    float float_value;
    std::string *string_ptr;
    class StringsSet *sset_ptr;
    class SymbolValue *sv_ptr;
    class RangeValue *rv_ptr;
    class Lts *lv_ptr;
    class ProcessNode * pn_ptr;
    class ProcessBase * pb_ptr;
    struct SvpVec * svpvec_ptr;
}

// define the "terminal symbol" token types I'm going to use (in CAPS
// by convention), and associate each with a field of the union:


%token IF THEN ELSE
%token WHEN
%token CONST RANGE SET
%token ARROW
%token DOTDOT
%token END STOP ERROR
%token PROPERTY PROGRESS MENU
%token FORALL
%token SHARING
%token OR AND EQUAL NOTEQUAL LOE GOE LSHIFT RSHIFT
%token <int_value> INTEGER
%token <float_value> FLOAT
%token <string_ptr> UpperCaseID
%token <string_ptr> LowerCaseID

%type <svpvec_ptr> simple_expression
%type <svpvec_ptr> base_expr expression unary_expr multiplicative_expr
%type <svpvec_ptr>  additive_expr shift_expr relational_expr equality_expr
%type <svpvec_ptr> bitand_expr bitxor_expr bitor_expr and_expr or_expr

%type <string_ptr> variable constant_id range_id set_id range_or_set_id
%type <string_ptr> parameter_id process_id progress_id menu_id
%type <string_ptr> const_range_set_parameter_id

%type <svpvec_ptr> set set_elements set_expr
%type <svpvec_ptr> action_labels
%type <svpvec_ptr> alphabet_extension_OPT
%type <svpvec_ptr> action_range guard_OPT
%type <svpvec_ptr> range_expr
%type <pn_ptr> choice action_prefix prefix_actions
%type <pb_ptr> process_body local_process local_process_defs local_process_def
%type <pb_ptr> sequential_composition base_local_process
%type <pb_ptr> seq_process_list process_ref

%glr-parser

%%

/* Start symbol: an arbitrary long list of fsp_definitions */
fsp_description:
    fsp_definition
    | fsp_description fsp_definition
    ;

/* All the possible type of fsp_definitions */
fsp_definition:
    constant_def
    | range_def
    | set_def
    | property_def
    | progress_def
    | menu_def
    | process_def
    | composite_def
    ;


/* Action labels TODO: fix */
action_labels:
    LowerCaseID {
	SvpVec * vp;
	SetValue * setvp; 

	vp = new SvpVec;
	vp->shared = false;
	for (int c=0; c<current_contexts.size(); c++) {
	    setvp = new SetValue;
	    setvp->actions.push_back(*$1);
	    vp->v.push_back(setvp);
	}
	delete $1;
	$$ = vp;
	cout << "<<B>> als\n";
	vp->print();
    }
    | set
    | action_labels '.' LowerCaseID {
	if ($1->v.size() != current_contexts.size()) {cout<<"FATAL 561\n";exit(-1);}
	SetValue * setvp;
	for (int i=0; i<$1->v.size(); i++) {
	    setvp = err_if_not_set($1->v[i]);
	    for (int j=0; j<setvp->actions.size(); j++)
		setvp->actions[j] += "." + *$3;
	}
	delete $3;
	$$ = $1;
    }
    | action_labels '.' set {
/*
	$1->dotcat(*$3);
	delete $3;
*/
	$$ = $1;
    }
    | action_labels '[' action_range ']' {
	cout << "<<B>> als[action_range]\n";
	cout<<"$1 = ";$1->print();cout<<"$3 = ";$3->print();
	if ($1->v.size() != $3->v.size() ||
		$1->v.size() != current_contexts.size())
	     {cout<<"FATAL 215 \n"; exit(-1);}
	SvpVec * vp;
	SetValue * setvp;
	SetValue * rsetvp;
	RangeValue * rvp;
	ConstValue * cvp;
	ContextsSet * csp; 
	Context * cxp;
	/* type() and 'variable' is the same for all the elements in 
	   'action_range'. */
	switch ($3->v[0]->type()) {
	    case SymbolValue::Range:
		rvp = err_if_not_range($3->v[0]);
		if (rvp->variable != "") {
		    /* In this case each element in action_range is in the
		       form 'var:R', where R is a range_id or a range_expr. */
		    csp = new ContextsSet;
		    vp = new SvpVec;
		    for (int c=0; c<$1->v.size(); c++) {
			setvp = err_if_not_set($1->v[c]);
			rvp = err_if_not_range($3->v[c]);
			for (int j=rvp->low; j<=rvp->high; j++) {
			    SetValue * new_setvp = new SetValue(*setvp);
			    for (int k=0; k<new_setvp->actions.size(); k++)
				new_setvp->actions[k] += "[" +
				    int2string(j) + "]";
			    vp->v.push_back(new_setvp);
			    cxp = current_contexts[c];
			    cxp = new Context(*cxp);
			    if (!cxp->insert(rvp->variable, j)) {
				errstream << "Variable " << rvp->variable
				    << " declared twice\n";
				semantic_error();
			    }
			    csp->append(cxp);
			}
		    }
		    cout << "Contexts ramification\n";
		    css.push(csp);
		    current_contexts.print();
		    delete $1;
		    delete $3;
		    $$ = vp;
		} else {
		    /* In this case each element in action_range is in the
		       form "R", where R is a range_id or a range_expr. */
		    for (int c=0; c<$1->v.size(); c++) {
			setvp = err_if_not_set($1->v[c]);
			rvp = err_if_not_range($3->v[c]);
			SetValue * new_setvp = new SetValue;
			for (int k=0; k<setvp->actions.size(); k++)
			    for (int j=rvp->low; j<=rvp->high; j++)
				new_setvp->actions.push_back(
				    setvp->actions[k] + "[" + int2string(j)
					+ "]");
			delete $1->v[c];
			$1->v[c] = new_setvp;
		    }
		    delete $3;
		    $$ = $1;
		}
		break;

	    case SymbolValue::Const:
		for (int i=0; i<$1->v.size(); i++) {
		    setvp = err_if_not_set($1->v[i]);
		    cvp = err_if_not_const($3->v[i]);
		    for (int k=0; k<setvp->actions.size(); k++) 
			setvp->actions[k] += "[" + int2string(cvp->value)
						     + "]";
		}
		delete $3;
		$$ = $1;
		break;
	    case SymbolValue::Set:
		setvp = err_if_not_set($3->v[0]);
		if (setvp->variable != "") {
		    /* In this case each element in action_range is in the
		       form 'var:R', where R is a set_id or a set_expr. */
		    csp = new ContextsSet;
		    /* We need a new SvpVec for a new ContextSet. */
		    vp = new SvpVec;
		    for (int c=0; c<$1->v.size(); c++) {
			setvp = err_if_not_set($1->v[c]);
			rsetvp = err_if_not_set($3->v[c]);
			for (int j=0; j<rsetvp->actions.size(); j++) {
			    SetValue * new_setvp = new SetValue(*setvp);
			    for (int k=0; k<new_setvp->actions.size(); k++)
				new_setvp->actions[k] += "." +
				    rsetvp->actions[j];
			    /* Create a new context (extending the previous
			       one) and append the new SetValue to associate
			       to this context.*/
			    vp->v.push_back(new_setvp);
			    cxp = current_contexts[c];
			    cxp = new Context(*cxp);
			    if (!cxp->insert(rsetvp->variable,
				    rsetvp->actions[j])) {
				errstream << "Variable " << rsetvp->variable
				    << " declared twice\n";
				semantic_error();
			    }
			    /* Append the new Context to the new ContextSet. 
				*/
			    csp->append(cxp);
			}
		    }
		    cout << "Contexts ramification\n";
		    css.push(csp);
		    current_contexts.print();
		    delete $1;
		    delete $3;
		    $$ = vp;
		} else {
		    for (int c=0; c<$1->v.size(); c++) {
			setvp = err_if_not_set($1->v[c]);
			rsetvp = err_if_not_set($3->v[c]);
			/* Create a new SetValue that combines setvp and
			   rsetvp. No context ramification happens here. */
			SetValue * new_setvp = new SetValue;
			for (int k=0; k<setvp->actions.size(); k++)
			    for (int j=0; j<rsetvp->actions.size(); j++)
				new_setvp->actions.push_back(
				    setvp->actions[k] + "." +
					rsetvp->actions[j]);
			delete $1->v[c];
			$1->v[c] = new_setvp;
		    }
		    delete $3;
		    $$ = $1;
		}
		break;

	    default:
		cout << "WHAT!?!?!?\n";
		break;
	}
	$$->print();
/*
	StringsSet * ssp;
	ConstValue * cvp;
	RangeValue * rvp;

	switch ($3->type()) {
	    case SymbolValue::Const:
		cvp = ((ConstValue *)$3);
		$1->indexize(cvp->value);
		break;

	    case SymbolValue::Range:
		rvp = ((RangeValue *)$3);
		$1->print();
		$1->indexize(rvp->low, rvp->high);
		break;

	    case SymbolValue::Set:
		ssp = ((SetValue *)$3)->ssp;
		$1->indexize(*ssp);
		break;

	    default:
		errstream << "Internal error: unexpected symbol type\n";
		semantic_error();
	};

	delete $3;
*/
    }
    ;

set:
    set_id {
	SvpVec * vp = new SvpVec;
	SymbolValue * svp;
	SetValue * setvp;
	if (!identifiers.lookup(*$1, svp)) {
	    errstream << "set " << *$1 << " undeclared";
	    semantic_error();
	}
	delete $1;
	setvp = err_if_not_set(svp);

	//setvp->cloneActions(vp);
	vp->shared = true;
	for (int c=0; c<current_contexts.size(); c++)
	    vp->v.push_back(setvp);
	$$ = vp;
    }
    | set_expr
    ;

set_expr:
    '{' set_elements '}' {
	cout << "Set expression:\n";
	$2->print();
	$$ = $2;
    }
    ;

action_range:
    expression {
	$$ = $1;
    }
    | range_expr {
	$$ = $1;
    }
    | set_expr {
	$$ = $1;
    }
    | variable ':' range_or_set_id {
	cout << "Variable definition: " << *$1 << ":" << *$3 << "\n";
	SvpVec * vp = new SvpVec;
	SymbolValue * svp;
	if (!identifiers.lookup(*$3, svp)) {
	    errstream << "range/set " << *$3 << " undeclared";
	    semantic_error();
	}
	svp = svp->clone();
	/* Pass the variable name to the upper levels.*/
	switch (svp->type()) {
	    case SymbolValue::Range:
		((RangeValue *)svp)->variable = *$1;
		break;
	    case SymbolValue::Set:
		((SetValue *)svp)->variable = *$1;
		break;
	    default:
		errstream << "range or set identifier expected";
		semantic_error();
	}
	delete $1;
	vp->shared = true;
	for (int c=0; c<current_contexts.size(); c++)
	    vp->v.push_back(svp);
	$$ = vp;
	
    }
    | variable ':' range_expr {
	/* Pass the variable to the upper levels.*/
	RangeValue * rvp;
	for (int i=0; i<$3->v.size(); i++) {
	    rvp = (RangeValue *)($3->v[i]);
	    rvp->variable = *$1;
	}
	delete $1;
	$$ = $3;
    }
    | variable ':' set_expr {
	//TODO variable
	SetValue * setvp;
	for (int i=0; i<$3->v.size(); i++) {
	    setvp = err_if_not_set($3->v[i]);
	    setvp->variable = *$1;
	}
	delete $1;
	$$ = $3;
    }
    ;

range_expr:
    expression DOTDOT expression {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	RangeValue * rvp;
	ConstValue * cvp;
	SvpVec * vp = new SvpVec;
	for (int i=0; i<$1->v.size(); i++) {
	    rvp = new RangeValue;
	    cvp = err_if_not_const($1->v[i]);
	    rvp->low = cvp->value;
	    cvp = err_if_not_const($3->v[i]);
	    rvp->high = cvp->value;
	    vp->v.push_back(rvp);
	}
	delete $1;
	delete $3;
	$$ = vp;
	$$->print();
    }
    ;


/* Const, Range, Set */
constant_def:
    CONST constant_id '=' simple_expression {
	if ($4->v.size() != 1) {
	    // XXX this should never happen, because we get an "undeclared"
	    errstream << "Illegal use of variables in const declaration";
	    semantic_error();
	}
	ConstValue* cvp = err_if_not_const($4->v[0]);
	$4->detach(0);
	cout << "<<B>> Const " << *$2 << "=" << cvp->value << "\n";
	if (!identifiers.insert(*$2, cvp)) {
	    errstream << "const " << *$2 << " declared twice";
	    semantic_error();
	}
	delete $4;
	delete $2;
    };

range_def:
    RANGE range_id '=' simple_expression DOTDOT simple_expression {
	if ($4->v.size() != 1 || $6->v.size() != 1) {
	    // XXX this should never happen, because we get an "undeclared"
	    errstream << "Illegal use of variables in range declaration";
	    semantic_error();
	}
	RangeValue* rvp = new RangeValue;
	ConstValue * cvp1 = err_if_not_const($4->v[0]);
	ConstValue * cvp2 = err_if_not_const($6->v[0]);
	cout << "<<B>> Range " << *$2 << cvp1->value << cvp2->value << "\n";
	rvp->low = cvp1->value;
	rvp->high = cvp2->value;
	//delete cvp1; // done below
	//delete cvp2;
	delete $4;
	delete $6;
	if (!identifiers.insert(*$2, rvp)) {
	    errstream << "range " << *$2 << " declared twice";
	    semantic_error();
	}
	delete $2;
    };

set_def:
    SET set_id '=' '{' set_elements '}' {
	cout << "<<B>> Set\n"; $5->print();
	// TODO convert from SvpVec to SetValue
	if (!identifiers.insert(*$2, $5->v[0])) {
	    errstream << "set " << *$2 << " declared twice";
	    semantic_error();
	}
	$5->detach(0);
	delete $5;
	delete $2;
    };

set_elements:
    action_labels {
	$$ = $1;
    }
    | set_elements ',' action_labels {
	cout << "<<B>> set_el als\n";
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL 719\n";exit(-1);}
	for (int i=0; i<$1->v.size(); i++) {
	    SetValue * setvp = err_if_not_set($1->v[i]);
	    SetValue * rsetvp = err_if_not_set($3->v[i]);
	    for (int k=0; k<rsetvp->actions.size(); k++)
		setvp->actions.push_back(rsetvp->actions[k]);
    /*
	    $1->v.push_back($3->v[i]);
	    $3->detach(i); */
	}
	delete $3;
	$$ = $1;

/*
	*$1 += *$3;
	delete $3;
	$$ = $1; */
    }
    ;


/* Processes */
process_def:
    process_id param_OPT {
	/* Parameters have been pushed inside the 'param_OPT' rule.
	   A cleaner approach would be to get a list of parameters from
	   the rule and push the parameters into the 'identifiers' table
	   in this action. */
	;
    }
    '=' process_body alphabet_extension_OPT relabel_OPT hiding_OPT '.' {
	if ($5->unresolved()) {
	    errstream << "Local process " << 
		    ((UnresolvedProcess * )$5)->reference << " undeclared\n";
	    semantic_error();
	}

	/* Insert a new ProcessValue in the symbol table, attaching the
	   process_body to it. */
	ProcessValue * pvp = new ProcessValue;
	cout << "Process " << *$1 << " defined\n";
	if (!processes.insert(*$1, pvp)) {
	    errstream << "process " << *$1 << " declared twice";
	    semantic_error();
	}
	pvp->pnp = (ProcessNode *)$5;

	/* Try to resolve all the undefined references into this process. */
	struct ProcessVisitObject f;
	f.vfp = &fix_unresolved_references;
	f.opaque = &actions;
	pvp->pnp->visit(f);

	pvp->pnp->print(&actions);

	/* Convert the collection of ProcessNodes in an Lts object. */
	Lts lts(pvp->pnp, &actions);

	/* Now we can free the graph pointed by pvp->pnp. */
	freeProcessNodeGraph(pvp->pnp);

	/* Extend the alphabet if is the case. */
    /*
	if ($6) {
	    for (int i=0; i<$6->strings.size(); i++)
		lts.updateAlphabet(actions.insert($6->strings[i]));
		delete $6;
	} */

	/* Remove process parameters from the identifiers. */
	for (int i=0; i<parameters.size(); i++) {
	    identifiers.remove(*(parameters[i]));
	    delete parameters[i];
	}
	parameters.clear();

	lts.print();

	lts.graphvizOutput((*$1 += ".gv").c_str());
	delete $1;

	// TODO implement everything is OPT
    }
    ;

process_body:
    local_process
    | local_process ',' local_process_defs {
	// TODO compose
	$$ = $1;
    }
    ;

local_process_defs:
    local_process_def
    | local_process_defs ',' local_process_def {
	// TODO compose
	$$ = $1;
    }
    ;

local_process_def:
    process_id index_ranges_OPT '=' local_process {
	// TODO index_ranges_OPT
	$$ = $4;
    }
    ;

alphabet_extension_OPT:
    {
	$$ = NULL;
    }
    | '+' set {
	$$ = $2;
    }
    ;

local_process:
    base_local_process
    | sequential_composition
    | IF expression THEN local_process {
	ConstValue * cvp;
	if ($2->v.size() > 1) {cout < "TODO IF THEN\n"; exit(-1);} //TODO
	cvp = err_if_not_const($2->v[0]);
	if (cvp->value)
	    $$ = $4;
	else {
	    /* If the condition is not true, return a STOP process. */
	    if ($4->unresolved())
		delete $4;
	    else
		freeProcessNodeGraph((ProcessNode *)$4);
	    $$ = new ProcessNode;
	}
	delete $2;
    }
    | IF expression THEN local_process ELSE local_process {
	ConstValue * cvp; 
	ProcessBase * pbp;
	if ($2->v.size() > 1) {cout < "TODO IF THEN\n"; exit(-1);} //TODO
	cvp = err_if_not_const($2->v[0]);
	if (cvp->value) {
	    pbp = $6;
	    $$ = $4;
	} else {
	    pbp = $4;
	    $$ = $6;
	}
	if (pbp->unresolved())
	    delete pbp;
	else
	    freeProcessNodeGraph((ProcessNode *)pbp);
	delete $2;
    }
    | '(' choice ')' {
	//$2->print();
	$$ = $2;
    }
    ;

base_local_process:
    END {
	$$ = new ProcessNode(ProcessNode::End);
    }
    | STOP {
	$$ = new ProcessNode;
    }
    | ERROR {
	$$ = new ProcessNode(ProcessNode::Error);
    }
    | process_id indices_OPT {
	//TODO implement indices_OPT
	SymbolValue * svp;
	/* If the process referenced is already defined, return it.
	   Otherwise return a new UnresolvedProcess object, so that the
	   upper level sees that *$1 is unresolved. */
	if (processes.lookup(*$1, svp))
	    $$ = ((ProcessValue *)svp)->pnp;
	else
	    $$ = new UnresolvedProcess(*$1);
    }
    ;

choice:
    action_prefix
    | choice '|' action_prefix {
	cout << "Choice\n";
	/* Merge $1 head and $3 head. Don't care about frontier_shortcut
	   merging, since we will not need them anymore. */
	for (int i=0; i<$3->children.size(); i++)
	    $1->children.push_back($3->children[i]);
	/* We must delete only the ProcessNode pointed by $, but not the
	   whole graph! */
	delete $3;
	//$1->print();
	$$ = $1;
    }
    ;

action_prefix:
    guard_OPT prefix_actions ARROW local_process {
	// TODO guard_OPT

	if (!($4->unresolved())) {
	    /* If $4 is not an unresolved reference, we connect the frontier 
	       of $2 to the process $4. */
	    for (int i=0; i<$2->frontier_shortcut.size(); i++) {
		ProcessNode * pnp = $2->frontier_shortcut[i];
		for (int j=0; j<pnp->children.size(); j++)
		    pnp->children[j].dest = (ProcessNode *)$4;
	    }
	} else {
	    /* If $4 is an unresolved reference, we scan the frontier of $2
	       recording the reference itslef, so that this reference will
	       be fixed by the upper levels. */
	    string reference = ((UnresolvedProcess *)$4)->reference;
	    for (int i=0; i<$2->frontier_shortcut.size(); i++) {
		ProcessNode * pnp = $2->frontier_shortcut[i];
		for (int j=0; j<pnp->children.size(); j++) {
		    pnp->children[j].unresolved_reference = reference;
		}
	    }
	}
	//$2->print();
	$$ = $2;
    }
    ;

prefix_actions:
    action_labels {
/*
	cout << "Action: "; $1->print();
	ProcessNode * pnp = new ProcessNode;
	ProcessEdge e;

	pnp->type = ProcessNode::Normal;
	pnp->frontier_shortcut.push_back(pnp);
	for (int i=0; i<$1->strings.size(); i++) {
	    e.action = actions.insert($1->strings[i]);
	    e.dest = NULL;
	    pnp->children.push_back(e);
	}
	delete $1;
	//pnp->print();
	$$ = pnp;
*/
	    
    }
    | prefix_actions ARROW action_labels {
/*
	cout << "Action(->): "; $3->print();
	ProcessNode * rpnp = new ProcessNode;
	ProcessEdge e;

	rpnp->type = ProcessNode::Normal;
	for (int i=0; i<$3->strings.size(); i++) {
	    e.action = actions.insert($3->strings[i]);
	    e.dest = NULL;
	    rpnp->children.push_back(e);
	}
	delete $3;
	//rpnp->print();
*/
	/* Attach an rpnp clone to each node in the frontier. */
/*
	vector<ProcessNode*> new_frontier(1);
	$1->frontier_shortcut[0]->children[0].dest = rpnp;
	new_frontier[0] = rpnp;
	for (int i=0; i<$1->frontier_shortcut.size(); i++) {
	    ProcessNode * pnp = $1->frontier_shortcut[i];
	    cout << "Frontier element: " << pnp << "\n";
	    for (int j=0; j<pnp->children.size(); j++)
		if (i || j) {
		    pnp->children[j].dest = rpnp->clone();
		    new_frontier.push_back(pnp->children[j].dest);
		}
	}
	$1->frontier_shortcut = new_frontier;
	
	//$1->print();
	$$ = $1;
*/
    }
    ;

guard_OPT:
    {
	$$ = NULL;
    }
    | WHEN expression {
	ConstValue * cvp;
	for (int i=0; i<$2->v.size(); i++) {
	    err_if_not_const($2->v[i]);
	}
	$$ = $2;
    }
    ;

indices_OPT:
    | indices
    ;

indices:
    '[' expression ']'
    | indices '[' expression ']'
    ;

index_ranges_OPT:
    | index_ranges
    ;

index_ranges:
    '[' expression ']'
    | index_ranges '[' expression ']'
    | '[' action_range ']'
    | index_ranges '[' action_range ']'
    ;

sequential_composition:
    seq_process_list ';' base_local_process
    ;

seq_process_list:
    process_ref
    | seq_process_list ';' process_ref
    ;

process_ref:
    process_id argument_OPT {
	//TODO
	ProcessNode * pnp = new ProcessNode;
	$$ = pnp;
    }
    ;

argument_OPT:
    |'(' argument_list ')'
    ;

argument_list:
    expression
    | argument_list ',' expression
    ;


/* Composite process */
composite_def:
    OR process_id param_OPT '=' composite_body priority_OPT hiding_OPT '.'
    ;

composite_body:
    prefix_label_OPT process_ref relabel_OPT
    | prefix_label_OPT '(' parallel_composition ')' relabel_OPT
    | FORALL ranges composite_body
    | IF expression THEN composite_body
    | IF expression THEN composite_body ELSE composite_body
    ;

parallel_composition:
    composite_body
    | parallel_composition OR composite_body
    ;

prefix_label_OPT:
    | prefix_label
    ;

// TODO add the third option
prefix_label:
    action_labels ':' 
    | action_labels SHARING
    ;

priority_OPT:
    | priority;

priority:
    RSHIFT set
    | LSHIFT set
    ;

ranges_OPT:
    | ranges;

ranges:
    '[' action_range ']'
    | ranges '[' action_range ']'
    ;


/* Parameters */
param_OPT:
    | param
    ;

param:
    '(' parameter_list ')'
    ;

parameter_list:
    parameter
    | parameter_list ',' parameter
    ;

parameter:
    parameter_id '=' expression {
	if ($3->v.size() != 1) {
	    // XXX this should never happen..
	    errstream << "Illegal use of variables in parameter declaration";
	    semantic_error();
	}
	ConstValue * cvp = err_if_not_const($3->v[0]);
	$3->detach(0);
	SymbolValue * svp = cvp;
	if (!identifiers.insert(*$1, svp)) {
	    errstream << "identifier " << *$1 << " already declared";
	    semantic_error();
	}
	parameters.push_back($1);
	delete $3;
    }	
    ;


/* Re-Labeling and Hiding */
relabel_OPT:
    | relabel
    ;

relabel:
    '/' '{' relabel_defs '}'
    ;

relabel_defs:
    relabel_def
    | relabel_defs ',' relabel_def
    ;

relabel_def:
    action_labels '/' action_labels
    | FORALL index_ranges '{' relabel_defs '}'
    ;

hiding_OPT:
    | hiding
    ;

hiding:
    '\\' set
    | '@' set
    ;


/* Property, Progress and Menu */
// TODO second form of progress (if S then C)
property_def:
    PROPERTY process_def
    ;

progress_def:
    PROGRESS progress_id ranges_OPT '=' set
    ;

menu_def:
    MENU menu_id '=' set
    ;


/* An expression or a simple_expression: standard operators and priorities. */
expression:
    or_expr {
	$$ = $1;
	cout << "<<B>> Expression(s): ";
	$1->print();
    }
    ;

simple_expression:
    additive_expr {
	$$ = $1;
	cout << "<<B>> Simple expression(s): ";
	$1->print();
    }
    ;

or_expr:
    and_expr
    | or_expr OR and_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = vpl->value || vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

and_expr:
    bitor_expr
    | and_expr AND bitor_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = vpl->value && vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

bitor_expr:
    bitxor_expr
    | bitor_expr '|' bitxor_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value |= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

bitxor_expr:
    bitand_expr
    | bitxor_expr '^' bitand_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value ^= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

bitand_expr:
    equality_expr
    | bitand_expr '&' equality_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value &= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

equality_expr:
    relational_expr
    | equality_expr EQUAL relational_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value == vpr->value);
	}
	delete $3;
	$$ = $1;
    }
    | equality_expr NOTEQUAL relational_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value != vpr->value);
	}
	delete $3;
	$$ = $1;
    }
    ;

relational_expr:
    shift_expr
    | relational_expr '<' shift_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value < vpr->value);
	}
	delete $3;
	$$ = $1;
    }
    | relational_expr '>' shift_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value > vpr->value);
	}
	delete $3;
	$$ = $1;
    }
    | relational_expr LOE shift_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value <= vpr->value);
	}
	delete $3;
	$$ = $1;
    }
    | relational_expr GOE shift_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value >= vpr->value);
	}
	delete $3;
	$$ = $1;
    }
    ;

shift_expr:
    additive_expr
    | shift_expr LSHIFT additive_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value <<= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    | shift_expr RSHIFT additive_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value >>= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

additive_expr:
    multiplicative_expr
    | additive_expr '+' multiplicative_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value += vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    | additive_expr '-' multiplicative_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value -= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

multiplicative_expr:
    unary_expr
    | multiplicative_expr '*' unary_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value *= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    | multiplicative_expr '/' unary_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value /= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    | multiplicative_expr '%' unary_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = vpl->value % vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

unary_expr:
    base_expr
    | '+' base_expr {
	for (int i=0; i<$2->v.size(); i++) {
	    err_if_not_const($2->v[i]);
	}
	$$ = $2;
    }
    | '-' base_expr {
	SvpVec * vp = new SvpVec;
	ConstValue * cvp;
	for (int i=0; i<$2->v.size(); i++) {
	    cvp = err_if_not_const($2->v[i]);
	    cvp->value *= -1;;
	    vp->v.push_back(cvp);
	}
	$$ = vp;
    }
    | '!' base_expr {
	SvpVec * vp = new SvpVec;
	ConstValue * cvp;
	for (int i=0; i<$2->v.size(); i++) {
	    cvp = err_if_not_const($2->v[i]);
	    cvp->value = !(cvp->value);
	    vp->v.push_back(cvp);
	}
	$$ = vp;
    }
    ;

/* TODO: complete base_expr */
base_expr:
    INTEGER {
	SvpVec * vp;
	ConstValue * cvp;

	/* Return a ConstValue* for each context (in non shared mode). */
	vp = new SvpVec;
	vp->shared = false;
	for (int c=0; c<current_contexts.size(); c++) {
	    cvp = new ConstValue;
	    cvp->value = $1;
	    vp->v.push_back(cvp);
	}
	$$ = vp;
    }
    | variable {
	/* Return a ConstValue* for each context (in non shared mode). */
	SvpVec * vp;

	vp = new SvpVec;
	vp->shared = false;
	for (int c=0; c<current_contexts.size(); c++) {
	    SymbolValue * svp;
	    if (!(current_contexts[c]->lookup(*$1, svp))) {
		errstream << "variable " << *$1 << " undeclared\n";
		semantic_error();
	    }
	    svp = svp->clone();
	    vp->v.push_back(svp);
	}
	delete $1;
	$$ = vp;
    }
    | const_range_set_parameter_id {
	SymbolValue * svp;
	SvpVec * vp; 
	
	/* Lookup the identifier and clone the associated object. */
	if (!identifiers.lookup(*$1, svp)) {
	    errstream << "const/range/set/parameter " << *$1
			    << " undeclared";
	    semantic_error();
	}
	delete $1;

	/* Return a ConstValue* for each context (in non shared mode). */
	vp = new SvpVec;
	vp->shared = false;
	for (int c=0; c<current_contexts.size(); c++)
	    vp->v.push_back(svp->clone());
	$$ = vp;
    }
    | '(' expression ')' { $$ = $2; }
    ;

/* Some useful alias for LowerCaseID and UpperCaseID. */
variable: LowerCaseID;
constant_id: UpperCaseID;
range_id: UpperCaseID;
set_id: UpperCaseID;
range_or_set_id: set_id;
const_range_set_parameter_id: set_id;
parameter_id: UpperCaseID;
process_id: UpperCaseID;
progress_id: UpperCaseID;
menu_id: UpperCaseID;

%%

void fix_unresolved_references(ProcessNode * pnp, void * opaque)
{
    ActionsTable * atp = (ActionsTable *)opaque;

    for (int i=0; i<pnp->children.size(); i++) {
	ProcessEdge& e = pnp->children[i];
	SymbolValue * svp;
	if (e.dest == NULL) {
	    cout << "Unref " << pnp << ": " << actions.reverse[e.action]
		<< " -> " << e.unresolved_reference << "\n";				
	    if (!processes.lookup(e.unresolved_reference, svp)) {
		errstream << "Local process " << pnp << ": "
		    << e.unresolved_reference << " undeclared\n";
		semantic_error();
	    }
	    e.dest = ((ProcessValue *)svp)->pnp;
	}
    }
}


int parser()
{
    FILE *fin = fopen("input", "r");
    if (!fin) {
	cout << "I can't open 'input'!" << endl;
	return -1;
    }

    /* Initialize shared data structures: A stack containing a single
       ContextsSet. This set contains a single empty Context. */
    ContextsSet * csp = new ContextsSet;
    csp->append(new Context);
    css.push(csp);


    /* Set flex to read from it instead of defaulting to STDIN. */
    yyin = fin;

    /* Parse through the input until there is no more. */
    do {
	yyparse();
    } while (!feof(yyin));
    
    return 0;
}

void yyerror(const char *s) {
    cout << "Syntax error:" << s << endl;
    // might as well halt now:
    exit(-1);
}

