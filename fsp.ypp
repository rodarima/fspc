%{
#include <cstdio>
#include <iostream>
using namespace std;

/* Stuff from flex that bison needs to know about. */
extern int yylex();
extern FILE * yyin;

/* Main identifiers table. */
#include "strings_table.hpp"
extern struct SymbolsTable identifiers;


void T(int x)
{
    cout << "<<B>> " << x << "\n";
}

void yyerror(const char *s);
%}

// Bison fundamentally works by asking flex to get the next token, which it
// returns as an object of type "YYSTYPE".  But tokens could be of any
// arbitrary data type!  So we deal with that in Bison by defining a C union
// holding each of the types of tokens that Flex could return, and have Bison
// use that union instead of "int" for the definition of "YYSTYPE":
%union {
    int int_value;
    float float_value;
    char *string_value;
}

// define the "terminal symbol" token types I'm going to use (in CAPS
// by convention), and associate each with a field of the union:


%token IF THEN ELSE
%token WHEN
%token CONST RANGE SET
%token ARROW
%token DOTDOT
%token END STOP ERROR
%token PROPERTY PROGRESS MENU
%token FORALL
%token SHARING
%token OR AND EQUAL NOTEQUAL LOE GOE LSHIFT RSHIFT
%token <int_value> INTEGER
%token <float_value> FLOAT
%token <string_value> UpperCaseID
%token <string_value> LowerCaseID


%type <int_value> base_expr simple_expression expression unary_expr
%type <int_value> multiplicative_expr additive_expr shift_expr relational_expr
%type <int_value> equality_expr bitand_expr bitxor_expr bitor_expr and_expr
%type <int_value> or_expr

%type <string_value> variable constant_id range_id set_id range_or_set_id
%type <string_value> parameter_id process_id progress_id menu_id


%glr-parser

%%

/* Start symbol: an arbitrary long list of fsp_definitions */
fsp_description:
    fsp_definition
    | fsp_description fsp_definition
    ;

/* All the possible type of fsp_definitions */
fsp_definition:
    constant_def
    | range_def
    | set_def
    | property_def
    | progress_def
    | menu_def
    | process_def
    | composite_def
    ;


/* Action labels TODO: fix */
action_labels:
    LowerCaseID
    | set
    | action_labels '.' LowerCaseID
    | action_labels '.' set
    | action_labels '[' action_range ']'
    | action_labels '[' expression ']'
    ;

set:
    set_id
    | set_expr
    ;

set_expr:
    '{' set_elements '}'
    ;

action_range:
    range_or_set_id
    | range_expr
    | set_expr
    | variable ':' range_or_set_id
    | variable ':' range_expr
    | variable ':' set_expr
    ;

range_expr:
    expression DOTDOT expression
    ;


/* Const, Range, Set */
constant_def:
    CONST constant_id '=' simple_expression {
	cout << "<<B>> Const " << $2 << "=" << $4 << "\n";
	int v = $4;
	int ok = identifiers.insert(string($2), v);
	if (ok)
	    cout << "Inserted\n";
	else
	    cout << "Duplicate!\n";
    };

range_def:
    RANGE range_id '=' simple_expression DOTDOT simple_expression {
	cout << "<<B>> Range\n";
    };

set_def:
    SET set_id '=' '{' set_elements '}' {
	cout << "<<B>> Set\n";
    };

set_elements:
    action_labels
    | set_elements ',' action_labels
    ;


/* Processes */
process_def:
    process_id param_OPT '=' process_body alphabet_extension_OPT 
    relabel_OPT hiding_OPT '.'
    ;

process_body:
    local_process
    | local_process ',' local_process_defs
    ;

local_process_defs:
    local_process_def
    | local_process_defs ',' local_process_def
    ;

local_process_def:
    process_id index_ranges_OPT '=' local_process
    ;

alphabet_extension_OPT:
    | '+' set
    ;

local_process:
    base_local_process
    | sequential_composition
    | IF expression THEN local_process
    | IF expression THEN local_process ELSE local_process
    | '(' choice ')'
    ;

base_local_process:
    END
    | STOP
    | ERROR
    | process_id indices_OPT
    ;

choice:
    action_prefix
    | choice '|' action_prefix
    ;

action_prefix:
    guard_OPT prefix_actions ARROW local_process
    ;

prefix_actions:
    action_labels
    | prefix_actions ARROW action_labels
    ;

guard_OPT:
    | WHEN expression
    ;

indices_OPT:
    | indices
    ;

indices:
    '[' expression ']'
    | indices '[' expression ']'
    ;

index_ranges_OPT:
    | index_ranges
    ;

index_ranges:
    '[' expression ']'
    | index_ranges '[' expression ']'
    | '[' action_range ']'
    | index_ranges '[' action_range ']'
    ;

sequential_composition:
    seq_process_list ';' base_local_process
    ;

seq_process_list:
    process_ref
    | seq_process_list ';' process_ref
    ;

process_ref:
    process_id argument_OPT
    ;

argument_OPT:
    |'(' argument_list ')'
    ;

argument_list:
    expression
    | argument_list ',' expression
    ;


/* Composite process */
composite_def:
    OR process_id param_OPT '=' composite_body priority_OPT hiding_OPT '.'
    ;

composite_body:
    prefix_label_OPT process_ref relabel_OPT
    | prefix_label_OPT '(' parallel_composition ')' relabel_OPT
    | FORALL ranges composite_body
    | IF expression THEN composite_body
    | IF expression THEN composite_body ELSE composite_body
    ;

parallel_composition:
    composite_body
    | parallel_composition OR composite_body
    ;

prefix_label_OPT:
    | prefix_label
    ;

// TODO add the third option
prefix_label:
    action_labels ':' 
    | action_labels SHARING
    ;

priority_OPT:
    | priority;

priority:
    RSHIFT set
    | LSHIFT set
    ;

ranges_OPT:
    | ranges;

ranges:
    '[' action_range ']'
    | ranges '[' action_range ']'
    ;


/* Parameters */
param_OPT:
    | param
    ;

param:
    '(' parameter_list ')'
    ;

parameter_list:
    parameter
    | parameter_list ',' parameter
    ;

parameter:
    parameter_id '=' expression
    ;


/* Re-Labeling and Hiding */
relabel_OPT:
    | relabel
    ;

relabel:
    '/' '{' relabel_defs '}'
    ;

relabel_defs:
    relabel_def
    | relabel_defs ',' relabel_def
    ;

relabel_def:
    action_labels '/' action_labels
    | FORALL index_ranges '{' relabel_defs '}'
    ;

hiding_OPT:
    | hiding
    ;

hiding:
    '\\' set
    | '@' set
    ;


/* Property, Progress and Menu */
// TODO second form of progress (if S then C)
property_def:
    PROPERTY process_def
    ;

progress_def:
    PROGRESS progress_id ranges_OPT '=' set
    ;

menu_def:
    MENU menu_id '=' set
    ;


/* An expression or a simple_expression: standard operators and priorities. */
expression:
    or_expr {
	$$ = $1;
	cout << "<<B>> Expression: " << $1 <<  "\n";
    }
    ;

simple_expression:
    additive_expr {
	$$ = $1;
	cout << "<<B>> Simple expression: " << $1 <<  "\n";
    }
    ;

or_expr:
    and_expr
    | or_expr OR and_expr { $$ = ($1 || $3); }
    ;

and_expr:
    bitor_expr
    | and_expr AND bitor_expr { $$ = ($1 && $3); }
    ;

bitor_expr:
    bitxor_expr
    | bitor_expr '|' bitxor_expr { $$ = ($1 | $3); }
    ;

bitxor_expr:
    bitand_expr
    | bitxor_expr '^' bitand_expr { $$ = ($1 ^ $3); }
    ;

bitand_expr:
    equality_expr
    | bitand_expr '&' equality_expr { $$ = ($1 & $3); }
    ;

equality_expr:
    relational_expr
    | equality_expr EQUAL relational_expr { $$ = ($1 == $3); }
    | equality_expr NOTEQUAL relational_expr { $$ = ($1 != $3); }
    ;

relational_expr:
    shift_expr
    | relational_expr '<' shift_expr { $$ = ($1 < $3); }
    | relational_expr '>' shift_expr { $$ = ($1 > $3); }
    | relational_expr LOE shift_expr { $$ = ($1 <= $3); }
    | relational_expr GOE shift_expr { $$ = ($1 >= $3); }
    ;

shift_expr:
    additive_expr
    | shift_expr LSHIFT additive_expr { $$ = ($1 << $3); }
    | shift_expr RSHIFT additive_expr { $$ = ($1 << $3); }
    ;

additive_expr:
    multiplicative_expr
    | additive_expr '+' multiplicative_expr { $$ = $1 + $3; }
    | additive_expr '-' multiplicative_expr { $$ = $1 - $3; }
    ;

multiplicative_expr:
    unary_expr
    | multiplicative_expr '*' unary_expr { $$ = $1 * $3; }
    | multiplicative_expr '/' unary_expr { $$ = $1 / $3; }
    | multiplicative_expr '%' unary_expr { $$ = $1 % $3; }
    ;

unary_expr:
    base_expr
    | '+' base_expr { $$ = $2; }
    | '-' base_expr { $$ = -1 * $2; }
    | '!' base_expr { $$ = !$2; }
    ;

/* TODO: complete base_expr */
base_expr:
    INTEGER { $$ = $1; /* implicit action */ }
    | variable { $$ = 19; /*TODO take from symbols */ }
    | constant_id   { $$ = 23; /* TODO / */ }
    | '(' expression ')' { $$ = $2; }
    ;

/* Some useful alias for LowerCaseID and UpperCaseID. */
variable: LowerCaseID;
constant_id: UpperCaseID;
range_id: UpperCaseID;
set_id: UpperCaseID;
range_or_set_id: set_id;
parameter_id: UpperCaseID;
process_id: UpperCaseID;
progress_id: UpperCaseID;
menu_id: UpperCaseID;

%%

int parser() {
    // open a file handle to a particular file:
    FILE *fin = fopen("input", "r");
    if (!fin) {
	cout << "I can't open 'input'!" << endl;
	return -1;
    }

    /* Set flex to read from it instead of defaulting to STDIN. */
    yyin = fin;

    /* Parse through the input until there is no more. */
    do {
	yyparse();
    } while (!feof(yyin));
    
    return 0;
}

void yyerror(const char *s) {
    cout << "EEK, parse error!  Message: " << s << endl;
    // might as well halt now:
    exit(-1);
}

