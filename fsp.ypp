%code top {
#include <cstdio>
#include <iostream>
#include <sstream>
#include <cstdlib>
#include <set>
#include <vector>

using namespace std;

//#define NDEBUG
#include <assert.h>

}


%code requires {
/* Symbols tables. */
#include "symbols_table.hpp"
}


// Bison fundamentally works by asking flex to get the next token, which it
// returns as an object of type "YYSTYPE".  But tokens could be of any
// arbitrary data type!  So we deal with that in Bison by defining a C union
// holding each of the types of tokens that Flex could return, and have Bison
// use that union instead of "int" for the definition of "YYSTYPE":
%union {
    int int_value;
    float float_value;
    std::string *string_ptr;
    class SymbolValue *sv_ptr;
    struct SvpVec * svpvec_ptr;
    struct Pvec * pvec_ptr;
    class Lts * lts_ptr;
}


%{

/* Inline utilities. */
#include "utils.hpp"

/* Context, ContextsSet and ContextsSetStack. */
#include "context.hpp"

/* Definition of the FspTranslator class. */
#include "translator.hpp"

/* Stuff from flex that bison needs to know about. */
#include "scanner.hpp"

/* Lts definitions and operations. */
#include "lts.hpp"

/* Callbacks. */
#include "callbacks.hpp"

/* Compiler options. */
#include "interface.hpp"



/* A global data structure containing everything the compiler needs. */
struct FspCompiler c;


/* The 'ps' vector and the AA function are necessary in the debug phase in
   order to check that the callback playback systems can work properly. */
vector <void *> ps;
inline void AA(void * barg, int midx, int tot)
{
    assert(barg == ps[ps.size()-1-tot+(midx)]);
}


void relabel_one(SymbolValue * r, SymbolValue * l)
{
    Lts * lts = err_if_not_lts(l);
    RelabelingValue * rlv = err_if_not_relabeling(r);
    /* Apply relabeling. */
    if (rlv) {
	for (int i=0; i<rlv->size(); i++)
	    lts->relabeling(*(rlv->new_labels[i]),
		    *(rlv->old_labels[i]));
    }
}

void relabel(SvpVec *relabv, SvpVec * ltsv)
{
    assert(ltsv->v.size() == c.tr.current_contexts().size());

    if (relabv) {
	assert(ltsv->v.size() == relabv->v.size());
	for (int c=0; c<relabv->v.size(); c++)
	    relabel_one(relabv->v[c], ltsv->v[c]);
    }
}

SvpVec * priority_callback(SvpVec * one, bool low)
{
    PriorityValue * prv;

    assert(one->v.size() == c.tr.current_contexts().size());
    for (int c=0; c<one->v.size(); c++) {
	prv = new PriorityValue;
	prv->setvp = err_if_not_set(one->v[c]);
	prv->low = low;
	one->v[c] = prv;
    }

    return one;
}

void merge_lts_by_rank(SvpVec * ltsv, SvpVec& result)
{
    int rank = -1;
    Lts * merged = NULL;
    Lts * lts;

    assert(result.v.size() == 0);
    assert(ltsv->v.size() == c.tr.current_contexts().size());
    for (int k=0; k<ltsv->v.size(); k++) {
	lts = err_if_not_lts(ltsv->v[k]);
	if (lts->rank != rank) {
	    rank = lts->rank;
	    merged = lts;
	    ltsv->detach(k);
	    result.v.push_back(merged);
	} else
	    merged->compose(*lts);
    }
}

void merge_ltscomp_by_rank(SvpVec * ltscompv, SvpVec& result)
{
    int rank = -1;
    LtsComposition * merged = NULL;
    LtsComposition * lcp;
    Lts * lts;

    assert(result.v.size() == 0);
    assert(ltscompv->v.size() == c.tr.current_contexts().size());
    for (int k=0; k<ltscompv->v.size(); k++) {
	lcp = err_if_not_ltscomposition(ltscompv->v[k]);
	if (lcp->rank != rank) {
	    rank = lcp->rank;
	    merged = lcp;
	    ltscompv->detach(k);
	    result.v.push_back(merged);
	} else {
	    for (int i=0; i<merged->lts.size(); i++)
		merged->lts[i]->compose(*(lcp->lts[i]));
	}
    }
}


//#define DEBUG
#ifdef DEBUG
#define PROX(x) cout<<"PROX: ";x;cout<<"\n"
#define PROP(x) cout<<"PROP:==============================================================\n      " << x << "\n"
#else
#define PROP(x)
#define PROX(x)
#endif


void yyerror(const char *s);
%}


// define the "terminal symbol" token types I'm going to use (in CAPS
// by convention), and associate each with a field of the union:

%token IF THEN ELSE
%token WHEN
%token CONST RANGE SET
%token ARROW
%token DOTDOT
%token END STOP ERROR
%token PROPERTY PROGRESS MENU
%token FORALL
%token SHARING
%token OR AND EQUAL NOTEQUAL LOE GOE LSHIFT RSHIFT
%token <int_value> INTEGER
%token <float_value> FLOAT
%token <string_ptr> UpperCaseID
%token <string_ptr> LowerCaseID

%type <svpvec_ptr> simple_expression
%type <svpvec_ptr> base_expr expression unary_expr multiplicative_expr
%type <svpvec_ptr>  additive_expr shift_expr relational_expr equality_expr
%type <svpvec_ptr> bitand_expr bitxor_expr bitor_expr and_expr or_expr

%type <string_ptr> variable constant_id range_id set_id range_or_set_id
%type <string_ptr> parameter_id process_id progress_id menu_id
%type <string_ptr> const_range_set_parameter_id

%type <svpvec_ptr> set set_elements set_expr
%type <svpvec_ptr> action_labels
%type <svpvec_ptr> alphabet_extension_OPT
%type <svpvec_ptr> action_range guard_OPT
%type <svpvec_ptr> range_expr
%type <svpvec_ptr> index_ranges_OPT index_ranges indices_OPT indices

%type <pvec_ptr> choice action_prefix prefix_actions
%type <pvec_ptr> process_body local_process local_process_defs 
%type <pvec_ptr> local_process_def
%type <pvec_ptr> sequential_composition base_local_process else_OPT

%type <lts_ptr> process_def

%type <pvec_ptr> seq_process_list process_ref_seq
%type <svpvec_ptr> argument_list argument_OPT
%type <svpvec_ptr> process_ref composite_body parallel_composition
%type <svpvec_ptr> composite_else_OPT
%type <svpvec_ptr> labeling_OPT sharing_OPT
%type <svpvec_ptr> relabel_OPT relabel_def relabel_defs braces_relabel_defs
%type <svpvec_ptr> hiding_OPT hiding priority_OPT priority

/* Generate a Generic LR parser, instead of a standard LR parser. We need
   this to resolve conflicts at runtime. */
%glr-parser

/* Name of the parser implementation file. */
%output "parser.cpp"

/* Create a parser header file. This is needed because we define yylex()
   in another source file (the FLEX generated scanner source file). */
%defines

/* Write an extra output file containing verbose descriptions of the parser
    states and what is done for each type of lookahead token in that state
%verbose
*/



%%

/* Start symbol: an arbitrary long list of fsp_definitions */
fsp_description:
    fsp_definition
    | fsp_description fsp_definition
    ;

/* All the possible type of fsp_definitions */
fsp_definition:
    constant_def
    | range_def
    | set_def
    | property_def
    | progress_def
    | menu_def
    | process_def
    | composite_def
    ;


/* Action labels TODO: fix */
action_labels:
    LowerCaseID {
	if (c.record_mode_on)
	    c.parametric->record.push_back(
				    new Callback_V_S(&callback__1, *$1));
	$$ = callback__1(c.tr, $1);
	ps.push_back($$);
    }
    | set {
	AA($1,1,1);
	$$ = $1;
    }
    | action_labels '.' LowerCaseID {
	AA($1,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(
				new Callback_V_VS(&callback__2, *$3));
	$$ = callback__2(c.tr, $1, $3);
	
    }
    | action_labels '.' set {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__3));
	$$ = callback__3(c.tr, $1, $3);
	ps.pop_back();
    }
    | action_labels '[' action_range ']' {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__4));
	$$ = callback__4(c.tr, $1, $3);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

set:
    set_id {
	AA($1,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(
				    new Callback_V_S(&callback__5, *$1));
	$$ = callback__5(c.tr, $1);
	ps.pop_back();
	ps.push_back($$);
    }
    | set_expr {
	AA($1,1,1);
	$$ = $1;
    }
    ;

set_expr:
    '{' {
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_N(&callback__22));
	callback__22(c.tr);
    } set_elements '}' {
	AA($3,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_V(&callback__75));
	$$ = callback__75(c.tr, $3);
	$$ = $3;
    }
    ;

action_range:
    expression {
	AA($1,1,1);
	$$ = $1;
    }
    | range_expr {
	AA($1,1,1);
	$$ = $1;
    }
    | set_expr {
	AA($1,1,1);
	$$ = $1;
    }
    | variable ':' range_or_set_id {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(
				new Callback_V_SS(&callback__6, *$1, *$3));
	$$ = callback__6(c.tr, $1, $3);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    | variable ':' range_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(
				    new Callback_V_SV(&callback__7, *$1));
	$$ = callback__7(c.tr, $1, $3);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    | variable ':' set_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(
				    new Callback_V_SV(&callback__8, *$1));
	$$ = callback__8(c.tr, $1, $3);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

range_expr:
    expression DOTDOT expression {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__9));
	$$ = callback__9(c.tr, $1, $3);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;


/* Const, Range, Set */
constant_def:
    CONST constant_id '=' simple_expression {
	AA($2,1,2); AA($4,2,2);
	assert($4->v.size() == 1);

	ConstValue* cvp = err_if_not_const($4->v[0]);
	$4->detach(0);
	if (!c.identifiers.insert(*$2, cvp)) {
	    stringstream errstream;
	    errstream << "const " << *$2 << " declared twice";
	    semantic_error(errstream);
	}
	delete $4;
	delete $2;
	ps.pop_back();
	ps.pop_back();
    };

range_def:
    RANGE range_id '=' simple_expression DOTDOT simple_expression {
	AA($2,1,3); AA($4,2,3); AA($6,3,3);
	assert($4->v.size() == 1 && $6->v.size() == 1);

	RangeValue* rvp = new RangeValue;
	ConstValue * cvp1 = err_if_not_const($4->v[0]);
	ConstValue * cvp2 = err_if_not_const($6->v[0]);
	rvp->low = cvp1->value;
	rvp->high = cvp2->value;
	delete $4;
	delete $6;
	if (!c.identifiers.insert(*$2, rvp)) {
	    stringstream errstream;
	    errstream << "range " << *$2 << " declared twice";
	    semantic_error(errstream);
	}
	delete $2;
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
    };

set_def:
    SET set_id '=' set_expr {
	AA($2,1,2); AA($4,2,2);

	assert($4->v.size() == 1);
	if (!c.identifiers.insert(*$2, $4->v[0])) {
	    stringstream errstream;
	    errstream << "set " << *$2 << " declared twice";
	    semantic_error(errstream);
	}
	$4->detach(0);
	delete $4;
	delete $2;
	ps.pop_back();
	ps.pop_back();
    };

set_elements:
    action_labels {
	AA($1,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_V(&callback__10));
	$$ = callback__10(c.tr, $1);
	ps.pop_back();
	ps.push_back($$);

    }
    | set_elements ',' {
	AA($1,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_N_V(&callback__74));
	callback__74(c.tr, $1);
    }  action_labels {
	AA($1,1,2); AA($4,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__13));
	$$ = callback__13(c.tr, $1, $4);
	ps.pop_back();
    }
    ;


/* Processes */
process_def:
    process_id param_OPT {
	AA($1,1,1);
	c.record_mode_on = 1;
	if (c.record_mode_on)
	    c.parametric->record.push_back(
				    new Callback_N_S(&callback__14, *$1));
	callback__14(c.tr, $1);
    }
    '=' process_body alphabet_extension_OPT relabel_OPT hiding_OPT '.' {
	AA($1,1,5); AA($5,2,5); AA($6,3,5); AA($7,4,5); AA($8,5,5);
	string name = *$1;
	Lts * lts;
	SymbolValue * svp;
	SetValue * setvp;

	if (c.record_mode_on)
	    c.parametric->record.push_back(
				    new Callback_P_SPVVV(&callback__15, *$1));
	lts = callback__15(c.tr, $1, $5, $6, $7, $8);

	/* Clear and free 'local_processes'. */
	c.tr.local_processes.clear();
	/* Clear 'aliases'. */
	c.tr.aliases.clear();
	/* Free all the nodes allocated by c.pna, and remove the from
	   the allocator itself. */
	c.pna.clear();

	/* Remove process parameters from c.identifiers. */
	for (int i=0; i<c.parametric->parameter_names.size(); i++)
	    c.identifiers.remove(c.parametric->parameter_names[i]);

	/* Restore overridden identifiers. */
	for (int i=0; i<c.tr.overridden_names.size(); i++)
	    c.identifiers.insert(c.tr.overridden_names[i],
						    c.tr.overridden_values[i]);
	c.tr.overridden_names.clear();
	c.tr.overridden_values.clear();

	/* Insert lts into the global 'processes' table. */
	if (!c.processes.insert(name, lts)) {
	    stringstream errstream;
	    errstream << "Process " << name << " already declared";
	    semantic_error(errstream);
	}
	lts->name = name;

	/* Store c.parametric in parametric_processes. */
	if (!c.parametric_processes.insert(name, c.parametric)) {
	    stringstream errstream;
	    errstream << "Parametric process " << name
		<< " already declared";
	    semantic_error(errstream);
	}
	PROX(c.parametric->print());

	/* Prepare for the next parametric process. */
	c.parametric = new ParametricProcess;
	c.record_mode_on = 0;

	PROX(lts->print(); lts->graphvizOutput((name + ".gv").c_str()));
	$$ = lts;

	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
    }
    ;

process_body:
    local_process {
	AA($1,1,1);
	$$ = $1;
    }
    | local_process ',' local_process_defs {
	AA($1,1,2); AA($3,2,2);
	$$ = $1;
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_pop);
	ps.pop_back();
    }
    ;

local_process_defs:
    local_process_def {
	AA($1,1,1);
	$$ = $1;
    }
    | local_process_defs ',' local_process_def {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_pop);
	$$ = $1;
	ps.pop_back();
    }
    ;

local_process_def:
    process_id {
	AA($1,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(
				    new Callback_N_S(&callback__16, *$1));
	callback__16(c.tr, $1);
    } index_ranges_OPT '=' {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(
				    new Callback_N_SV(&callback__17, *$1));
	callback__17(c.tr, $1, $3);
    } local_process {
	AA($1,1,3); AA($3,2,3); AA($6,3,3);
	if (c.record_mode_on)
	    c.parametric->record.push_back(
				    new Callback_P_SVP(&callback__18, *$1));
	$$ = callback__18(c.tr, $1, $3, $6);
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

alphabet_extension_OPT:
    {
	$$ = NULL;
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_null);
	ps.push_back($$);
    }
    | '+' set {
	AA($2,1,1);
	$$ = $2;
    }
    ;

local_process:
    base_local_process {
	AA($1,1,1);
	$$ = $1;
    }
    | sequential_composition {
	AA($1,1,1);
	$$ = $1;
    }
    | IF expression THEN {
	AA($2,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_N_V(&callback__19));
	callback__19(c.tr, $2);
    } local_process {
	AA($2,1,2); AA($5,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_N_VP(&callback__20));
	callback__20(c.tr, $2, $5);
    } else_OPT {
	AA($2,1,3); AA($5,2,3); AA($7,3,3);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_P_VPP(&callback__21));
	$$ = callback__21(c.tr, $2, $5, $7);
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    | '(' {
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_N(&callback__22));
	callback__22(c.tr);
	PROX(cout << "CSS height (push) " << c.tr.css.stack.size());
	PROX(c.tr.current_contexts().print());
    } choice ')' {
	AA($3,1,1);
	$$ = $3;
    }
    ;

else_OPT:
    {
	$$ = NULL;
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_null);
	ps.push_back($$);
    }
    | ELSE local_process {
	AA($2,1,1);
	$$ = $2;
    }

base_local_process:
    END {
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_P(&callback__23));
	$$ = callback__23(c.tr);
	ps.push_back($$);
    }
    | STOP {
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_P(&callback__24));
	$$ = callback__24(c.tr);
	ps.push_back($$);
    }
    | ERROR {
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_P(&callback__25));
	$$ = callback__25(c.tr);
	ps.push_back($$);
    }
    | process_id indices_OPT {
	AA($1,1,2); AA($2,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(
				    new Callback_P_SV(&callback__26, *$1));
	$$ = callback__26(c.tr, $1, $2);;
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

choice:
    action_prefix {
	AA($1,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_P_P(&callback__27));
	$$ = callback__27(c.tr, $1);
	PROX(cout << "CSS height = (pop) " << c.tr.css.stack.size());
    }
    | choice '|' {
	AA($1,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_N_P(&callback__28));
	callback__28(c.tr, $1);
	PROX(cout << "CSS height (push) " << c.tr.css.stack.size());
	PROX(c.tr.current_contexts().print());
    } action_prefix {
	AA($1,1,2); AA($4,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_P_PP(&callback__29));
	$$ = callback__29(c.tr, $1, $4);
	PROX(cout << "CSS height = (pop) " << c.tr.css.stack.size() << "\n");
	ps.pop_back();
    }
    ;

action_prefix:
    guard_OPT {
	AA($1,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_N_V(&callback__30));
	callback__30(c.tr, $1);
    } prefix_actions ARROW local_process {
	AA($1,1,3); AA($3,2,3); AA($5,3,3);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_P_VPP(&callback__31));
	$$ = callback__31(c.tr, $1, $3, $5);
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

prefix_actions:
    action_labels {
	AA($1,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_P_V(&callback__32));
	$$ = callback__32(c.tr, $1);
	ps.pop_back();
	ps.push_back($$);
    }
    | prefix_actions ARROW action_labels {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_P_PV(&callback__33));
	$$ = callback__33(c.tr, $1, $3);
	ps.pop_back();
    }
    ;

guard_OPT:
    {
	$$ = NULL;
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_null);
	ps.push_back($$);
    }
    | WHEN expression {
	AA($2,1,1);
	$$ = $2;
    }
    ;

indices_OPT:
    {
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V(&callback__34));
	$$ = callback__34(c.tr);
	ps.push_back($$);
    }
    | indices
    ;

indices:
    '[' expression ']' {
	AA($2,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_V(&callback__35));
	$$ = callback__35(c.tr, $2);
	ps.pop_back();
	ps.push_back($$);
    }
    | indices '[' expression ']' {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__36));
	$$ = callback__36(c.tr, $1, $3);
	ps.pop_back();
    }
    ;

index_ranges_OPT:
    {
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V(&callback__37));
	$$ = callback__37(c.tr);
	ps.push_back($$);
    }
    | index_ranges
    ;

index_ranges:
    '[' action_range ']' {
	AA($2,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_V(&callback__38));
	$$ = callback__38(c.tr, $2);
	ps.pop_back();
	ps.push_back($$);
    }
    | index_ranges '[' action_range ']' {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__39));
	$$ = callback__39(c.tr, $1, $3);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

sequential_composition:
    seq_process_list ';' base_local_process {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_P_PP(&callback__64));
	$$ = callback__64(c.tr, $1, $3);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

seq_process_list:
    process_ref_seq {
	AA($1,1,1);
	$$ = $1;
    }
    | seq_process_list ';' process_ref_seq {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_P_PP(&callback__65));
	$$ = callback__65(c.tr, $1, $3);
	ps.pop_back();
    }
    ;

process_ref_seq:
    process_id argument_OPT {
	AA($1,1,2); AA($2,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(
				    new Callback_P_SV(&callback__66, *$1));
	$$ = callback__66(c.tr, $1, $2);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

argument_OPT:
    {
	$$ = NULL;
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_null);
	ps.push_back($$);
    }
    |'(' argument_list ')' {
	AA($2,1,1);
	$$ = $2;
    }
    ;

argument_list:
    expression {
	AA($1,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_V(&callback__67));
	$$ = callback__67(c.tr, $1);
	ps.pop_back();
	ps.push_back($$);
    }
    | argument_list ',' expression {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__68));
	$$ = callback__68(c.tr, $1, $3);
	ps.pop_back();
    }
    ;


/* Composite processes */
composite_def:
    OR process_id param_OPT {
	//c.tr.init_fakenode();
	c.tr.css.push_clone();
    } '=' composite_body priority_OPT hiding_OPT '.' {
	AA($2,1,4); AA($6,2,4); AA($7,3,4); AA($8,4,4);
	Lts * lts;

	c.tr.css.pop();
	assert($6->v.size() == 1);
	lts = err_if_not_lts($6->v[0]);

	/* Apply priority. */
	if ($7) {
	    PriorityValue * prv = err_if_not_priority($7->v[0]);

	    assert($7->v.size() == 1);
	    lts->priority(*(prv->setvp), prv->low);
	}

	/* Apply hiding. */
	if ($8) {
	    HidingValue * hvp = err_if_not_hiding($8->v[0]);

	    assert($8->v.size() == 1);
	    lts->hiding(*(hvp->setvp), hvp->interface);
	}

	/* Remove process parameters from c.identifiers. */
	for (int i=0; i<c.parametric->parameter_names.size(); i++)
	    c.identifiers.remove(c.parametric->parameter_names[i]);

	/* Restore overridden identifiers. */
	for (int i=0; i<c.tr.overridden_names.size(); i++)
	    c.identifiers.insert(c.tr.overridden_names[i],
						c.tr.overridden_values[i]);
	c.tr.overridden_names.clear();
	c.tr.overridden_values.clear();


	/* Insert lts into the global 'processes' table. */
	if (!c.processes.insert(*$2, lts)) {
	    stringstream errstream;
	    errstream << "Process " << *$2 << " already declared";
	    semantic_error(errstream);
	}
	lts->name = *$2;

	PROX(cout << "#####################Composite process " << *$2 << " defined#############\n");
	PROX(lts->print(); lts->graphvizOutput((*$2 + ".gv").c_str()));

	delete $2;
	delete $7;
	delete $8;
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
    }
    ;

composite_body:
    sharing_OPT labeling_OPT process_ref {
	AA($1,1,3); AA($2,2,3); AA($3,3,3);
	SvpVec * vp;
	Lts * lts;

	assert($3->v.size() == c.tr.current_contexts().size());
	if ($2) {
	    SetValue * setvp;

	    assert($2->v.size() == $3->v.size());
	    /* Apply process labeling, for each context separately. */
	    for (int k=0; k<$2->v.size(); k++) {
		setvp = err_if_not_set($2->v[k]);
		lts = err_if_not_lts($3->v[k]);
		lts->labeling(*setvp);
		lts->rank = setvp->rank;
	    }

	    /* Merge LTSs by prefix-labeling rank. */
	    vp = new SvpVec;
	    merge_lts_by_rank($3, *vp);
	} else
	    vp = $3;

	if ($1) {
	    SetValue * setvp;

	    assert($1->v.size() == vp->v.size());
	    /* Apply process sharing. */
	    for (int k=0; k<$1->v.size(); k++) {
		lts = err_if_not_lts(vp->v[k]);
		setvp = err_if_not_set($1->v[k]);
		lts->sharing(*setvp);
	    }
	    
	}

	/* Clean up the dirty contexts caused by labeling_OPT. */
	c.tr.css.pop();
	c.tr.css.push_clone();
	$<svpvec_ptr>$ = vp;
	ps.push_back(vp);
    } relabel_OPT {
	AA($1,1,5); AA($2,2,5); AA($3,3,5); 
	AA($<svpvec_ptr>4,4,5); AA($5,5,5);
	relabel($5, $<svpvec_ptr>4);
	if ($1) delete $1;
	if ($2) delete $2;
	if ($5) delete $5;

	$$ = $<svpvec_ptr>4;
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    | sharing_OPT labeling_OPT '(' {
	/* Save the contexts modified by labeling_OPT. */
	c.tr.css.push_clone();
    }  parallel_composition ')' {
	SvpVec * vp;
	LtsComposition * lcp;

	/* Restore the contexts modified by labeling_OPT. */
	c.tr.css.pop();

	assert($5->v.size() == c.tr.current_contexts().size());
	if ($2) {
	    SetValue * setvp;

	    assert($2->v.size() == $5->v.size());
	    /* Apply process labeling, for each context separately. */
	    for (int k=0; k<$2->v.size(); k++) {
		setvp = err_if_not_set($2->v[k]);
		lcp = err_if_not_ltscomposition($5->v[k]);

		/* Apply process labeling to each component process, before
		   performing the composition. */
		for (int i=0; i<lcp->lts.size(); i++)
		    lcp->lts[i]->labeling(*setvp);
		lcp->rank = setvp->rank;
	    }

	    /* Merge LTS compositions by labeling rank. */
	    vp = new SvpVec;
	    merge_ltscomp_by_rank($5, *vp);
	} else
	    vp = $5;

	if ($1) {
	    SetValue * setvp;

	    assert($1->v.size() == vp->v.size());
	    /* Apply process sharing, before performing the composition. */
	    for (int k=0; k<$1->v.size(); k++) {
		lcp = err_if_not_ltscomposition(vp->v[k]);
		setvp = err_if_not_set($1->v[k]);
		for (int i=0; i<lcp->lts.size(); i++)
		    lcp->lts[i]->sharing(*setvp);
	    }
	    
	}

	/* Restore the contexts to the state previous to labeling_OPT. */
	c.tr.css.pop();
	c.tr.css.push_clone();
	$<svpvec_ptr>$ = vp;
	ps.push_back(vp);
    } relabel_OPT {
	AA($1,1,5); AA($2,2,5); AA($5,3,5);
	AA($<svpvec_ptr>7,4,5); AA($8,5,5);
	SvpVec * vp = new SvpVec;
	LtsComposition * lcp;
	Lts * lts;

	if ($8) {
	    /* Apply relabeling. */
	    assert($<svpvec_ptr>7->v.size() == $8->v.size());
	    for (int c=0; c<$8->v.size(); c++) {
		lcp = err_if_not_ltscomposition($<svpvec_ptr>7->v[c]);

		/* Apply relabeling to each component process, before
		   performing the composition. */
		for (int i=0; i<lcp->lts.size(); i++)
		    relabel_one($8->v[c], lcp->lts[i]);

	    }
	}

	/* Perform parallel composition. */
	for (int c=0; c<$<svpvec_ptr>7->v.size(); c++) {
	    lcp = err_if_not_ltscomposition($<svpvec_ptr>7->v[c]);
	    /* Compose all the processes contained in 'lcp'. */
	    lts = lcp->lts[0];
	    for (int i=1; i<lcp->lts.size(); i++) {
		lts->compose(*(lcp->lts[i]));
		delete lcp->lts[i];
	    }
	    vp->v.push_back(lts);
	}
	delete $<svpvec_ptr>7;
	if ($1) delete $1;
	if ($2) delete $2;
	if ($8) delete $8;

	$$ = vp;
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    | FORALL {
	c.tr.css.push_clone();
    } index_ranges {
	c.tr.css.push_clone();
    } composite_body {
	/* Here there is an extension to the original grammar, since
	   we should have 'ranges' and not 'index_ranges'. */
	AA($3,1,2); AA($5,2,2);
	SvpVec * vp = new SvpVec;
	SetValue * setvp;
	Lts * lts;

	c.tr.css.pop();
	assert($3->v.size() == $5->v.size());
	for (int k=0; k<$3->v.size(); k++) {
	    setvp = err_if_not_set($3->v[k]);
	    lts = err_if_not_lts($5->v[k]);
	    lts->rank = setvp->rank;
	}
	merge_lts_by_rank($5, *vp);
	delete $3;
	delete $5;

	$$ = vp;
	c.tr.css.pop();
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    | IF expression THEN composite_body composite_else_OPT {
	/* TODO optimize: useless calculation of both branches. */
	AA($2,1,3); AA($4,2,3); AA($5,3,3);
	ConstValue * cvp;
	SvpVec * vp = $5;
	
	assert($2->v.size() == $4->v.size() &&
		$2->v.size() == c.tr.current_contexts().size());
	assert(!$5 || $2->v.size() == $5->v.size());
	if (!vp) {
	    vp = new SvpVec;
	    for (int k=0; k<$2->v.size(); k++)
		vp->v.push_back(new Lts(LtsNode::Normal, &c.actions));
	}
	for (int c=0; c<$2->v.size(); c++) {
	    cvp = err_if_not_const($2->v[c]);
	    if (!cvp->value) {
		SymbolValue * tmp = $4->v[c];
		$4->v[c] = vp->v[c];
		vp->v[c] = tmp;
	    }
	}
	delete vp;

	$$ = $4;
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

composite_else_OPT:
    {
	$$ = NULL;
	ps.push_back($$);
    }
    | ELSE composite_body {
	AA($2,1,1);
	$$ = $2;
    }
    ;

parallel_composition:
    composite_body {
	AA($1,1,1);
	SvpVec * vp = new SvpVec;
	LtsComposition * lcp;
	Lts * lts;

	for (int c=0; c<$1->v.size(); c++) {
	    lts = err_if_not_lts($1->v[c]);
	    lcp = new LtsComposition;
	    lcp->lts.push_back(lts);
	    vp->v.push_back(lcp);
	}
	$1->detach_all();
	delete $1;

	$$ = vp;
	ps.pop_back();
	ps.push_back($$);
    }
    | parallel_composition OR {
	c.tr.css.pop();
	c.tr.css.push_clone();
    } composite_body {
	AA($1,1,2); AA($4,2,2);
	LtsComposition * lcp;
	Lts * lts;
	
	assert($1->v.size() == $4->v.size());
	for (int c=0; c<$1->v.size(); c++) {
	    lcp = err_if_not_ltscomposition($1->v[c]);
	    lts = err_if_not_lts($4->v[c]);
	    lcp->lts.push_back(lts);
	}
	$4->detach_all();
	delete $4;

	$$ = $1;
	ps.pop_back();
    }
    ;

process_ref:
    process_id argument_OPT {
	AA($1,1,2); AA($2,2,2);
	SymbolValue * svp;
	Lts * lts;
	ParametricProcess * ppp;
	SvpVec * vp = new SvpVec;
	SvpVec * argvp = $2;
	ArgumentsValue * avp;

	/* Lookup 'process_id' in the 'parametric_process' table. */
	if (!c.parametric_processes.lookup(*$1, svp)) {
	    stringstream errstream;
	    errstream << "Process " << *$1 << " undeclared\n";
	    semantic_error(errstream);
	}
	ppp = err_if_not_parametric(svp);

	if (!argvp) {
	    /* 'argvp' is going to specify the default parameters for every
	       context. */
	    argvp = new SvpVec;
	    for (int k=0; k<c.tr.current_contexts().size(); k++) {
		avp = new ArgumentsValue;
		avp->args = ppp->parameter_defaults;
		argvp->v.push_back(avp);
	    }
	}

	for (int k=0; k<argvp->v.size(); k++) {
	    string name = *$1;

	    avp = err_if_not_arguments(argvp->v[k]);
	    if (avp->args.size() != ppp->parameter_names.size()) {
		stringstream errstream;
		errstream << "Parameters mismatch\n";
		semantic_error(errstream);
	    }
	    lts = ppp->replay(c, avp->args);
	    /* Compute the process name. TODO */

	    /* Free all the nodes allocated by c.pna, and remove the from
	       the allocator itself. */
	    c.pna.clear();

	    vp->v.push_back(lts);
	}
	delete $1;
	delete argvp;

	$$ = vp;
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

sharing_OPT:
    {
	$$ = NULL;
	ps.push_back($$);
    }
    | action_labels SHARING {
	AA($1,1,1);
	SvpVec * vp = new SvpVec;

	merge_by_rank($1, *vp);
	delete $1;
	/* We have to clean up the contexts, since process sharing does not
	   extend the contexts. */
	c.tr.css.pop();
	c.tr.css.push_clone();
	$$ = vp;
	ps.pop_back();
	ps.push_back($$);
    }
    ;

labeling_OPT:
    {
	$$ = NULL;
	ps.push_back($$);
    }
    | action_labels ':' {
	AA($1,1,1);
	assert($1->v.size() == c.tr.current_contexts().size());
	$$ = $1;
    }
    ;

priority_OPT:
    {
	$$ = NULL;
	ps.push_back($$);
    }
    | priority {
	AA($1,1,1);
	$$ = $1;
    }
    ;

priority:
    RSHIFT set {
	AA($2,1,1);
	$$ = priority_callback($2, true);
    }
    | LSHIFT set {
	AA($2,1,1);
	$$ = priority_callback($2, false);
    }
    ;


/* Parameters */
param_OPT:
    | param
    ;

param:
    '(' parameter_list ')' {
    }
    ;

parameter_list:
    parameter {
    }
    | parameter_list ',' parameter {
    }
    ;

parameter:
    parameter_id '=' expression {
	AA($1,1,2); AA($3,2,2);
	if ($3->v.size() != 1) {
	    // XXX this should never happen..
	    stringstream errstream;
	    errstream << "Illegal use of variables in parameter declaration";
	    semantic_error(errstream);
	}
	ConstValue * cvp = err_if_not_const($3->v[0]);
	SymbolValue * svp;
	$3->detach(0);
	if (c.identifiers.lookup(*$1, svp)) {
	    /* Save the overridden identifier. */
	    c.tr.overridden_names.push_back(*$1);
	    c.tr.overridden_values.push_back(svp->clone());
	    c.identifiers.remove(*$1);
	}
	if (!c.identifiers.insert(*$1, cvp)) {
	    stringstream errstream;
	    errstream << "identifier " << *$1 << " already declared";
	    semantic_error(errstream);
	}

	/* Update c.parametric-> */
	c.parametric->parameter_names.push_back(*$1);
	c.parametric->parameter_defaults.push_back(cvp->value);

	delete $1;
	delete $3;
	ps.pop_back();
	ps.pop_back();
    }	
    ;


/* Re-Labeling and Hiding */
relabel_OPT: {
	$$ = NULL;
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_null);
	ps.push_back($$);
    }
    | '/' braces_relabel_defs {
	AA($2,1,1);
	$$ = $2;
    }
    ;

braces_relabel_defs:
    '{' {
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_N(&callback__22));
	callback__22(c.tr);
    } relabel_defs '}' {
	AA($3,1,1);
	$$ = $3;
    }
    ;

relabel_defs:
    relabel_def {
	AA($1,1,1);
	$$ = $1;
    }
    | relabel_defs ',' {
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_N(&callback__22));
	callback__22(c.tr);
    }  relabel_def {
	AA($1,1,2); AA($4,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__69));
	$$ = callback__69(c.tr, $1, $4);
	ps.pop_back();
    }
    ;

relabel_def:
    action_labels '/' {
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_N_V(&callback__74));
	callback__74(c.tr, $1);
    }  action_labels {
	AA($1,1,2); AA($4,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__70));
	$$ = callback__70(c.tr, $1, $4);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    | FORALL {
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_N(&callback__22));
	callback__22(c.tr);
    } index_ranges braces_relabel_defs {
	AA($3,1,2); AA($4,2,2);
	if (c.record_mode_on) {
	    c.parametric->record.push_back(new Callback_V_VV(&callback__73));
	}
	$$ = callback__73(c.tr, $3, $4);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

hiding_OPT:
    {
	$$ = NULL;
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_null);
	ps.push_back($$);
    }
    | hiding {
	AA($1,1,1);
	$$ = $1;
    }
    ;

hiding:
    '\\' set {
	AA($2,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_V(&callback__71));
	$$ = callback__71(c.tr, $2);
	ps.pop_back();
	ps.push_back($$);
    }
    | '@' set {
	AA($2,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_V(&callback__72));
	$$ = callback__72(c.tr, $2);
	ps.pop_back();
	ps.push_back($$);
    }
    ;


/* Property, Progress and Menu */
// TODO second form of progress (if S then C)
property_def:
    PROPERTY process_def {
	$2->property();
	PROX($2->print(); $2->graphvizOutput(($2->name + ".gv").c_str()));
    }
    ;

progress_def:
    PROGRESS progress_id {
	c.tr.css.push_clone();
    } index_ranges_OPT '=' set {
	AA($2,1,3); AA($4,2,3); AA($6,3,3);
	Lts * lts;
	SetValue * setvp;
	SetValue * irp;
	string name;
	map<string, SymbolValue*>::iterator it;

	assert($4->v.size() == $6->v.size());
	for (int k=0; k<$6->v.size(); k++) {
	    irp = err_if_not_set($4->v[k]);
	    setvp = err_if_not_set($6->v[k]);
	    /* We discard irp->actions[i] for i>0. */
	    name = *$2 + irp->actions[0]; 
	    
	    if (!c.progresses.insert(name, setvp)) {
		stringstream errstream;
		errstream << "const " << name << " declared twice";
		semantic_error(errstream);
	    }
	}
	c.tr.css.pop();
	delete $2;
	delete $4;

	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
    }
    ;

menu_def:
    MENU menu_id '=' set
    ;


/* An expression or a simple_expression: standard operators and priorities. */
expression:
    or_expr {
	AA($1,1,1);
	$$ = $1;
    }
    ;

simple_expression:
    additive_expr {
	AA($1,1,1);
	$$ = $1;
    }
    ;

or_expr:
    and_expr
    | or_expr OR and_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__41));
	$$ = callback__41(c.tr, $1, $3);
	ps.pop_back();
    }
    ;

and_expr:
    bitor_expr
    | and_expr AND bitor_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__42));
	$$ = callback__42(c.tr, $1, $3);
	ps.pop_back();
    }
    ;

bitor_expr:
    bitxor_expr
    | bitor_expr '|' bitxor_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__43));
	$$ = callback__43(c.tr, $1, $3);
	ps.pop_back();
    }
    ;

bitxor_expr:
    bitand_expr
    | bitxor_expr '^' bitand_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__44));
	$$ = callback__44(c.tr, $1, $3);
	ps.pop_back();
    }
    ;

bitand_expr:
    equality_expr
    | bitand_expr '&' equality_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__45));
	$$ = callback__45(c.tr, $1, $3);
	ps.pop_back();
    }
    ;

equality_expr:
    relational_expr
    | equality_expr EQUAL relational_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__46));
	$$ = callback__46(c.tr, $1, $3);
	ps.pop_back();
    }
    | equality_expr NOTEQUAL relational_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__47));
	$$ = callback__47(c.tr, $1, $3);
	ps.pop_back();
    }
    ;

relational_expr:
    shift_expr
    | relational_expr '<' shift_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__48));
	$$ = callback__48(c.tr, $1, $3);
	ps.pop_back();
    }
    | relational_expr '>' shift_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__49));
	$$ = callback__49(c.tr, $1, $3);
	ps.pop_back();
    }
    | relational_expr LOE shift_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__50));
	$$ = callback__50(c.tr, $1, $3);
	ps.pop_back();
    }
    | relational_expr GOE shift_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__51));
	$$ = callback__51(c.tr, $1, $3);
	ps.pop_back();
    }
    ;

shift_expr:
    additive_expr
    | shift_expr LSHIFT additive_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__52));
	$$ = callback__52(c.tr, $1, $3);
	ps.pop_back();
    }
    | shift_expr RSHIFT additive_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__53));
	$$ = callback__53(c.tr, $1, $3);
	ps.pop_back();
    }
    ;

additive_expr:
    multiplicative_expr
    | additive_expr '+' multiplicative_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__54));
	$$ = callback__54(c.tr, $1, $3);
	ps.pop_back();
    }
    | additive_expr '-' multiplicative_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__55));
	$$ = callback__55(c.tr, $1, $3);
	ps.pop_back();
    }
    ;

multiplicative_expr:
    unary_expr
    | multiplicative_expr '*' unary_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__56));
	$$ = callback__56(c.tr, $1, $3);
	ps.pop_back();
    }
    | multiplicative_expr '/' unary_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__57));
	$$ = callback__57(c.tr, $1, $3);
	ps.pop_back();
    }
    | multiplicative_expr '%' unary_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__58));
	$$ = callback__58(c.tr, $1, $3);
	ps.pop_back();
    }
    ;

unary_expr:
    base_expr
    | '+' base_expr {
	AA($2,1,1);
	for (int i=0; i<$2->v.size(); i++) {
	    err_if_not_const($2->v[i]);
	}
	$$ = $2;
    }
    | '-' base_expr {
	AA($2,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_V(&callback__59));
	$$ = callback__59(c.tr, $2);
    }
    | '!' base_expr {
	AA($2,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_V(&callback__60));
	$$ = callback__60(c.tr, $2);
    }
    ;

/* TODO: complete base_expr */
base_expr:
    INTEGER {
	if (c.record_mode_on)
	    c.parametric->record.push_back(
				new Callback_V_I(&callback__61, $1));
	$$ = callback__61(c.tr, $1);
	ps.push_back($$);
    }
    | variable {
	AA($1,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(
				    new Callback_V_S(&callback__62, *$1));
	$$ = callback__62(c.tr, $1);
	ps.pop_back();
	ps.push_back($$);
    }
    | const_range_set_parameter_id {
	AA($1,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(
				    new Callback_V_S(&callback__63, *$1));
	$$ = callback__63(c.tr, $1);
	ps.pop_back();
	ps.push_back($$);
    }
    | '(' expression ')' {
	AA($2,1,1);
	$$ = $2;
    }
    ;

/* Some useful alias for LowerCaseID and UpperCaseID. */
variable: LowerCaseID { ps.push_back($1); };
constant_id: UpperCaseID { ps.push_back($1); };
range_id: UpperCaseID { ps.push_back($1); };
set_id: UpperCaseID { ps.push_back($1); };
range_or_set_id: set_id { AA($1,1,1); };
const_range_set_parameter_id: set_id { AA($1,1,1); };
parameter_id: UpperCaseID { ps.push_back($1); };
process_id: UpperCaseID { ps.push_back($1); };
progress_id: UpperCaseID { ps.push_back($1); };
menu_id: UpperCaseID { ps.push_back($1); };

%%


const char * ex = "P=(a->b->P).";

int parser(const CompilerOptions& co)
{
    /*
    ScannerFileBuffer sfb(co.input_file);
    sfb.select();
    yyparse();

    ScannerStringBuffer ssb(ex,12);
    ssb.select();
    yyparse(); */

    InputBuffersStack ibs;

    if (co.input_type == CompilerOptions::InputTypeFsp) {
	/* Parse the FSP input file. */
	ibs.push(co.input_file);
	yyparse();
	ibs.pop();
    } else {
	/* Load the processes table from an LTS file. */
	fstream fin(co.input_file, fstream::in);
	Lts * lts;

	if (fin.fail()) {
	    cerr << "No such file: '" << co.input_file << "'\n";
	}
	
	while (!(fin.fail() || fin.eof())) {
	    lts = new Lts(fin, &c.actions);

	    if (fin.eof())
		break;
	    /* Insert lts into the global 'processes' table. */
	    if (!c.processes.insert(lts->name, lts)) {
		stringstream errstream;
		errstream << "Process " << lts->name << " already declared";
		semantic_error(errstream);
	    }
	}

	fin.close();
    }

    /* Zero-truncate the output file. */
    if (co.input_type != CompilerOptions::InputTypeLts)
	fstream(co.output_file, fstream::out).close();

    /* Scan the 'processes' symbols table. For each process, output
       the associated LTS and do the deadlock analysis. */
    map<string, SymbolValue *>::iterator it;
    map<string, SymbolValue *>::iterator jt;
    Lts * lts;
    SetValue * setvp;    

    for (it=c.processes.table.begin(); it!=c.processes.table.end(); it++) {
	lts = err_if_not_lts(it->second);

	/* We output an LTS file only if the input is not an LTS file. */
	if (co.input_type != CompilerOptions::InputTypeLts)
	    lts->output(co.output_file);

	if (co.deadlock)
	    lts->deadlockAnalysis();

	if (co.graphviz)
	    lts->graphvizOutput((lts->name + ".gv").c_str());
    }

    if (co.progress) {
	/* Do each progress check against all the global processes. */
	for (it=c.progresses.table.begin(); it!=c.progresses.table.end();
								    it++) {
	    setvp = err_if_not_set(it->second);
	    for (jt=c.processes.table.begin();
		    jt!=c.processes.table.end(); jt++) {
		lts = err_if_not_lts(jt->second);
		lts->progress(it->first, *setvp);
	    }
	}
    }

    return 0;
}


void yyerror(const char *s) {
    cout << "Syntax error:" << s << endl;
    // might as well halt now:
    exit(-1);
}

