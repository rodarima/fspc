%{
#include <cstdio>
#include <iostream>
#include <sstream>
#include <cstdlib>
#include <set>
#include <vector>

using namespace std;

/* Stuff from flex that bison needs to know about. */
extern int yylex();
extern FILE * yyin;

/* Symbols tables. */
#include "strings_table.hpp"
//TODO define these tables here.. move from fspc.cpp
extern struct SymbolsTable identifiers;
extern struct SymbolsTable processes;

/* Main actions table. */
struct ActionsTable actions("Global actions table");

#include "lts.hpp"


#include "context.hpp"

/* Stack of contexts sets. */
struct ContextsSetStack {
    vector<ContextsSet *> stack;

    ContextsSetStack() { }
    void push(ContextsSet * ctxset) {
	stack.push_back(ctxset);
    }
    void push_clone() {
	stack.push_back(new ContextsSet(*stack.back()));
    }
    void update(ContextsSet * ctxset) {
	delete stack.back();
	stack.back() = ctxset;
    }
    void pop() {
	delete stack.back();
	stack.pop_back();
    }
    ContextsSet& top() { return *(stack.back()); }
};

struct ContextsSetStack css;
#define current_contexts css.top()


/* Storage for a list of parameters identifiers to remove from the 
   identifiers table when a process definition has been completed. */
vector<string *> parameters;


/* Fix unresolved ProcessNode references due to cyclic processes. */
void fix_unresolved_references(ProcessNode * pnp, void * opaque);


/* For semantic errors */
stringstream errstream;

void semantic_error()
{
    cout << "Semantic error: " << errstream.str() << "\n";
    exit(-1);
}

/* Helper function used to get a ConstValue* from a SymbolValue*. If the
   object pointed is not a constant, a semantic error is issued. */
inline ConstValue* err_if_not_const(SymbolValue * svp)
{
    if (svp->type() != SymbolValue::Const) {
	errstream << "Const expected";
	semantic_error();
    }

    return (ConstValue *)svp;
}

inline RangeValue* err_if_not_range(SymbolValue * svp)
{
    if (svp->type() != SymbolValue::Range) {
	errstream << "Range expected";
	semantic_error();
    }

    return (RangeValue *)svp;
}

inline SetValue* err_if_not_set(SymbolValue * svp)
{
    if (svp->type() != SymbolValue::Set) {
	errstream << "Set expected";
	semantic_error();
    }

    return (SetValue *)svp;
}

inline ProcessNode * err_if_not_procnode(ProcessBase * pbp) {
    if (pbp->unresolved() || pbp->connected()) {
	errstream << "ProcessNode expected";
	semantic_error();
    }
    return (ProcessNode *)pbp;
}

static ProcessBase * gpp = NULL;

#define DEBUG 1
#if (DEBUG==2)
#define SHH(x) cout<< "SHH >> " << x << "\n";
#define OUT(x) cout<<"OUT:"; x
#define IN(x) cout<<"IN:"; x
#define PRO(x)
#elif (DEBUG==1)
#define SHH(x)
#define OUT(x)
#define IN(x)
#define PRO(x) cout<<"PRO:";x;cout<<"\n"
#else
#define SHH(x)
#define OUT(x)
#define IN(x)
#define PRO(x)
#endif


void yyerror(const char *s);
%}

// Bison fundamentally works by asking flex to get the next token, which it
// returns as an object of type "YYSTYPE".  But tokens could be of any
// arbitrary data type!  So we deal with that in Bison by defining a C union
// holding each of the types of tokens that Flex could return, and have Bison
// use that union instead of "int" for the definition of "YYSTYPE":
%union {
    int int_value;
    float float_value;
    std::string *string_ptr;
    class StringsSet *sset_ptr;
    class SymbolValue *sv_ptr;
    class RangeValue *rv_ptr;
    class Lts *lv_ptr;
    class ProcessNode * pn_ptr;
    class ProcessBase * pb_ptr;
    struct SvpVec * svpvec_ptr;
}

// define the "terminal symbol" token types I'm going to use (in CAPS
// by convention), and associate each with a field of the union:


%token IF THEN ELSE
%token WHEN
%token CONST RANGE SET
%token ARROW
%token DOTDOT
%token END STOP ERROR
%token PROPERTY PROGRESS MENU
%token FORALL
%token SHARING
%token OR AND EQUAL NOTEQUAL LOE GOE LSHIFT RSHIFT
%token <int_value> INTEGER
%token <float_value> FLOAT
%token <string_ptr> UpperCaseID
%token <string_ptr> LowerCaseID

%type <svpvec_ptr> simple_expression
%type <svpvec_ptr> base_expr expression unary_expr multiplicative_expr
%type <svpvec_ptr>  additive_expr shift_expr relational_expr equality_expr
%type <svpvec_ptr> bitand_expr bitxor_expr bitor_expr and_expr or_expr

%type <string_ptr> variable constant_id range_id set_id range_or_set_id
%type <string_ptr> parameter_id process_id progress_id menu_id
%type <string_ptr> const_range_set_parameter_id

%type <svpvec_ptr> set set_elements set_expr
%type <svpvec_ptr> action_labels
%type <svpvec_ptr> alphabet_extension_OPT
%type <svpvec_ptr> action_range guard_OPT
%type <svpvec_ptr> range_expr
%type <svpvec_ptr> index_ranges_OPT index_ranges
%type <pb_ptr> choice action_prefix prefix_actions
%type <pb_ptr> process_body local_process local_process_defs local_process_def
%type <pb_ptr> sequential_composition base_local_process
%type <pb_ptr> seq_process_list process_ref

%glr-parser

%%

/* Start symbol: an arbitrary long list of fsp_definitions */
fsp_description:
    fsp_definition
    | fsp_description fsp_definition
    ;

/* All the possible type of fsp_definitions */
fsp_definition:
    constant_def
    | range_def
    | set_def
    | property_def
    | progress_def
    | menu_def
    | process_def
    | composite_def
    ;


/* Action labels TODO: fix */
action_labels:
    LowerCaseID {
	SHH("action_labels --> LowerCaseID");
	SvpVec * vp;
	SetValue * setvp; 

	vp = new SvpVec;
	vp->shared = false;
	for (int c=0; c<current_contexts.size(); c++) {
	    setvp = new SetValue;
	    *setvp += *$1;
	    /* We assign a different rank to each setvp in vp (and so one
	       per context). Note that this assignment happens before
	       parsing anithing else in the composite action. For istance,
	       if we have to parse 'a[i:R][S][i+1]', this action is executed
	       as soon as 'a' is parsed, and so before parsing the rest
	       of the composite action. */
	    setvp->rank = c;
	    vp->v.push_back(setvp);
	}
	delete $1;
	$$ = vp;
	OUT(vp->print());
    }
    | set {
	SHH("action_labels --> set");
	$$ = $1;
	OUT($$->print());
    }
    | action_labels '.' LowerCaseID {
	SHH("action_labels --> action_labels . LowerCaseID");
	IN($1->print());
	if ($1->v.size() != current_contexts.size()) {cout<<"FATAL 561\n";exit(-1);}
	SetValue * setvp;
	for (int c=0; c<$1->v.size(); c++) {
	    setvp = err_if_not_set($1->v[c]);
	    setvp->dotcat(*$3);
	    /* Rank is inherited. */
	}
	delete $3;
	$$ = $1;
    }
    | action_labels '.' set {
	SHH("action_labels --> action_labels . set");
	if ($1->v.size() != $3->v.size() ||
		$1->v.size() != current_contexts.size())
	     {cout<<"FATAL 412 \n"; exit(-1);}
	SetValue * setvp;
	SetValue * rsetvp;
	for (int c=0; c<$1->v.size(); c++) {
	    setvp = err_if_not_set($1->v[c]);
	    rsetvp = err_if_not_set($3->v[c]);
	    /* Combine setvp with rsetvp. No context ramification
	       happens here. */
	    setvp->dotcat(*rsetvp);
	    /* Rank is inherited. */
	}
	delete $3;
	$$ = $1;
	OUT($$->print());
    }
    | action_labels '[' action_range ']' {
	SHH("action_labels --> action_labels [ action_range ]");
	IN($1->print(); $3->print());
	if ($1->v.size() != $3->v.size() ||
		$1->v.size() != current_contexts.size())
	     {cout<<"FATAL 215 \n"; exit(-1);}
	SvpVec * vp;
	SetValue * setvp;
	SetValue * rsetvp;
	RangeValue * rvp;
	ConstValue * cvp;
	ContextsSet * csp; 
	Context * cxp;
	/* type() and 'variable' is the same for all the elements in 
	   'action_range'. */
	switch ($3->v[0]->type()) {
	    case SymbolValue::Range:
		rvp = err_if_not_range($3->v[0]);
		if (rvp->variable != "") {
		    /* In this case each element in action_range is in the
		       form 'var:R', where R is a range_id or a range_expr. */
		    csp = new ContextsSet;
		    csp->frontier = current_contexts.frontier;
		    vp = new SvpVec;
		    for (int c=0; c<$1->v.size(); c++) {
			setvp = err_if_not_set($1->v[c]);
			rvp = err_if_not_range($3->v[c]);
			for (int j=rvp->low; j<=rvp->high; j++) {
			    SetValue * new_setvp = new SetValue(*setvp);
			    for (int k=0; k<new_setvp->actions.size(); k++)
				new_setvp->actions[k] += "[" +
				    int2string(j) + "]";
			    /* When a context spread happens, each new_setvp
			       inherits the rank of the generating setvp. */
			    new_setvp->rank = setvp->rank;
			    /* Create a new context (extending the previous
			       one) and append the new SetValue to associate
			       to this context.*/
			    vp->v.push_back(new_setvp);
			    cxp = current_contexts[c];
			    cxp = new Context(*cxp);
			    if (!cxp->insert(rvp->variable, j)) {
				errstream << "Variable " << rvp->variable
				    << " declared twice\n";
				semantic_error();
			    }
			    csp->append(cxp);
			}
		    }
		    cout << "Contexts ramification\n";
		    css.update(csp);
		    current_contexts.print();
		    delete $1;
		    delete $3;
		    $$ = vp;
		} else {
		    /* In this case each element in action_range is in the
		       form "R", where R is a range_id or a range_expr. */
		    for (int c=0; c<$1->v.size(); c++) {
			setvp = err_if_not_set($1->v[c]);
			rvp = err_if_not_range($3->v[c]);
			setvp->indexize(rvp->low, rvp->high);
			/* Rank is inherited. */
		    }
		    delete $3;
		    $$ = $1;
		}
		break;

	    case SymbolValue::Const:
		for (int c=0; c<$1->v.size(); c++) {
		    setvp = err_if_not_set($1->v[c]);
		    cvp = err_if_not_const($3->v[c]);
		    setvp->indexize(cvp->value);
		    /* Rank is inherited. */
		}
		delete $3;
		$$ = $1;
		break;
	    case SymbolValue::Set:
		setvp = err_if_not_set($3->v[0]);
		if (setvp->variable != "") {
		    /* In this case each element in action_range is in the
		       form 'var:R', where R is a set_id or a set_expr. */
		    csp = new ContextsSet;
		    csp->frontier = current_contexts.frontier;
		    /* We need a new SvpVec for a new ContextSet. */
		    vp = new SvpVec;
		    for (int c=0; c<$1->v.size(); c++) {
			setvp = err_if_not_set($1->v[c]);
			rsetvp = err_if_not_set($3->v[c]);
			for (int j=0; j<rsetvp->actions.size(); j++) {
			    SetValue * new_setvp = new SetValue(*setvp);
			    for (int k=0; k<new_setvp->actions.size(); k++)
				new_setvp->actions[k] += "." +
				    rsetvp->actions[j];
			    /* When a context spread happens, each new_setvp
			       inherits the rank of the generating setvp. */
			    new_setvp->rank = setvp->rank;
			    /* Create a new context (extending the previous
			       one) and append the new SetValue to associate
			       to this context.*/
			    vp->v.push_back(new_setvp);
			    cxp = current_contexts[c];
			    cxp = new Context(*cxp);
			    if (!cxp->insert(rsetvp->variable,
				    rsetvp->actions[j])) {
				errstream << "Variable " << rsetvp->variable
				    << " declared twice\n";
				semantic_error();
			    }
			    /* Append the new Context to the new ContextSet. 
				*/
			    csp->append(cxp);
			}
		    }
		    cout << "Contexts ramification\n";
		    css.update(csp);
		    current_contexts.print();
		    delete $1;
		    delete $3;
		    $$ = vp;
		} else {
		    for (int c=0; c<$1->v.size(); c++) {
			setvp = err_if_not_set($1->v[c]);
			rsetvp = err_if_not_set($3->v[c]);
			/* Create a new SetValue that combines setvp and
			   rsetvp. No context ramification happens here. */
			setvp->indexize(*rsetvp);
			/* Rank is inherited. */
		    }
		    delete $3;
		    $$ = $1;
		}
		break;

	    default:
		cout << "WHAT!?!?!?\n";
		exit(-1);
		break;
	}
	OUT($$->print());
    }
    ;

set:
    set_id {
	SHH("set --> set_id");
	SvpVec * vp = new SvpVec;
	SymbolValue * svp;
	SetValue * setvp;
	if (!identifiers.lookup(*$1, svp)) {
	    errstream << "set " << *$1 << " undeclared";
	    semantic_error();
	}
	delete $1;
	setvp = err_if_not_set(svp);
	svp = svp->clone();
	vp->shared = true;
	for (int c=0; c<current_contexts.size(); c++)
	    vp->v.push_back(svp);
	$$ = vp;
	OUT($$->print());
    }
    | set_expr {
	SHH("set --> set_expr");
	$$ = $1;
	OUT($$->print());
    }
    ;

set_expr:
    '{' set_elements '}' {
	SHH("set_expr --> { set_elements }");
	$2->print();
	$$ = $2;
	OUT($$->print());
    }
    ;

action_range:
    expression {
	SHH("action_range --> expression");
	$$ = $1;
	OUT($$->print());
    }
    | range_expr {
	SHH("action_range --> range_expr");
	$$ = $1;
	OUT($$->print());
    }
    | set_expr {
	SHH("action_range --> set_expr");
	$$ = $1;
	OUT($$->print());
    }
    | variable ':' range_or_set_id {
	SHH("action_range --> variable : range_or_set_id");
	IN(cout << *$1 << ": " << *$3 << "\n");
	SvpVec * vp = new SvpVec;
	SymbolValue * svp;

	if (!identifiers.lookup(*$3, svp)) {
	    errstream << "range/set " << *$3 << " undeclared";
	    semantic_error();
	}
	svp = svp->clone();

	/* Pass the variable name to the upper levels.*/
	svp->setVariable(*$1);
	delete $1;
	vp->shared = true;
	for (int c=0; c<current_contexts.size(); c++)
	    vp->v.push_back(svp);
	$$ = vp;
	OUT($$->print());
    }
    | variable ':' range_expr {
	SHH("action_range --> variable : range_expr");
	IN(cout << *$1 << ": "; $3->print());
	RangeValue * rvp;
	for (int i=0; i<$3->v.size(); i++) {
	    rvp = err_if_not_range($3->v[i]);
	    /* Pass the variable to the upper levels.*/
	    rvp->setVariable(*$1);
	}
	delete $1;
	$$ = $3;
	OUT($$->print());
    }
    | variable ':' set_expr {
	SHH("action_range --> variable : set_expr");
	IN(cout << *$1 << ": "; $3->print());
	SetValue * setvp;
	for (int i=0; i<$3->v.size(); i++) {
	    setvp = err_if_not_set($3->v[i]);
	    /* Pass the variable to the upper levels.*/
	    setvp->setVariable(*$1);
	}
	delete $1;
	$$ = $3;
	OUT($$->print());
    }
    ;

range_expr:
    expression DOTDOT expression {
	SHH("range_expr --> expression .. expression");
	IN($1->print(); $3->print());
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	RangeValue * rvp;
	ConstValue * cvp;
	SvpVec * vp = new SvpVec;
	for (int i=0; i<$1->v.size(); i++) {
	    rvp = new RangeValue;
	    cvp = err_if_not_const($1->v[i]);
	    rvp->low = cvp->value;
	    cvp = err_if_not_const($3->v[i]);
	    rvp->high = cvp->value;
	    vp->v.push_back(rvp);
	}
	delete $1;
	delete $3;
	$$ = vp;
	OUT($$->print());
    }
    ;


/* Const, Range, Set */
constant_def:
    CONST constant_id '=' simple_expression {
	if ($4->v.size() != 1) {
	    // XXX this should never happen, because we get an "undeclared"
	    errstream << "Illegal use of variables in const declaration";
	    semantic_error();
	}
	ConstValue* cvp = err_if_not_const($4->v[0]);
	$4->detach(0);
	OUT(cout << "Const " << *$2 << "=" << cvp->value << "\n");
	if (!identifiers.insert(*$2, cvp)) {
	    errstream << "const " << *$2 << " declared twice";
	    semantic_error();
	}
	delete $4;
	delete $2;
    };

range_def:
    RANGE range_id '=' simple_expression DOTDOT simple_expression {
	if ($4->v.size() != 1 || $6->v.size() != 1) {
	    // XXX this should never happen, because we get an "undeclared"
	    errstream << "Illegal use of variables in range declaration";
	    semantic_error();
	}
	RangeValue* rvp = new RangeValue;
	ConstValue * cvp1 = err_if_not_const($4->v[0]);
	ConstValue * cvp2 = err_if_not_const($6->v[0]);
	OUT(cout << "Range " << *$2 << "[" << cvp1->value << ", " << cvp2->value << "]\n");
	rvp->low = cvp1->value;
	rvp->high = cvp2->value;
	//delete cvp1; // done below
	//delete cvp2;
	delete $4;
	delete $6;
	if (!identifiers.insert(*$2, rvp)) {
	    errstream << "range " << *$2 << " declared twice";
	    semantic_error();
	}
	delete $2;
    };

set_def:
    SET set_id '=' '{' set_elements '}' {
	OUT(cout << "Set\n"; $5->print());
	// TODO convert from SvpVec to SetValue
	if (!identifiers.insert(*$2, $5->v[0])) {
	    errstream << "set " << *$2 << " declared twice";
	    semantic_error();
	}
	$5->detach(0);
	delete $5;
	delete $2;
    };

set_elements:
    action_labels {
	SHH("set_elements --> action_labels");
	$$ = $1;
	OUT($$->print());
    }
    | set_elements ',' action_labels {
	SHH("set_elements --> set_elements , action_labels");
	IN($1->print(); $3->print());
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL 719\n";exit(-1);}
	for (int c=0; c<$1->v.size(); c++) {
	    SetValue * setvp = err_if_not_set($1->v[c]);
	    SetValue * rsetvp = err_if_not_set($3->v[c]);
	    *setvp += *rsetvp;
	}
	delete $3;
	$$ = $1;
	OUT($$->print());
    }
    ;


/* Processes */
process_def:
    process_id param_OPT {
	/* Parameters have been pushed inside the 'param_OPT' rule.
	   A cleaner approach would be to get a list of parameters from
	   the rule and push the parameters into the 'identifiers' table
	   in this action. */
	;
    }
    '=' process_body alphabet_extension_OPT relabel_OPT hiding_OPT '.' {
	SHH("process_def --> ... process_body ...");
	IN(cout<<*$1<< ": "; $5->print(&actions));
	if ($5->unresolved()) {
	    errstream << "Local process " << 
		    ((UnresolvedProcess * )$5)->reference << " undeclared\n";
	    semantic_error();
	}

	PRO(cout<<*$1<<" = "; $5->print(&actions));

	/* Insert a new ProcessValue in the symbol table, attaching the
	   process_body to it. */
	ProcessValue * pvp = new ProcessValue;
	cout << "Process " << *$1 << " defined\n";
	if (!processes.insert(*$1, pvp)) {
	    errstream << "process " << *$1 << " declared twice";
	    semantic_error();
	}
	pvp->pnp = (ProcessNode *)$5;

	/* Try to resolve all the undefined references into this process. */
	struct ProcessVisitObject f;
	f.vfp = &fix_unresolved_references;
	f.opaque = &actions;
	pvp->pnp->visit(f);

	PRO(cout<<"resolved: "; pvp->pnp->print(&actions));

	/* Convert the collection of ProcessNodes in an Lts object. */
	Lts lts(pvp->pnp, &actions);

	/* Now we can free the graph pointed by pvp->pnp. */
	freeProcessNodeGraph(pvp->pnp);

	/* Extend the alphabet if is the case. */
	if ($6) {
	    SetValue * setvp;
	    if ($6->v.size() != 1) {
		errstream << "Multiset alphabet extension";
		semantic_error();
	    }
	    setvp = err_if_not_set($6->v[0]);
	    for (int i=0; i<setvp->actions.size(); i++)
		lts.updateAlphabet(actions.insert(setvp->actions[i]));
		delete setvp;
	}

	/* Remove process parameters from the identifiers. */
	for (int i=0; i<parameters.size(); i++) {
	    identifiers.remove(*(parameters[i]));
	    delete parameters[i];
	}
	parameters.clear();

	lts.print();
	lts.graphvizOutput((*$1 += ".gv").c_str());
	delete $1;

	// TODO implement everything is OPT
    }
    ;

process_body:
    local_process {
	SHH("process_body --> local_process");
	$$ = $1;
	OUT($$->print(&actions));
    }
    | local_process ',' local_process_defs {
	SHH("process_body --> local_process , local_process_defs");
	IN($1->print(&actions); $3->print(&actions));
	// TODO compose
	$$ = $1;
	OUT($$->print(&actions));
    }
    ;

local_process_defs:
    local_process_def {
	SHH("local_process_defs --> local_process_def");
	$$ = $1;
	OUT($$->print(&actions));
    }
    | local_process_defs ',' local_process_def {
	SHH("local_process_defs --> local_process_defs , local_process_def");
	IN($1->print(&actions); $3->print(&actions));
	// TODO compose
	$$ = $1;
	OUT($$->print(&actions));
    }
    ;

local_process_def:
    process_id index_ranges_OPT '=' local_process {
	SHH("local_process_def --> process_id = local_process");
	IN(cout << *$1 << ": "; $4->print(&actions));
	// TODO index_ranges_OPT

	if ($4->unresolved()) {
	    errstream << "Local process " << 
		    ((UnresolvedProcess * )$4)->reference << " undeclared\n";
	    semantic_error();
	}

	// switch ($2->v[0].type())

	/* Insert a new ProcessValue in the symbol table, attaching the
	   'local_process' to it. */
	ProcessValue * pvp = new ProcessValue;
	cout << "Process " << *$1 << "[] defined\n";
	if (!processes.insert(*$1, pvp)) {
	    errstream << "process " << *$1 << " declared twice";
	    semantic_error();
	}
	pvp->pnp = err_if_not_procnode($4);

	//pvp->pnp->print(&actions);

	delete $1;
	$$ = $4;
	OUT($$->print(&actions));
    }
    ;

alphabet_extension_OPT:
    {
	$$ = NULL;
    }
    | '+' set {
	SHH("alphabet_extension_OPT --> + set");
	$$ = $2;
	OUT($$->print());
    }
    ;

local_process:
    base_local_process {
	SHH("local_process --> base_local_process");
	$$ = $1;
	OUT($$->print(&actions));
    }
    | sequential_composition {
	SHH("local_process --> sequential_composition");
	$$ = $1;
	OUT($$->print(&actions));
    }
    | IF expression THEN local_process {
	SHH("local_process --> IF expression THEN local_process");
	IN($2->print();$4->print(&actions));
	ConstValue * cvp;
	if ($2->v.size() > 1) {cout < "TODO IF THEN\n"; exit(-1);} //TODO
	cvp = err_if_not_const($2->v[0]);
	if (cvp->value)
	    $$ = $4;
	else {
	    /* If the condition is not true, return a STOP process. */
	    if ($4->unresolved())
		delete $4;
	    else
		freeProcessNodeGraph((ProcessNode *)$4);
	    $$ = new ProcessNode;
	}
	delete $2;
	OUT($$->print(&actions));
    }
    | IF expression THEN {
	SHH("local_process --> IF expression THEN (cont)");
	ConstValue * cvp;

	css.push_clone();
	for (int c=0; c<current_contexts.size(); c++) {
	    cvp = err_if_not_const($2->v[c]);
	    if (!cvp->value) {
		current_contexts.rule_out(c);
	    }
	}
	cout << "IFTHENELSE\n";
    } local_process ELSE {
	SHH("local_process --> (cont) local_process ELSE (cont)");
	ConstValue * cvp;

	css.pop();
	css.push_clone();
	for (int c=0; c<current_contexts.size(); c++) {
	    cvp = err_if_not_const($2->v[c]);
	    if (cvp->value) {
		current_contexts.rule_out(c);
	    }
	}
    } local_process {
	SHH("local_process --> (cont) local_process");
	IN($2->print(); $5->print(&actions); $8->print(&actions));
	ConstValue * cvp;
	ProcessBase * pbp;

	css.pop();
	// TODO vectorize output!
	for (int c=0; c<current_contexts.size(); c++) {
	    cvp = err_if_not_const($2->v[c]);
	    if (cvp->value)
		pbp = $5;
	    else
		pbp = $8;
	}
	delete $2;
	$$ = pbp;
	OUT($$->print(&actions));
    }
    | '(' {
	SHH("local_process --> (   (cont)");
	/* Replicate the CSS stack top so that it can be used by 'choice'. */
	css.push_clone();
	cout << "CSS height (push) " << css.stack.size() << "\n";
    } choice ')' {
	SHH("local_process --> (cont)  choice )");
	//$3->print();
	$$ = $3;
	OUT($$->print(&actions));
    }
    ;

base_local_process:
    END {
	SHH("base_local_process --> END");
	$$ = new ProcessNode(ProcessNode::End);
	OUT($$->print(&actions));
    }
    | STOP {
	SHH("base_local_process --> STOP");
	$$ = new ProcessNode;
	OUT($$->print(&actions));
    }
    | ERROR {
	SHH("base_local_process --> ERROR");
	$$ = new ProcessNode(ProcessNode::Error);
	OUT($$->print(&actions));
    }
    | process_id indices_OPT {
	SHH("base_local_process --> process_id indices_OPT");
	//TODO implement indices_OPT
	SymbolValue * svp;
	/* If the process referenced is already defined, return it.
	   Otherwise return a new UnresolvedProcess object, so that the
	   upper level sees that *$1 is unresolved. */
	if (processes.lookup(*$1, svp))
	    $$ = ((ProcessValue *)svp)->pnp;
	else
	    $$ = new UnresolvedProcess(*$1);
	OUT($$->print(&actions));
    }
    ;

choice:
    action_prefix {
	SHH("choice --> action_prefix");
	cout << "Choice\n";
	/* Pop (and destroy) the replicated top and everything above. */
	css.pop();
	cout << "CSS height = (pop) " << css.stack.size() << "\n";
	$$ = $1;
	OUT($$->print(&actions));
    }
    | choice '|' {
	SHH("choice --> choice | (cont)");
	/* Replicate the CSS stack top so that it can be used by
	   'action_prefix'. */
	css.push_clone();
	cout << "CSS height (push) " << css.stack.size() << "\n";
    } action_prefix {
	SHH("choice --> (cont) action_prefix");
	IN($1->print(&actions); $4->print(&actions));
	/* Pop (and destroy) the replicated top and everything above. */
	css.pop();
	cout << "CSS height = (pop) " << css.stack.size() << "\n";
	cout << "Choice\n";
	cout << "ch|ap\n"; current_contexts.print();

	/* If the frontier is empty, $1 must be the zero node, and so we
	   just have to merge $1 and $4, adding to $1 all the edges of $4.
	   If the frontier is not empty, it means that the choice we are
	   processing is not onto the zero node, but somewhere in the middle
	   of the graph: In this case the merging operation has already been
	   done by the action associated to the rule 
	   'prefix_actions: actions_label'.
	 */
	if (current_contexts.frontier.size() == 0) {
	    ProcessNode * pnpl = err_if_not_procnode($1);
	    ProcessNode * pnpr = err_if_not_procnode($4);
	    for (int i=0; i<pnpr->children.size(); i++)
		pnpl->children.push_back(pnpr->children[i]);
	    /* We must delete only the ProcessNode pointed by $4, but not the
	       whole graph! */
	    delete pnpr;
	    //$1->print();
	}
	$$ = $1;
	OUT($$->print(&actions));
	gpp->print(&actions);
    }
    ;

action_prefix:
    guard_OPT {
	SHH("action_prefix --> guard_OPT (cont)");
	ConstValue * cvp;
	current_contexts.print();
	if ($1) {
	    for (int c=0; c<current_contexts.size(); c++) {
		cvp = err_if_not_const($1->v[c]);
		if (!cvp->value)
		    current_contexts.rule_out(c);
	    }
	    cout << "filtered\n"; current_contexts.print();
	}
    } prefix_actions ARROW local_process {
	SHH("action_prefix --> (cont) prefix_actions -> local_process");
	IN($3->print(&actions); $5->print(&actions));

	/* If $5 is an istance of ConnectedProcess, it means that its first 
	   nodes have already been connected to the frontier of $3 in the
	   lower level rule 'prefix_actions'. Therefore there is nothing to
	   be done here. */
	if (!$5->connected()) {
	    if (!($5->unresolved())) {
		/* If $5 is not an unresolved reference, we connect the
		   current frontier (e.g. the frontier of $3) to the process
		    $5. */
		for (int i=0; i<current_contexts.frontier.size(); i++) {
		    ProcessNode * pnp = current_contexts.frontier[i].pnp;
		    int child = current_contexts.frontier[i].child;
		    pnp->children[child].dest = (ProcessNode *)$5;
		}
	    } else {
		/* If $5 is an unresolved reference, we scan the current
		   frontier recording the reference itself, so that this
		   reference will be fixed by the upper levels. */
		string reference = ((UnresolvedProcess *)$5)->reference;
		for (int i=0; i<current_contexts.frontier.size(); i++) {
		    ProcessNode * pnp = current_contexts.frontier[i].pnp;
		    int child = current_contexts.frontier[i].child;
		    pnp->children[child].unresolved_reference = reference;
		}
	    }
	}
	//$3->print();
	$$ = $3;
	OUT($$->print(&actions));
	gpp->print(&actions);
    }
    ;

prefix_actions:
    action_labels {
	SHH("prefix_actions --> action_labels");
	IN($1->print(); current_contexts.print());
	ProcessNode * pnp;
	ProcessEdge e;
	SetValue * setvp;
	struct FrontierElement fe;

	/* Note that this is executed (obviously) after $1 has been
	   parsed, and so after all the context ramifications implied by
	   the latter have been executed. */

	if (current_contexts.frontier.size() == 0) {
	    /* If the frontier is empty, it means that we are at very
	       beginning of a process definition (e.g. "P=(a->..."), or
	       we are processing a choice alternative to the very first
	       choice (e.g. "P(a->b->P|d->...").
	       In this case we create a node that will be the zero node,
	       (or that will be merged with the zero node) and add to it a
	       NULL pointing edge for each action in $1. All these edges
	       are pushed into the current frontier. */
	    pnp = new ProcessNode;
	    pnp->type = ProcessNode::Normal;

	    for (int c=0; c<$1->v.size(); c++) {
		if (current_contexts.is_ruled_out(c)) continue;
		setvp = err_if_not_set($1->v[c]);
		for (int i=0; i<setvp->actions.size(); i++) {
		    e.action = actions.insert(setvp->actions[i]);
		    e.dest = NULL;
		    e.rank = c;
		    pnp->children.push_back(e);
		    fe.pnp = pnp;
		    fe.child = pnp->children.size() - 1;
		    current_contexts.frontier.push_back(fe);
		}
	    }
	    delete $1;
	    $$ = pnp;
	    if (gpp == NULL) gpp = pnp; //XXX
	} else {
	    /* If the frontier is not empty, it means that, although at the
	       beginning of an 'action_prefix', we are in the middle of
	       a process definition (e.g. "P=(a->b->(c->..." or
	       "P=(a-b->(c->d->P|e->..."). In this case we have consider all
	       the edges in the frontier (e.g. the edge "b").
	    */
	    vector<FrontierElement> new_frontier;
	    ProcessNode * pnp;
	    ProcessNode * npnp;
	    ProcessEdge e;
	    SetValue * setvp;
	    int rank;
	    int child;
	    struct FrontierElement fe;

	    for (int i=0; i<current_contexts.frontier.size(); i++) {
		pnp = current_contexts.frontier[i].pnp;
		child = current_contexts.frontier[i].child;
		/* If the edge i is NULL-pointing, it means that we are
		   at the beginning of a choice construct (e.g.
		   "P=(a->b->(c->..."): We then create a node for that
		   edge (in our example we create a node for "b"). If the
		   edge is not NULL-pointing, it means that we are in 
		   the middle of a choice construct (e.g.
		   "P=(a-b->(c->d->P|e->...") and so the node has already
		   been created when processing the first choice element.
		   There is no need to create anything.
		 */
		if (pnp->children[child].dest == NULL)
		    pnp->children[child].dest = 
			new ProcessNode(ProcessNode::Normal);
		npnp = pnp->children[child].dest;
		/* Once we get the node pointed by the edge i (npnp), we
		   have to combine that edge with the sets in $1. We
		   have a combination when the rank of the edge is equal
		   to the rank of the set. When we find a combination, we
		   add to npnp a NULL-pointing edge for each element in 
		   the matching set.
		 */
		rank = pnp->children[child].rank;
		for (int c=0; c<$1->v.size(); c++) {
		    if (current_contexts.is_ruled_out(c)) continue;
		    setvp = err_if_not_set($1->v[c]);
		    if (setvp->rank == rank) {
			for (int k=0; k<setvp->actions.size(); k++) {
			    e.action = actions.insert(setvp->actions[k]);
			    e.dest = NULL;
			    /* We set e.rank to the index in the SvpVec
			       $1 of setvp, so that this edge will
			       combine with actions in the next level
			       that have the same rank. */
			    e.rank = c;
			    npnp->children.push_back(e);
			    /* We add the edge to the new frontier, so that
			       it will be used for combination with the next
			        level actions. */
			    fe.pnp = npnp;
			    fe.child = npnp->children.size() - 1;
			    new_frontier.push_back(fe);
			}
		    }
		}
	    }
	    /* Update the frontier. */
	    current_contexts.frontier = new_frontier;
	    /* Tell the upper level rule (action_prefix) that the beginning
	       of this prefix_actions has already been connected, and so
	       'local_process' results already connected (see above). */
	    $$ = new ConnectedProcess();
	}
	OUT($$->print(&actions));
	gpp->print(&actions);
    }
    | prefix_actions ARROW action_labels {
	SHH("prefix_actions --> prefix_actions -> action_labels");
	IN($3->print(); current_contexts.print());
	ProcessNode * pnp;
	ProcessNode * npnp;
	ProcessEdge e;
	SetValue * setvp;
	int rank;
	int child;
	struct FrontierElement fe;
	vector<FrontierElement> new_frontier;

	/* Here we are in the middle of a 'prefix_actions' 
	   (e.g. "...->b->c->d->.."), and so we have to connect each edge in
	   the frontier with the action sets in $3 (e.g. we have a frontier
	   that contains a NULL-pointing edge "c" and $3={{d}}).
	*/
	for (int i=0; i<current_contexts.frontier.size(); i++) {
	    pnp = current_contexts.frontier[i].pnp;
	    child = current_contexts.frontier[i].child;
	    /* Here we have to do the same combination descripted above,
	       but only if the edge in the frontier is NULL-pointing and
	       it has not an unresolved reference associated. If the
	       edge is not NULL-pointing, it means that we are in a 
	       situation like this "...->a->(b->c->...|d->e->...)". In
	       this case pnp is the node which has an edge "b" and an 
	       edge "d", and $3={{e}}: Therefore we don't have to consider
	       the edge "b" for combinations, since it has already been used
	       when processing the previous choice element. We only have to
	       consider "d". If an edge has an unresolved reference, 
	       it means that we are in a situation like this
	       "..a->(b->P|d->e->...)": this case is very similar to the
	       previous one, but here the edge "b" is NULL-pointing,
	       only because of the unresolved reference P: considering it
	       for combinations would be an error. */
	    if (pnp->children[child].dest == NULL &&
		    pnp->children[child].unresolved_reference == "") {
		pnp->children[child].dest = 
		    new ProcessNode(ProcessNode::Normal);
		npnp = pnp->children[child].dest;
		rank = pnp->children[child].rank;
		for (int c=0; c<$3->v.size(); c++) {
		    if (current_contexts.is_ruled_out(c)) continue;
		    setvp = err_if_not_set($3->v[c]);
		    if (setvp->rank == rank) {
			for (int k=0; k<setvp->actions.size(); k++) {
			    e.action = actions.insert(setvp->actions[k]);
			    e.dest = NULL;
			    /* We set e.rank to the index in the SvpVec
			       $3, so that this edge will combine with
			       actions in the next level that have the
			       same rank. */
			    e.rank = c;
			    npnp->children.push_back(e);
			    fe.pnp = npnp;
			    fe.child = npnp->children.size() - 1;
			    new_frontier.push_back(fe);
			}
		    }
		}
	    }
	}
	current_contexts.frontier = new_frontier;
	/* Note that $1 is not used in this action, because we use the
	   frontier stored in current_contexts. As a result, $1 is
	   the result of the previous action (and so a ProcessNode* or a
	   ConnectedProcess*. */
	$$ = $1;
	OUT($$->print(&actions));
	gpp->print(&actions);
    }
    ;

guard_OPT:
    {
	$$ = NULL;
    }
    | WHEN expression {
	SHH("guard_OPT --> WHEN expression");
	for (int i=0; i<$2->v.size(); i++)
	    err_if_not_const($2->v[i]);
	$$ = $2;
	OUT($$->print());
    }
    ;

indices_OPT:
    | indices
    ;

indices:
    '[' expression ']' {
	SHH("indices --> [ expression ]");
    }
    | indices '[' expression ']' {
	SHH("indices --> indices [ expression ]");
    }
    ;

index_ranges_OPT:
    {
	$$ = NULL;
    }
    | index_ranges
    ;

index_ranges:
    '[' action_range ']' {
	SHH("index_ranges --> [ action_range ]");
	IN($2->print());
	SvpVec * vp;
	SetValue * setvp;
	ConstValue * cvp;

	//TODO need rank here!
	/* Here we are sure to have only the empty context. */
	if ($2->v.size() != 1) {cout << "FATAL 523\n";exit(-1);}
	switch ($2->v[0]->type()) {
	    case SymbolValue::Const:
		cvp = err_if_not_const($2->v[0]);
		setvp = new SetValue;
		setvp->actions.push_back("[" + int2string(cvp->value) + "]");
		break;
	    default:
		cout << "STILL TO IMPLEMENT 523\n";
		exit(1);    
	}
	delete $2;

	vp = new SvpVec;
	vp->v.push_back(setvp);
	$$ = vp;
	OUT($$->print());
    }
    | index_ranges '[' action_range ']' {
	SHH("index_ranges --> index_ranges [ action_range ]");
	IN($1->print(); $3->print());
	SvpVec * vp;
	SetValue * setvp;
	ConstValue * cvp;

	if ($3->v.size() != $1->v.size()) {cout << "FATAL 836\n";exit(-1);}
	switch ($3->v[0]->type()) {
	    case SymbolValue::Const:
		for (int c=0; c<$1->v.size(); c++) {
		    setvp = err_if_not_set($1->v[c]);
		    cvp = err_if_not_const($3->v[c]);
		    setvp->indexize(cvp->value);
		}
		delete $3;
		$$ = $1;
		break;
	    default:
		cout << "STILL TO IMPLEMENT 836\n";
		exit(1);    
	}
	OUT($$->print());
    }
    ;

sequential_composition:
    seq_process_list ';' base_local_process {
	SHH("sequential_composition --> seq_process_list ; \
		base_local_process");
	$$ = $1;
    }
    ;

seq_process_list:
    process_ref {
	SHH("seq_process_list --> process_ref");
	$$ = $1;
    }
    | seq_process_list ';' process_ref {
	SHH("seq_process_list --> seq_process_list ; process_ref");
	$$ = $1;
    }
    ;

process_ref:
    process_id argument_OPT {
	SHH("process_ref --> process_id argument_OPT");
	//TODO
	ProcessNode * pnp = new ProcessNode;
	$$ = pnp;
    }
    ;

argument_OPT:
    |'(' argument_list ')' {
	SHH("argument_OPT --> ( argument_list )");
    }
    ;

argument_list:
    expression {
	SHH("argument_list --> expression");
    }
    | argument_list ',' expression {
	SHH("argument_list --> argument_list , expression");
    }
    ;


/* Composite process */
composite_def:
    OR process_id param_OPT '=' composite_body priority_OPT hiding_OPT '.'
    ;

composite_body:
    prefix_label_OPT process_ref relabel_OPT
    | prefix_label_OPT '(' parallel_composition ')' relabel_OPT
    | FORALL ranges composite_body
    | IF expression THEN composite_body
    | IF expression THEN composite_body ELSE composite_body
    ;

parallel_composition:
    composite_body
    | parallel_composition OR composite_body
    ;

prefix_label_OPT:
    | prefix_label
    ;

// TODO add the third option
prefix_label:
    action_labels ':' 
    | action_labels SHARING
    ;

priority_OPT:
    | priority;

priority:
    RSHIFT set
    | LSHIFT set
    ;

ranges_OPT:
    | ranges;

ranges:
    '[' action_range ']'
    | ranges '[' action_range ']'
    ;


/* Parameters */
param_OPT:
    | param {
	SHH("param_OPT -->  param");
    }
    ;

param:
    '(' parameter_list ')' {
	SHH("param -> ( parameter_list )");
    }
    ;

parameter_list:
    parameter {
	SHH("parameter_list --> parameter");
    }
    | parameter_list ',' parameter {
	SHH("parameter_list --> parameter_list , parameter");
    }
    ;

parameter:
    parameter_id '=' expression {
	SHH("parameter --> parameter_id = expression");
	if ($3->v.size() != 1) {
	    // XXX this should never happen..
	    errstream << "Illegal use of variables in parameter declaration";
	    semantic_error();
	}
	ConstValue * cvp = err_if_not_const($3->v[0]);
	$3->detach(0);
	SymbolValue * svp = cvp;
	if (!identifiers.insert(*$1, svp)) {
	    errstream << "identifier " << *$1 << " already declared";
	    semantic_error();
	}
	parameters.push_back($1);
	delete $3;
    }	
    ;


/* Re-Labeling and Hiding */
relabel_OPT:
    | relabel
    ;

relabel:
    '/' '{' relabel_defs '}'
    ;

relabel_defs:
    relabel_def
    | relabel_defs ',' relabel_def
    ;

relabel_def:
    action_labels '/' action_labels
    | FORALL index_ranges '{' relabel_defs '}'
    ;

hiding_OPT:
    | hiding
    ;

hiding:
    '\\' set
    | '@' set
    ;


/* Property, Progress and Menu */
// TODO second form of progress (if S then C)
property_def:
    PROPERTY process_def
    ;

progress_def:
    PROGRESS progress_id ranges_OPT '=' set
    ;

menu_def:
    MENU menu_id '=' set
    ;


/* An expression or a simple_expression: standard operators and priorities. */
expression:
    or_expr {
	SHH("expression --> or_expr");
	$$ = $1;
	OUT($$->print());
    }
    ;

simple_expression:
    additive_expr {
	SHH("simple_expression --> additive_expr");
	$$ = $1;
	OUT($$->print());
    }
    ;

or_expr:
    and_expr
    | or_expr OR and_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = vpl->value || vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

and_expr:
    bitor_expr
    | and_expr AND bitor_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = vpl->value && vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

bitor_expr:
    bitxor_expr
    | bitor_expr '|' bitxor_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value |= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

bitxor_expr:
    bitand_expr
    | bitxor_expr '^' bitand_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value ^= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

bitand_expr:
    equality_expr
    | bitand_expr '&' equality_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value &= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

equality_expr:
    relational_expr
    | equality_expr EQUAL relational_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value == vpr->value);
	}
	delete $3;
	$$ = $1;
    }
    | equality_expr NOTEQUAL relational_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value != vpr->value);
	}
	delete $3;
	$$ = $1;
    }
    ;

relational_expr:
    shift_expr
    | relational_expr '<' shift_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value < vpr->value);
	}
	delete $3;
	$$ = $1;
    }
    | relational_expr '>' shift_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value > vpr->value);
	}
	delete $3;
	$$ = $1;
    }
    | relational_expr LOE shift_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value <= vpr->value);
	}
	delete $3;
	$$ = $1;
    }
    | relational_expr GOE shift_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value >= vpr->value);
	}
	delete $3;
	$$ = $1;
    }
    ;

shift_expr:
    additive_expr
    | shift_expr LSHIFT additive_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value <<= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    | shift_expr RSHIFT additive_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value >>= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

additive_expr:
    multiplicative_expr
    | additive_expr '+' multiplicative_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value += vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    | additive_expr '-' multiplicative_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value -= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

multiplicative_expr:
    unary_expr
    | multiplicative_expr '*' unary_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value *= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    | multiplicative_expr '/' unary_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value /= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    | multiplicative_expr '%' unary_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = vpl->value % vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

unary_expr:
    base_expr
    | '+' base_expr {
	for (int i=0; i<$2->v.size(); i++) {
	    err_if_not_const($2->v[i]);
	}
	$$ = $2;
    }
    | '-' base_expr {
	SvpVec * vp = new SvpVec;
	ConstValue * cvp;
	for (int i=0; i<$2->v.size(); i++) {
	    cvp = err_if_not_const($2->v[i]);
	    cvp->value *= -1;;
	    vp->v.push_back(cvp);
	}
	$$ = vp;
    }
    | '!' base_expr {
	SvpVec * vp = new SvpVec;
	ConstValue * cvp;
	for (int i=0; i<$2->v.size(); i++) {
	    cvp = err_if_not_const($2->v[i]);
	    cvp->value = !(cvp->value);
	    vp->v.push_back(cvp);
	}
	$$ = vp;
    }
    ;

/* TODO: complete base_expr */
base_expr:
    INTEGER {
	SvpVec * vp;
	ConstValue * cvp;

	/* Return a ConstValue* for each context (in non shared mode). */
	vp = new SvpVec;
	vp->shared = false;
	for (int c=0; c<current_contexts.size(); c++) {
	    cvp = new ConstValue;
	    cvp->value = $1;
	    vp->v.push_back(cvp);
	}
	$$ = vp;
    }
    | variable {
	/* Return a ConstValue* for each context (in non shared mode). */
	SvpVec * vp;

	vp = new SvpVec;
	vp->shared = false;
	for (int c=0; c<current_contexts.size(); c++) {
	    SymbolValue * svp;
	    if (!(current_contexts[c]->lookup(*$1, svp))) {
		errstream << "variable " << *$1 << " undeclared\n";
		semantic_error();
	    }
	    svp = svp->clone();
	    vp->v.push_back(svp);
	}
	delete $1;
	$$ = vp;
    }
    | const_range_set_parameter_id {
	SymbolValue * svp;
	SvpVec * vp; 
	
	/* Lookup the identifier and clone the associated object. */
	if (!identifiers.lookup(*$1, svp)) {
	    errstream << "const/range/set/parameter " << *$1
			    << " undeclared";
	    semantic_error();
	}
	delete $1;

	/* Return a ConstValue* for each context (in non shared mode). */
	vp = new SvpVec;
	vp->shared = false;
	for (int c=0; c<current_contexts.size(); c++)
	    vp->v.push_back(svp->clone());
	$$ = vp;
    }
    | '(' expression ')' { $$ = $2; }
    ;

/* Some useful alias for LowerCaseID and UpperCaseID. */
variable: LowerCaseID;
constant_id: UpperCaseID;
range_id: UpperCaseID;
set_id: UpperCaseID;
range_or_set_id: set_id;
const_range_set_parameter_id: set_id;
parameter_id: UpperCaseID;
process_id: UpperCaseID;
progress_id: UpperCaseID;
menu_id: UpperCaseID;

%%

void fix_unresolved_references(ProcessNode * pnp, void * opaque)
{
    ActionsTable * atp = (ActionsTable *)opaque;

    for (int i=0; i<pnp->children.size(); i++) {
	ProcessEdge& e = pnp->children[i];
	SymbolValue * svp;
	if (e.dest == NULL) {
	    cout << "Unref " << pnp << ": " << actions.reverse[e.action]
		<< " -> " << e.unresolved_reference << "\n";				
	    if (!processes.lookup(e.unresolved_reference, svp)) {
		errstream << "Local process " << pnp << ": "
		    << e.unresolved_reference << " undeclared\n";
		semantic_error();
	    }
	    e.dest = ((ProcessValue *)svp)->pnp;
	}
    }
}


int parser()
{
    FILE *fin = fopen("input", "r");
    if (!fin) {
	cout << "I can't open 'input'!" << endl;
	return -1;
    }

    /* Initialize shared data structures: A stack containing a single
       ContextsSet. This set contains a single empty Context and an
       empty frontier. */
    ContextsSet * csp = new ContextsSet;
    csp->append(new Context);
    css.push(csp);


    /* Set flex to read from it instead of defaulting to STDIN. */
    yyin = fin;

    /* Parse through the input until there is no more. */
    do {
	yyparse();
    } while (!feof(yyin));
    
    return 0;
}

void yyerror(const char *s) {
    cout << "Syntax error:" << s << endl;
    // might as well halt now:
    exit(-1);
}

