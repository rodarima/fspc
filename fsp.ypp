%{
#include <cstdio>
#include <iostream>
#include <sstream>
#include <cstdlib>
#include <set>
#include <vector>

using namespace std;

/* Stuff from flex that bison needs to know about. */
extern int yylex();
extern FILE * yyin;

/* Symbols tables. */
#include "strings_table.hpp"
extern struct SymbolsTable identifiers;
extern struct SymbolsTable processes;

/* Strings sets. */
#include "strings_set.hpp"
#include "lts.hpp"

void fixUnresolvedReferences(ProcessNode * pnp);


/* For semantic errors */
stringstream errstream;

void semantic_error()
{
    cout << "Semantic error: " << errstream.str() << "\n";
    exit(-1);
}

inline ConstValue* err_if_not_const(SymbolValue * svp)
{
    if (svp->type() != SymbolValue::Const) {
	errstream << "Unexpected range/set";
	semantic_error();
    }

    return (ConstValue *)svp;
}

void yyerror(const char *s);
%}

// Bison fundamentally works by asking flex to get the next token, which it
// returns as an object of type "YYSTYPE".  But tokens could be of any
// arbitrary data type!  So we deal with that in Bison by defining a C union
// holding each of the types of tokens that Flex could return, and have Bison
// use that union instead of "int" for the definition of "YYSTYPE":
%union {
    int int_value;
    float float_value;
    std::string *string_ptr;
    class StringsSet *sset_ptr;
    class SymbolValue *sv_ptr;
    class RangeValue *rv_ptr;
    class Lts *lv_ptr;
    class ProcessNode * pn_ptr;
    class ProcessBase * pb_ptr;
}

// define the "terminal symbol" token types I'm going to use (in CAPS
// by convention), and associate each with a field of the union:


%token IF THEN ELSE
%token WHEN
%token CONST RANGE SET
%token ARROW
%token DOTDOT
%token <pn_ptr> END STOP ERROR
%token PROPERTY PROGRESS MENU
%token FORALL
%token SHARING
%token OR AND EQUAL NOTEQUAL LOE GOE LSHIFT RSHIFT
%token <int_value> INTEGER
%token <float_value> FLOAT
%token <string_ptr> UpperCaseID
%token <string_ptr> LowerCaseID

%type <sv_ptr> simple_expression
%type <sv_ptr> base_expr expression unary_expr multiplicative_expr
%type <sv_ptr>  additive_expr shift_expr relational_expr equality_expr
%type <sv_ptr> bitand_expr bitxor_expr bitor_expr and_expr or_expr

%type <string_ptr> variable constant_id range_id set_id range_or_set_id
%type <string_ptr> parameter_id process_id progress_id menu_id
%type <string_ptr> const_range_set_id

%type <sset_ptr> action_labels set set_expr set_elements
%type <sv_ptr> action_range
%type <rv_ptr> range_expr
%type <pn_ptr> choice action_prefix prefix_actions
%type <pb_ptr> process_body local_process local_process_defs local_process_def
%type <pb_ptr> sequential_composition base_local_process
%type <pb_ptr> seq_process_list process_ref

%glr-parser

%%

/* Start symbol: an arbitrary long list of fsp_definitions */
fsp_description:
    fsp_definition
    | fsp_description fsp_definition
    ;

/* All the possible type of fsp_definitions */
fsp_definition:
    constant_def
    | range_def
    | set_def
    | property_def
    | progress_def
    | menu_def
    | process_def
    | composite_def
    ;


/* Action labels TODO: fix */
action_labels:
    LowerCaseID {
	$$ = new StringsSet(*$1);
	/* Free the memory allocated by flex for the token. */
	delete $1; 
    }
    | set
    | action_labels '.' LowerCaseID {
	$1->dotcat(*$3);
	delete $3;
	$$ = $1;
    }
    | action_labels '.' set {
	$1->dotcat(*$3);
	delete $3;
	$$ = $1;
    }
    | action_labels '[' action_range ']' {
	StringsSet * ssp;
	ConstValue * cvp;
	RangeValue * rvp;

	switch ($3->type()) {
	    case SymbolValue::Const:
		cvp = ((ConstValue *)$3);
		$1->indexize(cvp->value);
		break;

	    case SymbolValue::Range:
		rvp = ((RangeValue *)$3);
		$1->print();
		$1->indexize(rvp->low, rvp->high);
		break;

	    case SymbolValue::Set:
		ssp = ((SetValue *)$3)->ssp;
		$1->indexize(*ssp);
		break;

	    default:
		errstream << "Internal error: unexpected symbol type\n";
		semantic_error();
	};

	delete $3;
	$$ = $1;
    }
    ;

set:
    set_id {
	SymbolValue * svp;
	StringsSet * ss;
	int ok = identifiers.lookup(*$1, svp);
	if (!ok) {
	    errstream << "set " << *$1 << " undeclared";
	    semantic_error();
	}
	if (svp->type() != SymbolValue::Set) {
	    errstream << "identifier " << *$1 << " is not a set";
	    semantic_error();
	}
	ss = new StringsSet(*(((SetValue *)svp)->ssp));
	$$ = ss;
    }
    | set_expr
    ;

set_expr:
    '{' set_elements '}' { $$ = $2; }
    ;

action_range:
    expression {
	$$ = $1;
    }
    | range_expr {
	$$ = (SymbolValue *)$1;
	cout << "From RangeValue to SymbolValue\n";
    }
    | set_expr {
	SetValue * vp = new SetValue;
	vp->ssp = $1;
	$$ = (SymbolValue *)vp;
    }
    | variable ':' range_or_set_id {
	// TODO pass the variable
	SymbolValue * svp;
	int ok = identifiers.lookup(*$3, svp);
	if (!ok) {
	    errstream << "range/set " << *$3 << " undeclared";
	    semantic_error();
	}
	svp = svp->clone();
	$$ = svp;
	
    }
    | variable ':' range_expr {
	//TODO variable
	$$ = (SymbolValue *)$3;
    }
    | variable ':' set_expr {
	//TODO variable
	SetValue * vp = new SetValue;
	vp->ssp = $3;
	$$ = (SymbolValue *)vp;
    }
    ;

range_expr:
    expression DOTDOT expression {
	RangeValue * vp = new RangeValue;
	ConstValue * cvp = err_if_not_const($1);
	vp->low = cvp->value;
	delete $1;
	cvp = err_if_not_const($3);
	vp->high = cvp->value;
	delete $3;
	$$ = vp;
    }
    ;


/* Const, Range, Set */
constant_def:
    CONST constant_id '=' simple_expression {
	ConstValue* cvp = err_if_not_const($4);
	cout << "<<B>> Const " << *$2 << "=" << cvp->value << "\n";
	int ok = identifiers.insert(*$2, cvp);
	if (!ok) {
	    errstream << "const " << *$2 << " declared twice";
	    semantic_error();
	}
    };

range_def:
    RANGE range_id '=' simple_expression DOTDOT simple_expression {
	RangeValue* rvp = new RangeValue;
	ConstValue * cvp1 = err_if_not_const($4);
	ConstValue * cvp2 = err_if_not_const($6);
	cout << "<<B>> Range " << *$2 << cvp1->value << cvp2->value << "\n";
	rvp->low = cvp1->value;
	rvp->high = cvp2->value;
	delete cvp1;
	delete cvp2;
	int ok = identifiers.insert(*$2, rvp);
	if (!ok) {
	    errstream << "range " << *$2 << " declared twice";
	    semantic_error();
	}
    };

set_def:
    SET set_id '=' '{' set_elements '}' {
	cout << "<<B>> Set\n";
	SetValue* vp = new SetValue;
	vp->ssp = $5;
	int ok = identifiers.insert(*$2, vp);
	if (!ok) {
	    errstream << "set " << *$2 << " declared twice";
	    semantic_error();
	}
	$5->print();
    };

set_elements:
    action_labels {
	$$ = $1;
    }
    | set_elements ',' action_labels {
	*$1 += *$3;
	// XXX delete $3 ?? 
	$$ = $1;
    }
    ;


/* Processes */
process_def:
    process_id param_OPT '=' process_body alphabet_extension_OPT
					    relabel_OPT hiding_OPT '.' {
	if ($4->unresolved()) {
	    errstream << "Local process " << 
		    ((UnresolvedProcess * )$4)->reference << " undeclared\n";
	    semantic_error();
	}

	/* Insert a new ProcessValue in the symbol table, attaching the
	   process_body to it. */
	ProcessValue * pvp = new ProcessValue;
	cout << "Process " << *$1 << " defined\n";
	int ok = processes.insert(*$1, pvp);
	if (!ok) {
	    errstream << "process " << *$1 << " declared twice";
	    semantic_error();
	}
	pvp->pnp = (ProcessNode *)$4;

	/* Try to resolve all the undefined references into this process. */
	pvp->pnp->visit(&fixUnresolvedReferences);

	pvp->pnp->print();
	// TODO implement everything is OPT
    }
    ;

process_body:
    local_process
    | local_process ',' local_process_defs {
	// TODO compose
	$$ = $1;
    }
    ;

local_process_defs:
    local_process_def
    | local_process_defs ',' local_process_def {
	// TODO compose
	$$ = $1;
    }
    ;

local_process_def:
    process_id index_ranges_OPT '=' local_process {
	// TODO index_ranges_OPT
	$$ = $4;
    }
    ;

alphabet_extension_OPT:
    | '+' set
    ;

local_process:
    base_local_process
    | sequential_composition
    | IF expression THEN local_process {
	ConstValue * cvp = err_if_not_const($2);
	if (cvp->value)
	    $$ = $4;
	else {
	    /* If the condition is not true, return a STOP process. */
	    delete $4;
	    $$ = new ProcessNode;
	}
    }
    | IF expression THEN local_process ELSE local_process {
	ConstValue * cvp = err_if_not_const($2);
	if (cvp->value) {
	    delete $6;
	    $$ = $4;
	} else {
	    delete $4;
	    $$ = $6;
	}
    }
    | '(' choice ')' {
	cout << "(choice)\n";
	//$2->print();
	$$ = $2;
    }
    ;

base_local_process:
    END {
	$$ = new ProcessNode(ProcessNode::End);
    }
    | STOP {
	$$ = new ProcessNode;
    }
    | ERROR {
	$$ = new ProcessNode(ProcessNode::Error);
    }
    | process_id indices_OPT {
	//TODO implement indices_OPT
	SymbolValue * svp;
	/* If the process referenced is already defined, return it.
	   Otherwise return a new UnresolvedProcess object, so that the
	   upper level sees that *$1 is unresolved. */
	bool ok = processes.lookup(*$1, svp);
	if (ok)
	    $$ = ((ProcessValue *)svp)->pnp;
	else
	    $$ = new UnresolvedProcess(*$1);
    }
    ;

choice:
    action_prefix
    | choice '|' action_prefix {
	cout << "Choice\n";
	/* Merge $1 head and $3 head. */
	for (int i=0; i<$3->children.size(); i++)
	    $1->children.push_back($3->children[i]);
	// XXX must delete $3 but not the whole graph!
	//$1->print();
	$$ = $1;
    }
    ;

action_prefix:
    guard_OPT prefix_actions ARROW local_process {
	// TODO guard_OPT

	if (!($4->unresolved())) {
	    /* If $4 is not an unresolved reference, we connect the frontier 
	       of $2 to the process $4. */
	    for (int i=0; i<$2->frontier_shortcut.size(); i++) {
		ProcessNode * pnp = $2->frontier_shortcut[i];
		for (int j=0; j<pnp->children.size(); j++)
		    pnp->children[j].dest = (ProcessNode *)$4;
	    }
	} else {
	    /* If $4 is an unresolved reference, we scan the frontier of $2
	       recording the reference itslef, so that this reference will
	       be fixed by the upper levels. */
	    string reference = ((UnresolvedProcess *)$4)->reference;
	    for (int i=0; i<$2->frontier_shortcut.size(); i++) {
		ProcessNode * pnp = $2->frontier_shortcut[i];
		for (int j=0; j<pnp->children.size(); j++) {
		    pnp->children[j].unresolved_reference = reference;
		}
	    }
	}
	//$2->print();
	$$ = $2;
    }
    ;

prefix_actions:
    action_labels {
	cout << "Action: "; $1->print();
	ProcessNode * pnp = new ProcessNode;
	ProcessEdge e;

	pnp->type = ProcessNode::Normal;
	pnp->frontier_shortcut.push_back(pnp);
	for (int i=0; i<$1->strings.size(); i++) {
	    e.action = $1->strings[i];
	    e.dest = NULL;
	    pnp->children.push_back(e);
	}
	delete $1;
	//pnp->print();
	$$ = pnp;
	    
    }
    | prefix_actions ARROW action_labels {
	cout << "Action(->): "; $3->print();
	ProcessNode * rpnp = new ProcessNode;
	ProcessEdge e;

	rpnp->type = ProcessNode::Normal;
	for (int i=0; i<$3->strings.size(); i++) {
	    e.action = $3->strings[i];
	    e.dest = NULL;
	    rpnp->children.push_back(e);
	}
	delete $3;
	//rpnp->print();
	
	/* Attach an rpnp clone to each node in the frontier. */
	vector<ProcessNode*> new_frontier(1);
	$1->frontier_shortcut[0]->children[0].dest = rpnp;
	new_frontier[0] = rpnp;
	for (int i=0; i<$1->frontier_shortcut.size(); i++) {
	    ProcessNode * pnp = $1->frontier_shortcut[i];
	    cout << "Frontier element: " << pnp << "\n";
	    for (int j=0; j<pnp->children.size(); j++)
		if (i || j) {
		    pnp->children[j].dest = rpnp->clone();
		    new_frontier.push_back(pnp->children[j].dest);
		}
	}
	$1->frontier_shortcut = new_frontier;
	
	//$1->print();
	$$ = $1;
    }
    ;

guard_OPT:
    | WHEN expression
    ;

indices_OPT:
    | indices
    ;

indices:
    '[' expression ']'
    | indices '[' expression ']'
    ;

index_ranges_OPT:
    | index_ranges
    ;

index_ranges:
    '[' expression ']'
    | index_ranges '[' expression ']'
    | '[' action_range ']'
    | index_ranges '[' action_range ']'
    ;

sequential_composition:
    seq_process_list ';' base_local_process
    ;

seq_process_list:
    process_ref
    | seq_process_list ';' process_ref
    ;

process_ref:
    process_id argument_OPT {
	//TODO
	ProcessNode * pnp = new ProcessNode;
	$$ = pnp;
    }
    ;

argument_OPT:
    |'(' argument_list ')'
    ;

argument_list:
    expression
    | argument_list ',' expression
    ;


/* Composite process */
composite_def:
    OR process_id param_OPT '=' composite_body priority_OPT hiding_OPT '.'
    ;

composite_body:
    prefix_label_OPT process_ref relabel_OPT
    | prefix_label_OPT '(' parallel_composition ')' relabel_OPT
    | FORALL ranges composite_body
    | IF expression THEN composite_body
    | IF expression THEN composite_body ELSE composite_body
    ;

parallel_composition:
    composite_body
    | parallel_composition OR composite_body
    ;

prefix_label_OPT:
    | prefix_label
    ;

// TODO add the third option
prefix_label:
    action_labels ':' 
    | action_labels SHARING
    ;

priority_OPT:
    | priority;

priority:
    RSHIFT set
    | LSHIFT set
    ;

ranges_OPT:
    | ranges;

ranges:
    '[' action_range ']'
    | ranges '[' action_range ']'
    ;


/* Parameters */
param_OPT:
    | param
    ;

param:
    '(' parameter_list ')'
    ;

parameter_list:
    parameter
    | parameter_list ',' parameter
    ;

parameter:
    parameter_id '=' expression
    ;


/* Re-Labeling and Hiding */
relabel_OPT:
    | relabel
    ;

relabel:
    '/' '{' relabel_defs '}'
    ;

relabel_defs:
    relabel_def
    | relabel_defs ',' relabel_def
    ;

relabel_def:
    action_labels '/' action_labels
    | FORALL index_ranges '{' relabel_defs '}'
    ;

hiding_OPT:
    | hiding
    ;

hiding:
    '\\' set
    | '@' set
    ;


/* Property, Progress and Menu */
// TODO second form of progress (if S then C)
property_def:
    PROPERTY process_def
    ;

progress_def:
    PROGRESS progress_id ranges_OPT '=' set
    ;

menu_def:
    MENU menu_id '=' set
    ;


/* An expression or a simple_expression: standard operators and priorities. */
expression:
    or_expr {
	$$ = $1;
	if ($1->type() == SymbolValue::Const)
	    cout << "<<B>> Expression: " << ((ConstValue *)$1)->value
		    << "\n";
    }
    ;

simple_expression:
    additive_expr {
	$$ = $1;
	ConstValue * cvp = err_if_not_const($1);
	cout << "<<B>> Simple expression: " << cvp->value <<  "\n";
    }
    ;

or_expr:
    and_expr
    | or_expr OR and_expr {
	ConstValue * vpl = err_if_not_const($1);
	ConstValue * vpr = err_if_not_const($3);
	vpl->value = vpl->value || vpr->value;
	delete vpr;
	$$ = vpl;
    }
    ;

and_expr:
    bitor_expr
    | and_expr AND bitor_expr {
	ConstValue * vpl = err_if_not_const($1);
	ConstValue * vpr = err_if_not_const($3);
	vpl->value = vpl->value && vpr->value;
	delete vpr;
	$$ = vpl;
    }
    ;

bitor_expr:
    bitxor_expr
    | bitor_expr '|' bitxor_expr {
	ConstValue * vpl = err_if_not_const($1);
	ConstValue * vpr = err_if_not_const($3);
	vpl->value |= vpr->value;
	delete vpr;
	$$ = vpl;
    }
    ;

bitxor_expr:
    bitand_expr
    | bitxor_expr '^' bitand_expr {
	ConstValue * vpl = err_if_not_const($1);
	ConstValue * vpr = err_if_not_const($3);
	vpl->value ^= vpr->value;
	delete vpr;
	$$ = vpl;
    }
    ;

bitand_expr:
    equality_expr
    | bitand_expr '&' equality_expr {
	ConstValue * vpl = err_if_not_const($1);
	ConstValue * vpr = err_if_not_const($3);
	vpl->value &= vpr->value;
	delete vpr;
	$$ = vpl;
    }
    ;

equality_expr:
    relational_expr
    | equality_expr EQUAL relational_expr {
	ConstValue * vpl = err_if_not_const($1);
	ConstValue * vpr = err_if_not_const($3);
	vpl->value = (vpl->value == vpr->value);
	delete vpr;
	$$ = vpl;
    }
    | equality_expr NOTEQUAL relational_expr {
	ConstValue * vpl = err_if_not_const($1);
	ConstValue * vpr = err_if_not_const($3);
	vpl->value = (vpl->value != vpr->value);
	delete vpr;
	$$ = vpl;
    }
    ;

relational_expr:
    shift_expr
    | relational_expr '<' shift_expr {
	ConstValue * vpl = err_if_not_const($1);
	ConstValue * vpr = err_if_not_const($3);
	vpl->value = (vpl->value < vpr->value);
	delete vpr;
	$$ = vpl;
    }
    | relational_expr '>' shift_expr {
	ConstValue * vpl = err_if_not_const($1);
	ConstValue * vpr = err_if_not_const($3);
	vpl->value = (vpl->value > vpr->value);
	delete vpr;
	$$ = vpl;
    }
    | relational_expr LOE shift_expr {
	ConstValue * vpl = err_if_not_const($1);
	ConstValue * vpr = err_if_not_const($3);
	vpl->value = (vpl->value <= vpr->value);
	delete vpr;
	$$ = vpl;
    }
    | relational_expr GOE shift_expr {
	ConstValue * vpl = err_if_not_const($1);
	ConstValue * vpr = err_if_not_const($3);
	vpl->value = (vpl->value >= vpr->value);
	delete vpr;
	$$ = vpl;
    }
    ;

shift_expr:
    additive_expr
    | shift_expr LSHIFT additive_expr {
	ConstValue * vpl = err_if_not_const($1);
	ConstValue * vpr = err_if_not_const($3);
	vpl->value <<= vpr->value;
	delete vpr;
	$$ = vpl;
    }
    | shift_expr RSHIFT additive_expr {
	ConstValue * vpl = err_if_not_const($1);
	ConstValue * vpr = err_if_not_const($3);
	vpl->value >>= vpr->value;
	delete vpr;
	$$ = vpl;
    }
    ;

additive_expr:
    multiplicative_expr
    | additive_expr '+' multiplicative_expr {
	ConstValue * vpl = err_if_not_const($1);
	ConstValue * vpr = err_if_not_const($3);
	vpl->value += vpr->value;
	delete vpr;
	$$ = vpl;
    }
    | additive_expr '-' multiplicative_expr {
	ConstValue * vpl = err_if_not_const($1);
	ConstValue * vpr = err_if_not_const($3);
	vpl->value -= vpr->value;
	delete vpr;
	$$ = vpl;
    }
    ;

multiplicative_expr:
    unary_expr
    | multiplicative_expr '*' unary_expr {
	ConstValue * vpl = err_if_not_const($1);
	ConstValue * vpr = err_if_not_const($3);
	vpl->value *= vpr->value;
	delete vpr;
	$$ = vpl;
    }
    | multiplicative_expr '/' unary_expr {
	ConstValue * vpl = err_if_not_const($1);
	ConstValue * vpr = err_if_not_const($3);
	vpl->value /= vpr->value;
	delete vpr;
	$$ = vpl;
    }
    | multiplicative_expr '%' unary_expr {
	ConstValue * vpl = err_if_not_const($1);
	ConstValue * vpr = err_if_not_const($3);
	vpl->value = vpl->value % vpr->value;
	delete vpr;
	$$ = vpl;
    }
    ;

unary_expr:
    base_expr
    | '+' base_expr {
	err_if_not_const($2);
	$$ = $2;
    }
    | '-' base_expr {
	ConstValue * vp = err_if_not_const($2);
	vp->value *= -1;
	$$ = vp;
    }
    | '!' base_expr {
	ConstValue * vp = err_if_not_const($2);
	vp->value = !(vp->value);
	$$ = vp;
    }
    ;

/* TODO: complete base_expr */
base_expr:
    INTEGER {
	ConstValue * vp = new ConstValue;
	vp->value = $1;
	$$ = vp;
    }
    | variable {
	ConstValue * vp = new ConstValue;
	vp->value = 19; /*TODO take from symbols */
	$$ = vp;
    }
    | const_range_set_id {
	SymbolValue * svp;
	int ok = identifiers.lookup(*$1, svp);
	if (!ok) {
	    errstream << "const/range/set " << *$1 << " undeclared";
	    semantic_error();
	}
	svp = svp->clone();
	$$ = svp;
    }
    | '(' expression ')' { $$ = $2; }
    ;

/* Some useful alias for LowerCaseID and UpperCaseID. */
variable: LowerCaseID;
constant_id: UpperCaseID;
range_id: UpperCaseID;
set_id: UpperCaseID;
range_or_set_id: set_id;
const_range_set_id: set_id;
parameter_id: UpperCaseID;
process_id: UpperCaseID;
progress_id: UpperCaseID;
menu_id: UpperCaseID;

%%

void fixUnresolvedReferences(ProcessNode * pnp)
{
    for (int i=0; i<pnp->children.size(); i++) {
	ProcessEdge& e = pnp->children[i];
	SymbolValue * svp;
	if (e.dest == NULL) {
	    cout << "Unref " << pnp << ": " << e.action 
		<< " -> " << e.unresolved_reference << "\n";				
	    bool ok = processes.lookup(e.unresolved_reference, svp);
	    if (!ok) {
		errstream << "Local process " << pnp << ": "
		    << e.unresolved_reference << " undeclared\n";
		semantic_error();
	    }
	    e.dest = ((ProcessValue *)svp)->pnp;
	}
    }
}


int parser() {
    // open a file handle to a particular file:
    FILE *fin = fopen("input", "r");
    if (!fin) {
	cout << "I can't open 'input'!" << endl;
	return -1;
    }

    /* Set flex to read from it instead of defaulting to STDIN. */
    yyin = fin;

    /* Parse through the input until there is no more. */
    do {
	yyparse();
    } while (!feof(yyin));
    
    return 0;
}

void yyerror(const char *s) {
    cout << "Syntax error:" << s << endl;
    // might as well halt now:
    exit(-1);
}

