%code top {
#include <cstdio>
#include <iostream>
#include <sstream>
#include <cstdlib>
#include <set>
#include <vector>

using namespace std;

//#define NDEBUG
#include <assert.h>

}


%code requires {
/* Symbols tables. */
#include "symbols_table.hpp"
}


// Bison fundamentally works by asking flex to get the next token, which it
// returns as an object of type "YYSTYPE".  But tokens could be of any
// arbitrary data type!  So we deal with that in Bison by defining a C union
// holding each of the types of tokens that Flex could return, and have Bison
// use that union instead of "int" for the definition of "YYSTYPE":
%union {
    int int_value;
    float float_value;
    std::string *string_ptr;
    class SymbolValue *sv_ptr;
    struct SvpVec * svpvec_ptr;
    struct Pvec * pvec_ptr;
}


%{

/* Inline utilities. */
#include "utils.hpp"

/* Context, ContextsSet and ContextsSetStack. */
#include "context.hpp"

/* Definition of the FspTranslator class. */
#include "translator.hpp"

/* Stuff from flex that bison needs to know about. */
#include "scanner.hpp"

/* Lts definitions and operations. */
#include "lts.hpp"


template <class T>
static Context* extended_context(Context * ctx,
				const string& var, const T& val)
{
    ctx = new Context(*ctx);
    if (!ctx->insert(var, val)) {
	stringstream errstream;
	errstream << "Variable " << var << " declared twice\n";
	semantic_error(errstream);
    }

    return ctx;
}

/* Fix unresolved ProcessNode references due to cyclic processes. */
static void fix_unresolved_references(ProcessNode * pnp, void * opaque);


/* Left contains a SetValue*, while right is the result of 'action_range'. */
SvpVec * indexize_svpvec(struct FspTranslator * gp, SvpVec * left, SvpVec * right)
{
    SvpVec * vp;
    SetValue * setvp;
    SetValue * rsetvp;
    RangeValue * rvp;
    ConstValue * cvp;
    ContextsSet * csp; 
    Context * cxp;

    /* type() and 'variable' is the same for all the elements in 
       action_range. */
    switch (right->v[0]->type()) {
	case SymbolValue::Range:
	    rvp = err_if_not_range(right->v[0]);
	    if (rvp->variable != "") {
		/* In this case each element in action_range is in the
		   form 'var:R', where R is a range_id or a range_expr. */
		csp = new ContextsSet;
		csp->frontier = gp->current_contexts().frontier;
		vp = new SvpVec;
		for (int c=0; c<left->v.size(); c++) {
		    setvp = err_if_not_set(left->v[c]);
		    rvp = err_if_not_range(right->v[c]);
		    for (int j=rvp->low; j<=rvp->high; j++) {
			SetValue * new_setvp = new SetValue(*setvp);
			new_setvp->indexize(j);
			/* When a context spread happens, each new_setvp
			   inherits the rank of the generating setvp. */
			new_setvp->rank = setvp->rank;
			/* Append the new SetValue to associate to this
			   context.*/
			vp->v.push_back(new_setvp);
			/* Create a new context (extending the previous
			   one) */
			cxp = extended_context(gp->current_contexts()[c],
				rvp->variable, j);
			csp->append(cxp);
		    }
		}
		cout << "Contexts ramification\n";
		gp->css.update(csp);
		delete left;
		delete right;
		return vp;
	    } else {
		/* In this case each element in action_range is in the
		   form "R", where R is a range_id or a range_expr. */
		for (int c=0; c<left->v.size(); c++) {
		    setvp = err_if_not_set(left->v[c]);
		    rvp = err_if_not_range(right->v[c]);
		    setvp->indexize(rvp->low, rvp->high);
		    /* Rank is inherited. */
		}
		delete right;
		return left;
	    }
	    break;

	case SymbolValue::Const:
	    for (int c=0; c<left->v.size(); c++) {
		setvp = err_if_not_set(left->v[c]);
		cvp = err_if_not_const(right->v[c]);
		setvp->indexize(cvp->value);
		/* Rank is inherited. */
	    }
	    delete right;
	    return left;
	    break;
	case SymbolValue::Set:
	    setvp = err_if_not_set(right->v[0]);
	    if (setvp->variable != "") {
		/* In this case each element in action_range is in the
		   form 'var:R', where R is a set_id or a set_expr. */
		csp = new ContextsSet;
		csp->frontier = gp->current_contexts().frontier;
		/* We need a new SvpVec for a new ContextSet. */
		vp = new SvpVec;
		for (int c=0; c<left->v.size(); c++) {
		    setvp = err_if_not_set(left->v[c]);
		    rsetvp = err_if_not_set(right->v[c]);
		    for (int j=0; j<rsetvp->actions.size(); j++) {
			SetValue * new_setvp = new SetValue(*setvp);
			new_setvp->dotcat(rsetvp->actions[j]);
			/* When a context spread happens, each new_setvp
			   inherits the rank of the generating setvp. */
			new_setvp->rank = setvp->rank;
			/* Append the new SetValue to associate to this
			   context.*/
			vp->v.push_back(new_setvp);
			/* Create a new context (extending the previous
			   one) */
			cxp = extended_context(gp->current_contexts()[c],
				rsetvp->variable, rsetvp->actions[j]);
			/* Append the new Context to the new ContextSet. 
			 */
			csp->append(cxp);
		    }
		}
		cout << "Contexts ramification\n";
		gp->css.update(csp);
		delete left;
		delete right;
		return vp;
	    } else {
		for (int c=0; c<left->v.size(); c++) {
		    setvp = err_if_not_set(left->v[c]);
		    rsetvp = err_if_not_set(right->v[c]);
		    /* Create a new SetValue that combines setvp and
		       rsetvp. No context ramification happens here. */
		    setvp->indexize(*rsetvp);
		    /* Rank is inherited. */
		}
		delete right;
		return left;
	    }
	    break;

	default:
	    cerr << "I should not reach this point.\n";
	    assert(0);
	    exit(1);
    }
}


/* A global data structure containing everything the translator needs. */
struct FspTranslator tr;



#define DEBUG
#ifdef DEBUG
#define PROX(x) cout<<"PROX: ";x;cout<<"\n"
#define PROP(x) cout<<"PROP:==============================================================\n      " << x << "\n"
#else
#define PROP(x)
#define PROX(x)
#endif


void yyerror(const char *s);
%}


// define the "terminal symbol" token types I'm going to use (in CAPS
// by convention), and associate each with a field of the union:

%token IF THEN ELSE
%token WHEN
%token CONST RANGE SET
%token ARROW
%token DOTDOT
%token END STOP ERROR
%token PROPERTY PROGRESS MENU
%token FORALL
%token SHARING
%token OR AND EQUAL NOTEQUAL LOE GOE LSHIFT RSHIFT
%token <int_value> INTEGER
%token <float_value> FLOAT
%token <string_ptr> UpperCaseID
%token <string_ptr> LowerCaseID

%type <svpvec_ptr> simple_expression
%type <svpvec_ptr> base_expr expression unary_expr multiplicative_expr
%type <svpvec_ptr>  additive_expr shift_expr relational_expr equality_expr
%type <svpvec_ptr> bitand_expr bitxor_expr bitor_expr and_expr or_expr

%type <string_ptr> variable constant_id range_id set_id range_or_set_id
%type <string_ptr> parameter_id process_id progress_id menu_id
%type <string_ptr> const_range_set_parameter_id

%type <svpvec_ptr> set set_elements set_expr
%type <svpvec_ptr> action_labels
%type <svpvec_ptr> alphabet_extension_OPT
%type <svpvec_ptr> action_range guard_OPT
%type <svpvec_ptr> range_expr
%type <svpvec_ptr> index_ranges_OPT index_ranges indices_OPT indices

%type <pvec_ptr> choice action_prefix prefix_actions
%type <pvec_ptr> process_body local_process local_process_defs 
%type <pvec_ptr> local_process_def
%type <pvec_ptr> sequential_composition base_local_process else_OPT
%type <pvec_ptr> seq_process_list process_ref

/* Generate a Generic LR parser, instead of a standard LR parser. We need
   this to resolve conflicts at runtime. */
%glr-parser

/* Name of the parser implementation file. */
%output "parser.cpp"

/* Create a parser header file. This is needed because we define yylex()
   in another source file (the FLEX generated scanner source file). */
%defines

/* Write an extra output file containing verbose descriptions of the parser
    states and what is done for each type of lookahead token in that state
%verbose
*/



%%

/* Start symbol: an arbitrary long list of fsp_definitions */
fsp_description:
    fsp_definition
    | fsp_description fsp_definition
    ;

/* All the possible type of fsp_definitions */
fsp_definition:
    constant_def
    | range_def
    | set_def
    | property_def
    | progress_def
    | menu_def
    | process_def
    | composite_def
    ;


/* Action labels TODO: fix */
action_labels:
    LowerCaseID {
	SvpVec * vp;
	SetValue * setvp; 

	vp = new SvpVec;
	vp->shared = false;
	for (int c=0; c<tr.current_contexts().size(); c++) {
	    setvp = new SetValue;
	    *setvp += *$1;
	    /* We assign a different rank to each setvp in vp (and so one
	       per context). Note that this assignment happens before
	       parsing anithing else in the composite action. For istance,
	       if we have to parse 'a[i:R][S][i+1]', this action is executed
	       as soon as 'a' is parsed, and so before parsing the rest
	       of the composite action. */
	    setvp->rank = c;
	    vp->v.push_back(setvp);
	}
	delete $1;
	$$ = vp;
    }
    | set {
	$$ = $1;
    }
    | action_labels '.' LowerCaseID {
	SetValue * setvp;

	assert($1->v.size() == tr.current_contexts().size());
	for (int c=0; c<$1->v.size(); c++) {
	    setvp = err_if_not_set($1->v[c]);
	    setvp->dotcat(*$3);
	    /* Rank is inherited. */
	}
	delete $3;
	$$ = $1;
    }
    | action_labels '.' set {
	assert($1->v.size() == $3->v.size() &&
		    $1->v.size() == tr.current_contexts().size());
	SetValue * setvp;
	SetValue * rsetvp;
	for (int c=0; c<$1->v.size(); c++) {
	    setvp = err_if_not_set($1->v[c]);
	    rsetvp = err_if_not_set($3->v[c]);
	    /* Combine setvp with rsetvp. No context ramification
	       happens here. */
	    setvp->dotcat(*rsetvp);
	    /* Rank is inherited. */
	}
	delete $3;
	$$ = $1;
    }
    | action_labels '[' action_range ']' {

	assert($1->v.size() == $3->v.size() &&
		$1->v.size() == tr.current_contexts().size());
	$$ = indexize_svpvec(&tr, $1, $3);
    }
    ;

set:
    set_id {
	SvpVec * vp = new SvpVec;
	SymbolValue * svp;
	SetValue * setvp;
	if (!tr.identifiers.lookup(*$1, svp)) {
	    stringstream errstream;
errstream << "set " << *$1 << " undeclared";
	    semantic_error(errstream);
	}
	delete $1;
	setvp = err_if_not_set(svp);
	svp = svp->clone();
	vp->shared = true;
	for (int c=0; c<tr.current_contexts().size(); c++)
	    vp->v.push_back(svp);
	$$ = vp;
    }
    | set_expr {
	$$ = $1;
    }
    ;

set_expr:
    '{' set_elements '}' {
	$2->print();
	$$ = $2;
    }
    ;

action_range:
    expression {
	$$ = $1;
    }
    | range_expr {
	$$ = $1;
    }
    | set_expr {
	$$ = $1;
    }
    | variable ':' range_or_set_id {
	SvpVec * vp = new SvpVec;
	SymbolValue * svp;

	if (!tr.identifiers.lookup(*$3, svp)) {
	    stringstream errstream;
errstream << "range/set " << *$3 << " undeclared";
	    semantic_error(errstream);
	}
	svp = svp->clone();

	/* Pass the variable name to the upper levels.*/
	svp->setVariable(*$1);
	delete $1;
	vp->shared = true;
	for (int c=0; c<tr.current_contexts().size(); c++)
	    vp->v.push_back(svp);
	$$ = vp;
    }
    | variable ':' range_expr {
	RangeValue * rvp;
	for (int i=0; i<$3->v.size(); i++) {
	    rvp = err_if_not_range($3->v[i]);
	    /* Pass the variable to the upper levels.*/
	    rvp->setVariable(*$1);
	}
	delete $1;
	$$ = $3;
    }
    | variable ':' set_expr {
	SetValue * setvp;
	for (int i=0; i<$3->v.size(); i++) {
	    setvp = err_if_not_set($3->v[i]);
	    /* Pass the variable to the upper levels.*/
	    setvp->setVariable(*$1);
	}
	delete $1;
	$$ = $3;
    }
    ;

range_expr:
    expression DOTDOT expression {
	RangeValue * rvp;
	ConstValue * cvp;
	SvpVec * vp = new SvpVec;

	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    rvp = new RangeValue;
	    cvp = err_if_not_const($1->v[i]);
	    rvp->low = cvp->value;
	    cvp = err_if_not_const($3->v[i]);
	    rvp->high = cvp->value;
	    vp->v.push_back(rvp);
	}
	delete $1;
	delete $3;
	$$ = vp;
    }
    ;


/* Const, Range, Set */
constant_def:
    CONST constant_id '=' simple_expression {
	if ($4->v.size() != 1) {
	    // XXX this should never happen, because we get an "undeclared"
	    stringstream errstream;
errstream << "Illegal use of variables in const declaration";
	    semantic_error(errstream);
	}
	ConstValue* cvp = err_if_not_const($4->v[0]);
	$4->detach(0);
	if (!tr.identifiers.insert(*$2, cvp)) {
	    stringstream errstream;
errstream << "const " << *$2 << " declared twice";
	    semantic_error(errstream);
	}
	delete $4;
	delete $2;
    };

range_def:
    RANGE range_id '=' simple_expression DOTDOT simple_expression {
	if ($4->v.size() != 1 || $6->v.size() != 1) {
	    // XXX this should never happen, because we get an "undeclared"
	    stringstream errstream;
errstream << "Illegal use of variables in range declaration";
	    semantic_error(errstream);
	}
	RangeValue* rvp = new RangeValue;
	ConstValue * cvp1 = err_if_not_const($4->v[0]);
	ConstValue * cvp2 = err_if_not_const($6->v[0]);
	rvp->low = cvp1->value;
	rvp->high = cvp2->value;
	//delete cvp1; // done below
	//delete cvp2;
	delete $4;
	delete $6;
	if (!tr.identifiers.insert(*$2, rvp)) {
	    stringstream errstream;
errstream << "range " << *$2 << " declared twice";
	    semantic_error(errstream);
	}
	delete $2;
    };

set_def:
    SET set_id '=' '{' set_elements '}' {
	// TODO convert from SvpVec to SetValue
	if (!tr.identifiers.insert(*$2, $5->v[0])) {
	    stringstream errstream;
errstream << "set " << *$2 << " declared twice";
	    semantic_error(errstream);
	}
	$5->detach(0);
	delete $5;
	delete $2;
    };

set_elements:
    action_labels {
	$$ = $1;
    }
    | set_elements ',' action_labels {
	assert($1->v.size() == $3->v.size());
	for (int c=0; c<$1->v.size(); c++) {
	    SetValue * setvp = err_if_not_set($1->v[c]);
	    SetValue * rsetvp = err_if_not_set($3->v[c]);
	    *setvp += *rsetvp;
	}
	delete $3;
	$$ = $1;
    }
    ;


/* Processes */
process_def:
    process_id param_OPT {
	/* Parameters have been pushed inside the 'param_OPT' rule.
	   A cleaner approach would be to get a list of parameters from
	   the rule and push the parameters into the 'tr.identifiers' table
	   in this action. */
	tr.init_fakenode();
    }
    '=' process_body alphabet_extension_OPT relabel_OPT hiding_OPT '.' {
	PROP("process_def --> ... process_body ...");
	PROX(cout<<*$1<<" = "; $5->v[0]->print(&tr.actions));

	ProcessBase * pbp = $5->v[0];
	SymbolValue * svp;
	ProcessValue * pvp = NULL;

	assert($5->v.size() == 1);
	if (pbp->unresolved()) {
	    tr.aliases.insert(*$1, 
		    ((UnresolvedProcess* )pbp)->reference);
	    tr.aliases.print();
	} 
	tr.aliases.fill_process_table(tr.local_processes);
	if (pbp->unresolved()) {
	    if(!tr.local_processes.lookup(*$1, svp)) {
		stringstream errstream;
errstream << "process " << *$1 << " undeclared";
		semantic_error(errstream);
	    }
	    pvp = err_if_not_process(svp);
	} else {
	    /* Insert a new ProcessValue in the symbol table, attaching the
	       process_body to it. */
	    pvp = new ProcessValue;
	    pvp->pnp = err_if_not_procnode(pbp);
	    if (!tr.local_processes.insert(*$1, pvp)) {
		stringstream errstream;
errstream << "process " << *$1 << " declared twice";
		semantic_error(errstream);
	    }
	    cout << "Process " << *$1 << " defined (" << pvp->pnp << ")\n";
	}

	PROX(cout << "<<<<<<<<<<<<<<<<<<<<<<<<<<<< Process " << *$1 << " defined >>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n");

	/* Try to resolve all the undefined references into this process. */
	struct ProcessVisitObject f;
	f.vfp = &fix_unresolved_references;
	f.opaque = &tr.actions;
	pvp->pnp->visit(f);

	PROX(cout<<"resolved: "; pvp->pnp->print(&tr.actions));

	/* Convert the collection of ProcessNodes in an Lts object. */
	Lts lts(pvp->pnp, &tr.actions);

	/* Now we can free the graph pointed by pvp->pnp. */
	freeProcessNodeGraph(pvp->pnp);

	/* Extend the alphabet if is the case. */
	if ($6) {
	    SetValue * setvp;
	    if ($6->v.size() != 1) {
		stringstream errstream;
errstream << "Multiset alphabet extension";
		semantic_error(errstream);
	    }
	    setvp = err_if_not_set($6->v[0]);
	    for (int i=0; i<setvp->actions.size(); i++)
		lts.updateAlphabet(tr.actions.insert(setvp->actions[i]));
		delete setvp;
	}

	/* Remove process parameters from the tr.identifiers. */
	for (int i=0; i<tr.parameters.size(); i++) {
	    tr.identifiers.remove(*(tr.parameters[i]));
	    delete tr.parameters[i];
	}
	tr.parameters.clear();

	/* Clear 'tr.local_processes' and 'tr.aliases'. */
	tr.local_processes.clear();
	tr.aliases.clear();

	lts.print();
	lts.graphvizOutput((*$1 += ".gv").c_str());
	delete $1;

	// TODO implement everything is OPT
    }
    ;

process_body:
    local_process {
	$$ = $1;
    }
    | local_process ',' local_process_defs {
	$$ = $1;
    }
    ;

local_process_defs:
    local_process_def {
	$$ = $1;
    }
    | local_process_defs ',' local_process_def {
	$$ = $1;
    }
    ;

local_process_def:
    process_id {
	/* The following nonterminal 'index_ranges_OPT' may result
	   in contexts ramifications, and so tr.css.update() must be called. We
	   therefore push a clone of the current ContextsSet, which is the
	   initial empty one, so that the initial one is not modified. */
	tr.css.push_clone();
    } index_ranges_OPT '=' {
	cout << "index_ranges_OPT:\n";
	$3->print();
	tr.init_fakenode();
    } local_process {
	ProcessValue * pvp;
	SetValue * setvp;
	string procname;

	for (int c=0; c<$3->v.size(); c++) {
	    setvp = err_if_not_set($3->v[c]);
	    for (int j=0; j<setvp->actions.size(); j++) {
		procname = *$1 + setvp->actions[j];
		if ($6->v[c]->unresolved()) {
		    tr.aliases.insert(procname,
			((UnresolvedProcess* )$6->v[c])->reference);
		    tr.aliases.print();
		} else {
		    pvp = new ProcessValue;
		    pvp->pnp = err_if_not_procnode($6->v[c]);
		    if (j)
			pvp->pnp = pvp->pnp->clone();
		    if (!tr.local_processes.insert(procname, pvp)) {
			stringstream errstream;
errstream << "process " << procname
			    << " declared twice";
			semantic_error(errstream);
		    }
		    cout << "Process " << procname << " defined (" << pvp->pnp << ")\n";
		}
	    }
	}
	/* Pop out the cloned (maybe dirty) ContextsState, so that we
	   correctly restore the empty initial state. */
	tr.css.pop();
	delete $1;
	delete $3;
	$$ = $6;
    }
    ;

alphabet_extension_OPT:
    {
	$$ = NULL;
    }
    | '+' set {
	$$ = $2;
    }
    ;

local_process:
    base_local_process {
	$$ = $1;
    }
    | sequential_composition {
/*
	$$ = $1;
*/
    }
    | IF expression THEN {
	ConstValue * cvp;

	/* Prepare a clone of the current ContextsSet to rule out those
	   contexts that makes 'expression' false. In this way when executing
	   the translation of the following 'local_process', only the
	   selected contexts are expanded, while the others are not
	   translated (e.tr. are filtered out). */
	tr.css.push_clone();
	for (int c=0; c<tr.current_contexts().size(); c++) {
	    cvp = err_if_not_const($2->v[c]);
	    if (!cvp->value) {
		tr.current_contexts().rule_out(c);
	    }
	}
    } local_process {
	ConstValue * cvp;

	tr.css.pop();
	tr.css.push_clone();
	/* Clean the previous clone and prepare another one for the else
	   branch, in the same way descripted above. */
	for (int c=0; c<tr.current_contexts().size(); c++) {
	    cvp = err_if_not_const($2->v[c]);
	    if (cvp->value)
		tr.current_contexts().rule_out(c);
	}
    } else_OPT {
	Pvec * pvec = new Pvec;
	ConstValue * cvp;

	tr.css.pop();
	/* Clean the previous cloned ContextsSet and fill the return vector
	   *pvec, depending on the truth values contained in $2. */
	for (int c=0; c<tr.current_contexts().size(); c++) {
	    cvp = err_if_not_const($2->v[c]);
	    if (cvp->value)
		pvec->v.push_back($5->v[c]);
	    else if ($7)
		pvec->v.push_back($7->v[c]);
	    else
		/* If $7 == NULL there is no else branch, and so we insert
		   a STOP state. */
		pvec->v.push_back(new ProcessNode);
	}
	delete $2;
	$$ = pvec;
    }
    | '(' {
	/* Replicate the CSS stack top so that it can be used by 'choice'. */
	tr.css.push_clone();
	PROX(cout << "CSS height (push) " << tr.css.stack.size());
	PROX(tr.current_contexts().print());
    } choice ')' {
	//$3->print();
	$$ = $3;
    }
    ;

else_OPT:
    {
	$$ = NULL;
    }
    | ELSE local_process {
	$$ = $2;
    }

base_local_process:
    END {
	Pvec * pvec = new Pvec;
	ProcessNode * pnp = new ProcessNode(ProcessNode::End);

	for (int c=0; c<tr.current_contexts().size(); c++)
	    pvec->v.push_back(pnp);
	$$ = pvec;
    }
    | STOP {
	Pvec * pvec = new Pvec;
	ProcessNode * pnp = new ProcessNode;

	for (int c=0; c<tr.current_contexts().size(); c++)
	    pvec->v.push_back(pnp);
	$$ = pvec;
    }
    | ERROR {
	Pvec * pvec = new Pvec;
	ProcessNode * pnp = new ProcessNode(ProcessNode::Error);

	for (int c=0; c<tr.current_contexts().size(); c++)
	    pvec->v.push_back(pnp);
	$$ = pvec;
    }
    | process_id indices_OPT {
	SymbolValue * svp;
	Pvec * pvec = new Pvec;
	ProcessBase * pbp;
	SetValue * setvp;
	string name;

	assert($2->v.size() == tr.current_contexts().size());
	for (int c=0; c<$2->v.size(); c++) {
	    setvp = err_if_not_set($2->v[c]);
	    assert(setvp->actions.size() == 1);
	    name = *$1 + setvp->actions[0];
	    cout << "looking for " << name << endl;
	    /* If the process referenced is already defined, return it.
	       Otherwise return a new UnresolvedProcess object, so that the
	       upper level sees that 'name' is unresolved. */
	    if (tr.local_processes.lookup(name, svp))
		pbp = ((ProcessValue *)svp)->pnp;
	    else
		pbp = new UnresolvedProcess(name);
	    pvec->v.push_back(pbp);
	}

	$$ = pvec;
    }
    ;

choice:
    action_prefix {
	/* Pop (and destroy) the replicated top and everything above. */
	tr.css.pop();
	$$ = $1;
	PROX(cout << "CSS height = (pop) " << tr.css.stack.size());
    }
    | choice '|' {
	/* Replicate the CSS stack top so that it can be used by
	   'action_prefix'. */
	tr.css.push_clone();
	PROX(cout << "CSS height (push) " << tr.css.stack.size());
	PROX(tr.current_contexts().print());
    } action_prefix {
	/* Pop (and destroy) the replicated top and everything above. */
	tr.css.pop();
	cout << "CSS height = (pop) " << tr.css.stack.size() << "\n";
	$$ = $1;
    }
    ;

action_prefix:
    guard_OPT {
	PROP("action_prefix --> guard_OPT (cont)");
	ConstValue * cvp;
	if ($1) {
	    for (int c=0; c<tr.current_contexts().size(); c++) {
		cvp = err_if_not_const($1->v[c]);
		if (!cvp->value)
		    tr.current_contexts().rule_out(c);
	    }
	    cout << "filtered\n"; tr.current_contexts().print();
	}
    } prefix_actions ARROW local_process {
	PROP("action_prefix --> (cont) prefix_actions -> local_process");
	/* If $5 is an istance of ConnectedProcess, it means that its first 
	   nodes have already been connected to the frontier of $3 in the
	   lower level rule 'prefix_actions'. Therefore there is nothing to
	   be done here. */

	for (int i=0; i<tr.current_contexts().frontier.size(); i++) {
	    ProcessNode * pnp = tr.current_contexts().frontier[i].pnp;
	    int child = tr.current_contexts().frontier[i].child;
	    int rank = pnp->children[child].rank;
	    if ($5->v[rank]->connected()) continue;
	    if (!$5->v[rank]->unresolved())
		/* If $5 is not an unresolved reference, we connect the
		   current frontier (e.tr. the frontier of $3) to the process
		   $5. */
		pnp->children[child].dest =
		    err_if_not_procnode($5->v[rank]);
	    else
		/* If $5 is an unresolved reference, we scan the current
		   frontier recording the reference itself, so that this
		   reference will be fixed by the upper levels. */
		pnp->children[child].unresolved_reference =
		    ((UnresolvedProcess *)$5->v[rank])->reference;
	}

	//$3->print();
	$$ = $3;
	PROX(tr.current_contexts().print(); cout<<"$$ = "; tr.print_fakenode_forest());
    }
    ;

prefix_actions:
    action_labels {
	PROP("prefix_actions --> action_labels");
	PROX(cout<<"$1 = "; $1->print());

	/* Note that this is executed (obviously) after $1 has been
	   parsed, and so after all the context ramifications implied by
	   the latter have been executed. */

	/* If the frontier is not empty, it means that, although at the
	   beginning of an 'action_prefix', we are in the middle of
	   a process definition (e.tr. "P=(a->b->(c->..." or
	   "P=(a-b->(c->d->P|e->..."). In this case we have consider all
	   the edges in the frontier (e.tr. the edge "b").
	 */
	vector<FrontierElement> new_frontier;
	Pvec * pvec = new Pvec;
	ProcessNode * pnp;
	ProcessNode * npnp;
	ProcessEdge e;
	SetValue * setvp;
	int rank;
	int child;
	struct FrontierElement fe;
	bool zero;
	int max_rank = 0;

	zero = true;
	for (int i=0; i<tr.current_contexts().frontier.size(); i++)
	    if (tr.current_contexts().frontier[i].pnp != &tr.fakenode) {
		zero = false;
		break;
	    }

	for (int i=0; i<tr.current_contexts().frontier.size(); i++) {
	    pnp = tr.current_contexts().frontier[i].pnp;
	    child = tr.current_contexts().frontier[i].child;
	    /* If the edge i is NULL-pointing, it means that we are
	       at the beginning of a choice construct (e.tr.
	       "P=(a->b->(c->..."): We then create a node for that
	       edge (in our example we create a node for "b"). If the
	       edge is not NULL-pointing, it means that we are in 
	       the middle of a choice construct (e.tr.
	       "P=(a-b->(c->d->P|e->...") and so the node has already
	       been created when processing the first choice element.
	       There is no need to create anythintr.
	     */
	    if (pnp->children[child].dest == NULL)
		pnp->children[child].dest = 
		    new ProcessNode(ProcessNode::Normal);
	    npnp = pnp->children[child].dest;

	    /* Once we get the node pointed by the edge i (npnp), we
	       have to combine that edge with the sets in $1. We
	       have a combination when the rank of the edge is equal
	       to the rank of the set. When we find a combination, we
	       add to npnp a NULL-pointing edge for each element in 
	       the matching set.
	     */
	    rank = pnp->children[child].rank;
	    if (rank > max_rank) max_rank = rank;
	    for (int c=0; c<$1->v.size(); c++) {
		if (tr.current_contexts().is_ruled_out(c)) continue;
		setvp = err_if_not_set($1->v[c]);
		if (setvp->rank == rank) {
		    for (int k=0; k<setvp->actions.size(); k++) {
			e.action = tr.actions.insert(setvp->actions[k]);
			e.dest = NULL;
			/* We set e.rank to the index in the SvpVec
			   $1 of setvp, so that this edge will
			   combine with actions in the next level
			   that have the same rank. */
			e.rank = c;
			npnp->children.push_back(e);
			/* We add the edge to the new frontier, so that
			   it will be used for combination with the next
			   level actions. */
			fe.pnp = npnp;
			fe.child = npnp->children.size() - 1;
			new_frontier.push_back(fe);
		    }
		}
	    }
	}
	/* Update the frontier. */
	tr.current_contexts().frontier = new_frontier;
	if (zero) {
	    assert(max_rank+1 == tr.fakenode.children.size());
	    for (int c=0; c<max_rank+1; c++)
		pvec->v.push_back(tr.fakenode.children[c].dest);
	}
	else {
	    /* Tell the upper level rule (action_prefix) that the beginning
	       of this prefix_actions has already been connected, and so
	       'local_process' results already connected (see above). */
	    ProcessBase * pbp = new ConnectedProcess();
	    for (int c=0; c<max_rank+1; c++)
		pvec->v.push_back(pbp);
	}
	$$ = pvec;
	PROX(tr.current_contexts().print(); cout<<"$$ = \n"; tr.print_fakenode_forest());
    }
    | prefix_actions ARROW action_labels {
	PROP("prefix_actions --> prefix_actions -> action_labels");
	PROX(cout<<"$3 = "; $3->print());
	ProcessNode * pnp;
	ProcessNode * npnp;
	ProcessEdge e;
	SetValue * setvp;
	int rank;
	int child;
	struct FrontierElement fe;
	vector<FrontierElement> new_frontier;

	/* Here we are in the middle of a 'prefix_actions' 
	   (e.tr. "...->b->c->d->.."), and so we have to connect each edge in
	   the frontier with the action sets in $3 (e.tr. we have a frontier
	   that contains a NULL-pointing edge "c" and $3={{d}}).
	*/
	for (int i=0; i<tr.current_contexts().frontier.size(); i++) {
	    pnp = tr.current_contexts().frontier[i].pnp;
	    child = tr.current_contexts().frontier[i].child;
	    /* Here we have to do the same combination descripted above,
	       but only if the edge in the frontier is NULL-pointing and
	       it has not an unresolved reference associated. If the
	       edge is not NULL-pointing, it means that we are in a 
	       situation like this "...->a->(b->c->...|d->e->...)". In
	       this case pnp is the node which has an edge "b" and an 
	       edge "d", and $3={{e}}: Therefore we don't have to consider
	       the edge "b" for combinations, since it has already been used
	       when processing the previous choice element. We only have to
	       consider "d". If an edge has an unresolved reference, 
	       it means that we are in a situation like this
	       "..a->(b->P|d->e->...)": this case is very similar to the
	       previous one, but here the edge "b" is NULL-pointing,
	       only because of the unresolved reference P: considering it
	       for combinations would be an error. */
	    if (pnp->children[child].dest == NULL &&
		    pnp->children[child].unresolved_reference == "") {
		pnp->children[child].dest = 
		    new ProcessNode(ProcessNode::Normal);
		npnp = pnp->children[child].dest;
		rank = pnp->children[child].rank;
		for (int c=0; c<$3->v.size(); c++) {
		    if (tr.current_contexts().is_ruled_out(c)) continue;
		    setvp = err_if_not_set($3->v[c]);
		    if (setvp->rank == rank) {
			for (int k=0; k<setvp->actions.size(); k++) {
			    e.action = tr.actions.insert(setvp->actions[k]);
			    e.dest = NULL;
			    /* We set e.rank to the index in the SvpVec
			       $3, so that this edge will combine with
			       actions in the next level that have the
			       same rank. */
			    e.rank = c;
			    npnp->children.push_back(e);
			    fe.pnp = npnp;
			    fe.child = npnp->children.size() - 1;
			    new_frontier.push_back(fe);
			}
		    }
		}
	    }
	}
	tr.current_contexts().frontier = new_frontier;
	/* Note that $1 is not used in this action, because we use the
	   frontier stored in tr.current_contexts(). As a result, $1 is
	   the result of the previous action (and so a ProcessNode* or a
	   ConnectedProcess*. */
	$$ = $1;
	PROX(tr.current_contexts().print(); cout<<"$$ = \n"; tr.print_fakenode_forest());
    }
    ;

guard_OPT:
    {
	$$ = NULL;
    }
    | WHEN expression {
	for (int i=0; i<$2->v.size(); i++)
	    err_if_not_const($2->v[i]);
	$$ = $2;
    }
    ;

indices_OPT:
    {
	SvpVec * vp = new SvpVec;
	SetValue * setvp;

	for (int c=0; c<tr.current_contexts().size(); c++) {    
	    setvp = new SetValue;
	    setvp->actions.push_back("");
	    vp->v.push_back(setvp);
	}
	$$ = vp;
    }
    | indices
    ;

indices:
    '[' expression ']' {
	SvpVec * vp = new SvpVec;
	SetValue * setvp;
	ConstValue * cvp;

	assert($2->v.size() == tr.current_contexts().size());
	for (int c=0; c<$2->v.size(); c++) {
	    setvp = new SetValue;
	    cvp = err_if_not_const($2->v[c]);
	    setvp->actions.push_back("[" + int2string(cvp->value) + "]");
	    vp->v.push_back(setvp);
	}
	delete $2;
	$$ = vp;
    }
    | indices '[' expression ']' {
	SetValue * setvp;
	ConstValue * cvp;

	assert($1->v.size() == $3->v.size());
	for (int c=0; c<$3->v.size(); c++) {
	    setvp = err_if_not_set($1->v[c]);
	    cvp = err_if_not_const($3->v[c]);
	    setvp->indexize(cvp->value);
	}
	delete $3;
	$$ = $1;
    }
    ;

index_ranges_OPT:
    {
	SvpVec * vp = new SvpVec;
	SetValue * setvp = new SetValue;
	
	assert(tr.current_contexts().size() == 1);
	setvp->actions.push_back("");
	vp->v.push_back(setvp);
	$$ = vp;
    }
    | index_ranges
    ;

index_ranges:
    '[' action_range ']' {
	SvpVec * vp;
	SetValue * setvp;
	ConstValue * cvp;

	/* Here we are sure to have only the empty context. */
	assert(tr.current_contexts().size() == 1 && $2->v.size() == 1);

	if ($2->v[0]->type() == SymbolValue::Set) {
	    stringstream errstream;
errstream << "Unexpected set";
	    semantic_error(errstream);
	}
	setvp = new SetValue;
	setvp->actions.push_back("");
	vp = new SvpVec;
	vp->v.push_back(setvp);
	$$ = indexize_svpvec(&tr, vp, $2);

    }
    | index_ranges '[' action_range ']' {
	assert($3->v.size() == $1->v.size());
	if ($3->v[0]->type() == SymbolValue::Set) {
	    stringstream errstream;
errstream << "Unexpected set";
	    semantic_error(errstream);
	}
	$$ = indexize_svpvec(&tr, $1, $3);
    }
    ;

sequential_composition:
    seq_process_list ';' base_local_process {
	$$ = $1;
    }
    ;

seq_process_list:
    process_ref {
	$$ = $1;
    }
    | seq_process_list ';' process_ref {
	$$ = $1;
    }
    ;

process_ref:
    process_id argument_OPT {
	//TODO
    }
    ;

argument_OPT:
    |'(' argument_list ')' {
    }
    ;

argument_list:
    expression {
    }
    | argument_list ',' expression {
    }
    ;


/* Composite process */
composite_def:
    OR process_id param_OPT '=' composite_body priority_OPT hiding_OPT '.'
    ;

composite_body:
    prefix_label_OPT process_ref relabel_OPT
    | prefix_label_OPT '(' parallel_composition ')' relabel_OPT
    | FORALL ranges composite_body
    | IF expression THEN composite_body
    | IF expression THEN composite_body ELSE composite_body
    ;

parallel_composition:
    composite_body
    | parallel_composition OR composite_body
    ;

prefix_label_OPT:
    | prefix_label
    ;

// TODO add the third option
prefix_label:
    action_labels ':' 
    | action_labels SHARING
    ;

priority_OPT:
    | priority;

priority:
    RSHIFT set
    | LSHIFT set
    ;

ranges_OPT:
    | ranges;

ranges:
    '[' action_range ']'
    | ranges '[' action_range ']'
    ;


/* Parameters */
param_OPT:
    | param {
    }
    ;

param:
    '(' parameter_list ')' {
    }
    ;

parameter_list:
    parameter {
    }
    | parameter_list ',' parameter {
    }
    ;

parameter:
    parameter_id '=' expression {
	if ($3->v.size() != 1) {
	    // XXX this should never happen..
	    stringstream errstream;
errstream << "Illegal use of variables in parameter declaration";
	    semantic_error(errstream);
	}
	ConstValue * cvp = err_if_not_const($3->v[0]);
	$3->detach(0);
	SymbolValue * svp = cvp;
	if (!tr.identifiers.insert(*$1, svp)) {
	    stringstream errstream;
errstream << "identifier " << *$1 << " already declared";
	    semantic_error(errstream);
	}
	tr.parameters.push_back($1);
	delete $3;
    }	
    ;


/* Re-Labeling and Hiding */
relabel_OPT:
    | relabel
    ;

relabel:
    '/' '{' relabel_defs '}'
    ;

relabel_defs:
    relabel_def
    | relabel_defs ',' relabel_def
    ;

relabel_def:
    action_labels '/' action_labels
    | FORALL index_ranges '{' relabel_defs '}'
    ;

hiding_OPT:
    | hiding
    ;

hiding:
    '\\' set
    | '@' set
    ;


/* Property, Progress and Menu */
// TODO second form of progress (if S then C)
property_def:
    PROPERTY process_def
    ;

progress_def:
    PROGRESS progress_id ranges_OPT '=' set
    ;

menu_def:
    MENU menu_id '=' set
    ;


/* An expression or a simple_expression: standard operators and priorities. */
expression:
    or_expr {
	$$ = $1;
    }
    ;

simple_expression:
    additive_expr {
	$$ = $1;
    }
    ;

or_expr:
    and_expr
    | or_expr OR and_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = vpl->value || vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

and_expr:
    bitor_expr
    | and_expr AND bitor_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = vpl->value && vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

bitor_expr:
    bitxor_expr
    | bitor_expr '|' bitxor_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value |= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

bitxor_expr:
    bitand_expr
    | bitxor_expr '^' bitand_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value ^= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

bitand_expr:
    equality_expr
    | bitand_expr '&' equality_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value &= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

equality_expr:
    relational_expr
    | equality_expr EQUAL relational_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value == vpr->value);
	}
	delete $3;
	$$ = $1;
    }
    | equality_expr NOTEQUAL relational_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value != vpr->value);
	}
	delete $3;
	$$ = $1;
    }
    ;

relational_expr:
    shift_expr
    | relational_expr '<' shift_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value < vpr->value);
	}
	delete $3;
	$$ = $1;
    }
    | relational_expr '>' shift_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value > vpr->value);
	}
	delete $3;
	$$ = $1;
    }
    | relational_expr LOE shift_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value <= vpr->value);
	}
	delete $3;
	$$ = $1;
    }
    | relational_expr GOE shift_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value >= vpr->value);
	}
	delete $3;
	$$ = $1;
    }
    ;

shift_expr:
    additive_expr
    | shift_expr LSHIFT additive_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value <<= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    | shift_expr RSHIFT additive_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value >>= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

additive_expr:
    multiplicative_expr
    | additive_expr '+' multiplicative_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value += vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    | additive_expr '-' multiplicative_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value -= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

multiplicative_expr:
    unary_expr
    | multiplicative_expr '*' unary_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value *= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    | multiplicative_expr '/' unary_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value /= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    | multiplicative_expr '%' unary_expr {
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = vpl->value % vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

unary_expr:
    base_expr
    | '+' base_expr {
	for (int i=0; i<$2->v.size(); i++) {
	    err_if_not_const($2->v[i]);
	}
	$$ = $2;
    }
    | '-' base_expr {
	SvpVec * vp = new SvpVec;
	ConstValue * cvp;
	for (int i=0; i<$2->v.size(); i++) {
	    cvp = err_if_not_const($2->v[i]);
	    cvp->value *= -1;;
	    vp->v.push_back(cvp);
	}
	$$ = vp;
    }
    | '!' base_expr {
	SvpVec * vp = new SvpVec;
	ConstValue * cvp;
	for (int i=0; i<$2->v.size(); i++) {
	    cvp = err_if_not_const($2->v[i]);
	    cvp->value = !(cvp->value);
	    vp->v.push_back(cvp);
	}
	$$ = vp;
    }
    ;

/* TODO: complete base_expr */
base_expr:
    INTEGER {
	SvpVec * vp;
	ConstValue * cvp;

	/* Return a ConstValue* for each context (in non shared mode). */
	vp = new SvpVec;
	vp->shared = false;
	for (int c=0; c<tr.current_contexts().size(); c++) {
	    cvp = new ConstValue;
	    cvp->value = $1;
	    vp->v.push_back(cvp);
	}
	$$ = vp;
    }
    | variable {
	/* Return a ConstValue* for each context (in non shared mode). */
	SvpVec * vp;

	vp = new SvpVec;
	vp->shared = false;
	for (int c=0; c<tr.current_contexts().size(); c++) {
	    SymbolValue * svp;
	    if (!(tr.current_contexts()[c]->lookup(*$1, svp))) {
		stringstream errstream;
errstream << "variable " << *$1 << " undeclared\n";
		semantic_error(errstream);
	    }
	    svp = svp->clone();
	    vp->v.push_back(svp);
	}
	delete $1;
	$$ = vp;
    }
    | const_range_set_parameter_id {
	SymbolValue * svp;
	SvpVec * vp; 
	
	/* Lookup the identifier and clone the associated object. */
	if (!tr.identifiers.lookup(*$1, svp)) {
	    stringstream errstream;
errstream << "const/range/set/parameter " << *$1
			    << " undeclared";
	    semantic_error(errstream);
	}
	delete $1;

	/* Return a ConstValue* for each context (in non shared mode). */
	vp = new SvpVec;
	vp->shared = false;
	for (int c=0; c<tr.current_contexts().size(); c++)
	    vp->v.push_back(svp->clone());
	$$ = vp;
    }
    | '(' expression ')' { $$ = $2; }
    ;

/* Some useful alias for LowerCaseID and UpperCaseID. */
variable: LowerCaseID;
constant_id: UpperCaseID;
range_id: UpperCaseID;
set_id: UpperCaseID;
range_or_set_id: set_id;
const_range_set_parameter_id: set_id;
parameter_id: UpperCaseID;
process_id: UpperCaseID;
progress_id: UpperCaseID;
menu_id: UpperCaseID;

%%

static void fix_unresolved_references(ProcessNode * pnp, void * opaque)
{
    ActionsTable * atp = (ActionsTable *)opaque;

    for (int i=0; i<pnp->children.size(); i++) {
	ProcessEdge& e = pnp->children[i];
	SymbolValue * svp;
	if (e.dest == NULL) {
	    cout << "Unref " << pnp << ": " << tr.actions.reverse[e.action]
		<< " -> " << e.unresolved_reference << "\n";				
	    if (!tr.local_processes.lookup(e.unresolved_reference, svp)) {
		stringstream errstream;
errstream << "Local process " << pnp << ": "
		    << e.unresolved_reference << " undeclared\n";
		semantic_error(errstream);
	    }
	    e.dest = ((ProcessValue *)svp)->pnp;
	}
    }
}

const char * ex = "P=(a->b->P).";

int parser()
{
    const char * input_name = "input";

    /* Initialize shared data structures: A stack containing a single
       ContextsSet. This set contains a single empty Context and an
       empty frontier. */
    ContextsSet * csp = new ContextsSet;
    csp->append(new Context);
    tr.css.push(csp);

    /*
    ScannerFileBuffer sfb(input_name);
    sfb.select();
    yyparse();

    ScannerStringBuffer ssb(ex,12);
    ssb.select();
    yyparse(); */

    InputBuffersStack ibs;

    ibs.push(input_name);
    yyparse();
    ibs.pop();

    return 0;
}


void yyerror(const char *s) {
    cout << "Syntax error:" << s << endl;
    // might as well halt now:
    exit(-1);
}

