%{
#include <cstdio>
#include <iostream>
#include <sstream>
#include <cstdlib>
#include <set>
#include <vector>

using namespace std;

/* Stuff from flex that bison needs to know about. */
extern int yylex();
extern FILE * yyin;

/* Symbols tables. */
#include "strings_table.hpp"
//TODO define these tables here.. move from fspc.cpp
extern struct SymbolsTable identifiers;
extern struct SymbolsTable processes;

/* Main actions table. */
struct ActionsTable actions("Global actions table");

#include "lts.hpp"


#include "context.hpp"

/* Stack of contexts sets. */
struct ContextsSetStack {
    vector<ContextsSet *> stack;

    ContextsSetStack() { }
    void push(ContextsSet * ctxset) {
	stack.push_back(ctxset);
    }
    void push_clone() {
	stack.push_back(new ContextsSet(*stack.back()));
    }
    void update(ContextsSet * ctxset) {
	delete stack.back();
	stack.back() = ctxset;
    }
    void pop() {
	delete stack.back();
	stack.pop_back();
    }
    ContextsSet& top() { return *(stack.back()); }
};

struct ContextsSetStack css;
#define current_contexts css.top()


/* Storage for a list of parameters identifiers to remove from the 
   identifiers table when a process definition has been completed. */
vector<string *> parameters;


/* Fix unresolved ProcessNode references due to cyclic processes. */
void fix_unresolved_references(ProcessNode * pnp, void * opaque);


/* For semantic errors */
stringstream errstream;

void semantic_error()
{
    cout << "Semantic error: " << errstream.str() << "\n";
    exit(-1);
}

/* Helper function used to get a ConstValue* from a SymbolValue*. If the
   object pointed is not a constant, a semantic error is issued. */
inline ConstValue* err_if_not_const(SymbolValue * svp)
{
    if (svp->type() != SymbolValue::Const) {
	errstream << "Const expected";
	semantic_error();
    }

    return (ConstValue *)svp;
}

inline RangeValue* err_if_not_range(SymbolValue * svp)
{
    if (svp->type() != SymbolValue::Range) {
	errstream << "Range expected";
	semantic_error();
    }

    return (RangeValue *)svp;
}

inline SetValue* err_if_not_set(SymbolValue * svp)
{
    if (svp->type() != SymbolValue::Set) {
	errstream << "Set expected";
	semantic_error();
    }

    return (SetValue *)svp;
}


void yyerror(const char *s);
%}

// Bison fundamentally works by asking flex to get the next token, which it
// returns as an object of type "YYSTYPE".  But tokens could be of any
// arbitrary data type!  So we deal with that in Bison by defining a C union
// holding each of the types of tokens that Flex could return, and have Bison
// use that union instead of "int" for the definition of "YYSTYPE":
%union {
    int int_value;
    float float_value;
    std::string *string_ptr;
    class StringsSet *sset_ptr;
    class SymbolValue *sv_ptr;
    class RangeValue *rv_ptr;
    class Lts *lv_ptr;
    class ProcessNode * pn_ptr;
    class ProcessBase * pb_ptr;
    struct SvpVec * svpvec_ptr;
}

// define the "terminal symbol" token types I'm going to use (in CAPS
// by convention), and associate each with a field of the union:


%token IF THEN ELSE
%token WHEN
%token CONST RANGE SET
%token ARROW
%token DOTDOT
%token END STOP ERROR
%token PROPERTY PROGRESS MENU
%token FORALL
%token SHARING
%token OR AND EQUAL NOTEQUAL LOE GOE LSHIFT RSHIFT
%token <int_value> INTEGER
%token <float_value> FLOAT
%token <string_ptr> UpperCaseID
%token <string_ptr> LowerCaseID

%type <svpvec_ptr> simple_expression
%type <svpvec_ptr> base_expr expression unary_expr multiplicative_expr
%type <svpvec_ptr>  additive_expr shift_expr relational_expr equality_expr
%type <svpvec_ptr> bitand_expr bitxor_expr bitor_expr and_expr or_expr

%type <string_ptr> variable constant_id range_id set_id range_or_set_id
%type <string_ptr> parameter_id process_id progress_id menu_id
%type <string_ptr> const_range_set_parameter_id

%type <svpvec_ptr> set set_elements set_expr
%type <svpvec_ptr> action_labels
%type <svpvec_ptr> alphabet_extension_OPT
%type <svpvec_ptr> action_range guard_OPT
%type <svpvec_ptr> range_expr
%type <pn_ptr> choice action_prefix prefix_actions
%type <pb_ptr> process_body local_process local_process_defs local_process_def
%type <pb_ptr> sequential_composition base_local_process
%type <pb_ptr> seq_process_list process_ref

%glr-parser

%%

/* Start symbol: an arbitrary long list of fsp_definitions */
fsp_description:
    fsp_definition
    | fsp_description fsp_definition
    ;

/* All the possible type of fsp_definitions */
fsp_definition:
    constant_def
    | range_def
    | set_def
    | property_def
    | progress_def
    | menu_def
    | process_def
    | composite_def
    ;


/* Action labels TODO: fix */
action_labels:
    LowerCaseID {
	SvpVec * vp;
	SetValue * setvp; 

	vp = new SvpVec;
	vp->shared = false;
	for (int c=0; c<current_contexts.size(); c++) {
	    setvp = new SetValue;
	    *setvp += *$1;
	    /* We assign a different rank to each setvp in vp (and so one
	       per context). Note that this assignment happens before
	       parsing anithing else in the composite action. For istance,
	       if we have to parse 'a[i:R][S][i+1]', this action is executed
	       as soon as 'a' is parsed, and so before parsing the rest
	       of the composite action. */
	    setvp->rank = c;
	    vp->v.push_back(setvp);
	}
	delete $1;
	$$ = vp;
	cout << "<<B>> als\n";
	vp->print();
    }
    | set
    | action_labels '.' LowerCaseID {
	if ($1->v.size() != current_contexts.size()) {cout<<"FATAL 561\n";exit(-1);}
	SetValue * setvp;
	for (int c=0; c<$1->v.size(); c++) {
	    setvp = err_if_not_set($1->v[c]);
	    setvp->dotcat(*$3);
	    /* Rank is inherited. */
	}
	delete $3;
	$$ = $1;
    }
    | action_labels '.' set {
	if ($1->v.size() != $3->v.size() ||
		$1->v.size() != current_contexts.size())
	     {cout<<"FATAL 412 \n"; exit(-1);}
	cout << "<<B>> als.set\n";
	SetValue * setvp;
	SetValue * rsetvp;
	for (int c=0; c<$1->v.size(); c++) {
	    setvp = err_if_not_set($1->v[c]);
	    rsetvp = err_if_not_set($3->v[c]);
	    /* Combine setvp with rsetvp. No context ramification
	       happens here. */
	    setvp->dotcat(*rsetvp);
	    /* Rank is inherited. */
	}
	delete $3;
	$$ = $1;
	$$->print();
    }
    | action_labels '[' action_range ']' {
	cout << "<<B>> als[action_range]\n";
	if ($1->v.size() != $3->v.size() ||
		$1->v.size() != current_contexts.size())
	     {cout<<"FATAL 215 \n"; exit(-1);}
	SvpVec * vp;
	SetValue * setvp;
	SetValue * rsetvp;
	RangeValue * rvp;
	ConstValue * cvp;
	ContextsSet * csp; 
	Context * cxp;
	/* type() and 'variable' is the same for all the elements in 
	   'action_range'. */
	switch ($3->v[0]->type()) {
	    case SymbolValue::Range:
		rvp = err_if_not_range($3->v[0]);
		if (rvp->variable != "") {
		    /* In this case each element in action_range is in the
		       form 'var:R', where R is a range_id or a range_expr. */
		    csp = new ContextsSet;
		    vp = new SvpVec;
		    for (int c=0; c<$1->v.size(); c++) {
			setvp = err_if_not_set($1->v[c]);
			rvp = err_if_not_range($3->v[c]);
			for (int j=rvp->low; j<=rvp->high; j++) {
			    SetValue * new_setvp = new SetValue(*setvp);
			    for (int k=0; k<new_setvp->actions.size(); k++)
				new_setvp->actions[k] += "[" +
				    int2string(j) + "]";
			    /* When a context spread happens, each new_setvp
			       inherits the rank of the generating setvp. */
			    new_setvp->rank = setvp->rank;
			    /* Create a new context (extending the previous
			       one) and append the new SetValue to associate
			       to this context.*/
			    vp->v.push_back(new_setvp);
			    cxp = current_contexts[c];
			    cxp = new Context(*cxp);
			    if (!cxp->insert(rvp->variable, j)) {
				errstream << "Variable " << rvp->variable
				    << " declared twice\n";
				semantic_error();
			    }
			    csp->append(cxp);
			}
		    }
		    cout << "Contexts ramification\n";
		    css.update(csp);
		    current_contexts.print();
		    delete $1;
		    delete $3;
		    $$ = vp;
		} else {
		    /* In this case each element in action_range is in the
		       form "R", where R is a range_id or a range_expr. */
		    for (int c=0; c<$1->v.size(); c++) {
			setvp = err_if_not_set($1->v[c]);
			rvp = err_if_not_range($3->v[c]);
			setvp->indexize(rvp->low, rvp->high);
			/* Rank is inherited. */
		    }
		    delete $3;
		    $$ = $1;
		}
		break;

	    case SymbolValue::Const:
		for (int c=0; c<$1->v.size(); c++) {
		    setvp = err_if_not_set($1->v[c]);
		    cvp = err_if_not_const($3->v[c]);
		    setvp->indexize(cvp->value);
		    /* Rank is inherited. */
		}
		delete $3;
		$$ = $1;
		break;
	    case SymbolValue::Set:
		setvp = err_if_not_set($3->v[0]);
		if (setvp->variable != "") {
		    /* In this case each element in action_range is in the
		       form 'var:R', where R is a set_id or a set_expr. */
		    csp = new ContextsSet;
		    /* We need a new SvpVec for a new ContextSet. */
		    vp = new SvpVec;
		    for (int c=0; c<$1->v.size(); c++) {
			setvp = err_if_not_set($1->v[c]);
			rsetvp = err_if_not_set($3->v[c]);
			for (int j=0; j<rsetvp->actions.size(); j++) {
			    SetValue * new_setvp = new SetValue(*setvp);
			    for (int k=0; k<new_setvp->actions.size(); k++)
				new_setvp->actions[k] += "." +
				    rsetvp->actions[j];
			    /* When a context spread happens, each new_setvp
			       inherits the rank of the generating setvp. */
			    new_setvp->rank = setvp->rank;
			    /* Create a new context (extending the previous
			       one) and append the new SetValue to associate
			       to this context.*/
			    vp->v.push_back(new_setvp);
			    cxp = current_contexts[c];
			    cxp = new Context(*cxp);
			    if (!cxp->insert(rsetvp->variable,
				    rsetvp->actions[j])) {
				errstream << "Variable " << rsetvp->variable
				    << " declared twice\n";
				semantic_error();
			    }
			    /* Append the new Context to the new ContextSet. 
				*/
			    csp->append(cxp);
			}
		    }
		    cout << "Contexts ramification\n";
		    css.update(csp);
		    current_contexts.print();
		    delete $1;
		    delete $3;
		    $$ = vp;
		} else {
		    for (int c=0; c<$1->v.size(); c++) {
			setvp = err_if_not_set($1->v[c]);
			rsetvp = err_if_not_set($3->v[c]);
			/* Create a new SetValue that combines setvp and
			   rsetvp. No context ramification happens here. */
			setvp->indexize(*rsetvp);
			/* Rank is inherited. */
		    }
		    delete $3;
		    $$ = $1;
		}
		break;

	    default:
		cout << "WHAT!?!?!?\n";
		exit(-1);
		break;
	}
	$$->print();
    }
    ;

set:
    set_id {
	SvpVec * vp = new SvpVec;
	SymbolValue * svp;
	SetValue * setvp;
	if (!identifiers.lookup(*$1, svp)) {
	    errstream << "set " << *$1 << " undeclared";
	    semantic_error();
	}
	delete $1;
	setvp = err_if_not_set(svp);
	svp = svp->clone();
	vp->shared = true;
	for (int c=0; c<current_contexts.size(); c++)
	    vp->v.push_back(svp);
	$$ = vp;
    }
    | set_expr
    ;

set_expr:
    '{' set_elements '}' {
	cout << "Set expression:\n";
	$2->print();
	$$ = $2;
    }
    ;

action_range:
    expression
    | range_expr
    | set_expr
    | variable ':' range_or_set_id {
	cout << "Variable definition: " << *$1 << ":" << *$3 << "\n";
	SvpVec * vp = new SvpVec;
	SymbolValue * svp;
	if (!identifiers.lookup(*$3, svp)) {
	    errstream << "range/set " << *$3 << " undeclared";
	    semantic_error();
	}
	svp = svp->clone();

	/* Pass the variable name to the upper levels.*/
	svp->setVariable(*$1);
	delete $1;
	vp->shared = true;
	for (int c=0; c<current_contexts.size(); c++)
	    vp->v.push_back(svp);
	$$ = vp;
	
    }
    | variable ':' range_expr {
	RangeValue * rvp;
	for (int i=0; i<$3->v.size(); i++) {
	    rvp = err_if_not_range($3->v[i]);
	    /* Pass the variable to the upper levels.*/
	    rvp->setVariable(*$1);
	}
	delete $1;
	$$ = $3;
    }
    | variable ':' set_expr {
	SetValue * setvp;
	for (int i=0; i<$3->v.size(); i++) {
	    setvp = err_if_not_set($3->v[i]);
	    /* Pass the variable to the upper levels.*/
	    setvp->setVariable(*$1);
	}
	delete $1;
	$$ = $3;
    }
    ;

range_expr:
    expression DOTDOT expression {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	RangeValue * rvp;
	ConstValue * cvp;
	SvpVec * vp = new SvpVec;
	for (int i=0; i<$1->v.size(); i++) {
	    rvp = new RangeValue;
	    cvp = err_if_not_const($1->v[i]);
	    rvp->low = cvp->value;
	    cvp = err_if_not_const($3->v[i]);
	    rvp->high = cvp->value;
	    vp->v.push_back(rvp);
	}
	delete $1;
	delete $3;
	$$ = vp;
	$$->print();
    }
    ;


/* Const, Range, Set */
constant_def:
    CONST constant_id '=' simple_expression {
	if ($4->v.size() != 1) {
	    // XXX this should never happen, because we get an "undeclared"
	    errstream << "Illegal use of variables in const declaration";
	    semantic_error();
	}
	ConstValue* cvp = err_if_not_const($4->v[0]);
	$4->detach(0);
	cout << "<<B>> Const " << *$2 << "=" << cvp->value << "\n";
	if (!identifiers.insert(*$2, cvp)) {
	    errstream << "const " << *$2 << " declared twice";
	    semantic_error();
	}
	delete $4;
	delete $2;
    };

range_def:
    RANGE range_id '=' simple_expression DOTDOT simple_expression {
	if ($4->v.size() != 1 || $6->v.size() != 1) {
	    // XXX this should never happen, because we get an "undeclared"
	    errstream << "Illegal use of variables in range declaration";
	    semantic_error();
	}
	RangeValue* rvp = new RangeValue;
	ConstValue * cvp1 = err_if_not_const($4->v[0]);
	ConstValue * cvp2 = err_if_not_const($6->v[0]);
	cout << "<<B>> Range " << *$2 << cvp1->value << cvp2->value << "\n";
	rvp->low = cvp1->value;
	rvp->high = cvp2->value;
	//delete cvp1; // done below
	//delete cvp2;
	delete $4;
	delete $6;
	if (!identifiers.insert(*$2, rvp)) {
	    errstream << "range " << *$2 << " declared twice";
	    semantic_error();
	}
	delete $2;
    };

set_def:
    SET set_id '=' '{' set_elements '}' {
	cout << "<<B>> Set\n"; $5->print();
	// TODO convert from SvpVec to SetValue
	if (!identifiers.insert(*$2, $5->v[0])) {
	    errstream << "set " << *$2 << " declared twice";
	    semantic_error();
	}
	$5->detach(0);
	delete $5;
	delete $2;
    };

set_elements:
    action_labels {
	$$ = $1;
    }
    | set_elements ',' action_labels {
	cout << "<<B>> set_el als\n";
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL 719\n";exit(-1);}
	for (int c=0; c<$1->v.size(); c++) {
	    SetValue * setvp = err_if_not_set($1->v[c]);
	    SetValue * rsetvp = err_if_not_set($3->v[c]);
	    *setvp += *rsetvp;
	}
	delete $3;
	$$ = $1;
    }
    ;


/* Processes */
process_def:
    process_id param_OPT {
	/* Parameters have been pushed inside the 'param_OPT' rule.
	   A cleaner approach would be to get a list of parameters from
	   the rule and push the parameters into the 'identifiers' table
	   in this action. */
	;
    }
    '=' process_body alphabet_extension_OPT relabel_OPT hiding_OPT '.' {
	if ($5->unresolved()) {
	    errstream << "Local process " << 
		    ((UnresolvedProcess * )$5)->reference << " undeclared\n";
	    semantic_error();
	}

	/* Insert a new ProcessValue in the symbol table, attaching the
	   process_body to it. */
	ProcessValue * pvp = new ProcessValue;
	cout << "Process " << *$1 << " defined\n";
	if (!processes.insert(*$1, pvp)) {
	    errstream << "process " << *$1 << " declared twice";
	    semantic_error();
	}
	pvp->pnp = (ProcessNode *)$5;

	/* Try to resolve all the undefined references into this process. */
	struct ProcessVisitObject f;
	f.vfp = &fix_unresolved_references;
	f.opaque = &actions;
	pvp->pnp->visit(f);

	pvp->pnp->print(&actions);

	/* Convert the collection of ProcessNodes in an Lts object. */
	Lts lts(pvp->pnp, &actions);

	/* Now we can free the graph pointed by pvp->pnp. */
	freeProcessNodeGraph(pvp->pnp);

	/* Extend the alphabet if is the case. */
    /*
	if ($6) {
	    for (int i=0; i<$6->strings.size(); i++)
		lts.updateAlphabet(actions.insert($6->strings[i]));
		delete $6;
	} */

	/* Remove process parameters from the identifiers. */
	for (int i=0; i<parameters.size(); i++) {
	    identifiers.remove(*(parameters[i]));
	    delete parameters[i];
	}
	parameters.clear();

	lts.print();

	lts.graphvizOutput((*$1 += ".gv").c_str());
	delete $1;

	// TODO implement everything is OPT
    }
    ;

process_body:
    local_process
    | local_process ',' local_process_defs {
	// TODO compose
	$$ = $1;
    }
    ;

local_process_defs:
    local_process_def
    | local_process_defs ',' local_process_def {
	// TODO compose
	$$ = $1;
    }
    ;

local_process_def:
    process_id index_ranges_OPT '=' local_process {
	// TODO index_ranges_OPT
	$$ = $4;
    }
    ;

alphabet_extension_OPT:
    {
	$$ = NULL;
    }
    | '+' set {
	$$ = $2;
    }
    ;

local_process:
    base_local_process
    | sequential_composition
    | IF expression THEN local_process {
	ConstValue * cvp;
	if ($2->v.size() > 1) {cout < "TODO IF THEN\n"; exit(-1);} //TODO
	cvp = err_if_not_const($2->v[0]);
	if (cvp->value)
	    $$ = $4;
	else {
	    /* If the condition is not true, return a STOP process. */
	    if ($4->unresolved())
		delete $4;
	    else
		freeProcessNodeGraph((ProcessNode *)$4);
	    $$ = new ProcessNode;
	}
	delete $2;
    }
    | IF expression THEN local_process ELSE local_process {
	ConstValue * cvp; 
	ProcessBase * pbp;
	if ($2->v.size() > 1) {cout < "TODO IF THEN\n"; exit(-1);} //TODO
	cvp = err_if_not_const($2->v[0]);
	if (cvp->value) {
	    pbp = $6;
	    $$ = $4;
	} else {
	    pbp = $4;
	    $$ = $6;
	}
	if (pbp->unresolved())
	    delete pbp;
	else
	    freeProcessNodeGraph((ProcessNode *)pbp);
	delete $2;
    }
    | '(' {
	/* Replicate the CSS stack top so that it can be used by 'choice'. */
	css.push_clone();
	cout << "CSS height (push) " << css.stack.size() << "\n";
    } choice ')' {
	//$3->print();
	/* Pop (and destroy) the replicated top. */
	css.pop();
	cout << "CSS height = (pop) " << css.stack.size() << "\n";
	$$ = $3;
    }
    ;

base_local_process:
    END {
	$$ = new ProcessNode(ProcessNode::End);
    }
    | STOP {
	$$ = new ProcessNode;
    }
    | ERROR {
	$$ = new ProcessNode(ProcessNode::Error);
    }
    | process_id indices_OPT {
	//TODO implement indices_OPT
	SymbolValue * svp;
	/* If the process referenced is already defined, return it.
	   Otherwise return a new UnresolvedProcess object, so that the
	   upper level sees that *$1 is unresolved. */
	if (processes.lookup(*$1, svp))
	    $$ = ((ProcessValue *)svp)->pnp;
	else
	    $$ = new UnresolvedProcess(*$1);
    }
    ;

choice:
    action_prefix
    | choice '|' action_prefix {
	cout << "Choice\n";
	/* Merge $1 head and $3 head. Don't care about frontier_shortcut
	   merging, since we will not need them anymore. */
	for (int i=0; i<$3->children.size(); i++)
	    $1->children.push_back($3->children[i]);
	/* We must delete only the ProcessNode pointed by $, but not the
	   whole graph! */
	delete $3;
	//$1->print();
	$$ = $1;
    }
    ;

action_prefix:
    guard_OPT prefix_actions ARROW local_process {
	// TODO guard_OPT

	if (!($4->unresolved())) {
	    /* If $4 is not an unresolved reference, we connect the frontier 
	       of $2 to the process $4. */
	    for (int i=0; i<$2->frontier_shortcut.size(); i++) {
		ProcessNode * pnp = $2->frontier_shortcut[i];
		for (int j=0; j<pnp->children.size(); j++)
		    pnp->children[j].dest = (ProcessNode *)$4;
	    }
	} else {
	    /* If $4 is an unresolved reference, we scan the frontier of $2
	       recording the reference itself, so that this reference will
	       be fixed by the upper levels. */
	    string reference = ((UnresolvedProcess *)$4)->reference;
	    for (int i=0; i<$2->frontier_shortcut.size(); i++) {
		ProcessNode * pnp = $2->frontier_shortcut[i];
		for (int j=0; j<pnp->children.size(); j++) {
		    pnp->children[j].unresolved_reference = reference;
		}
	    }
	}
	//$2->print();
	$$ = $2;
    }
    ;

prefix_actions:
    action_labels {
	cout << "Action: "; $1->print();
	ProcessNode * pnp = new ProcessNode;
	ProcessEdge e;
	SetValue * setvp;

	pnp->type = ProcessNode::Normal;
	pnp->frontier_shortcut.push_back(pnp);
	for (int c=0; c<$1->v.size(); c++) {
	    setvp = err_if_not_set($1->v[c]);
	    for (int i=0; i<setvp->actions.size(); i++) {
		e.action = actions.insert(setvp->actions[i]);
		e.dest = NULL;
		e.rank = c;
		pnp->children.push_back(e);
	    }
	}
	delete $1;
	pnp->print(&actions);
	$$ = pnp;
    }
    | prefix_actions ARROW action_labels {
	cout << "Action(->): "; $3->print();
	ProcessNode * pnp;
	ProcessNode * npnp;
	ProcessEdge e;
	SetValue * setvp;
	int rank;
	int c = 0;
	bool change_node;

	vector<ProcessNode*> new_frontier;
	for (int i=0; i<$1->frontier_shortcut.size(); i++) {
	    pnp = $1->frontier_shortcut[i];
	    for (int j=0; j<pnp->children.size(); j++) {
		npnp = pnp->children[j].dest = 
			    new ProcessNode(ProcessNode::Normal);
		rank = pnp->children[j].rank;
		for (int c=0; c<$3->v.size(); c++) {
		    setvp = err_if_not_set($3->v[c]);
		    if (setvp->rank == rank) {
			for (int k=0; k<setvp->actions.size(); k++) {
			    e.action = actions.insert(setvp->actions[k]);
			    e.dest = NULL;
			    e.rank = c;
			    npnp->children.push_back(e);
			}
		    }
		}
		new_frontier.push_back(npnp);
	    }
	}
	$1->frontier_shortcut = new_frontier;
	$$ = $1;
	$1->print(&actions);
    }
    ;

guard_OPT:
    {
	$$ = NULL;
    }
    | WHEN expression {
	ConstValue * cvp;
	for (int i=0; i<$2->v.size(); i++) {
	    err_if_not_const($2->v[i]);
	}
	$$ = $2;
    }
    ;

indices_OPT:
    | indices
    ;

indices:
    '[' expression ']'
    | indices '[' expression ']'
    ;

index_ranges_OPT:
    | index_ranges
    ;

index_ranges:
    '[' expression ']'
    | index_ranges '[' expression ']'
    | '[' action_range ']'
    | index_ranges '[' action_range ']'
    ;

sequential_composition:
    seq_process_list ';' base_local_process
    ;

seq_process_list:
    process_ref
    | seq_process_list ';' process_ref
    ;

process_ref:
    process_id argument_OPT {
	//TODO
	ProcessNode * pnp = new ProcessNode;
	$$ = pnp;
    }
    ;

argument_OPT:
    |'(' argument_list ')'
    ;

argument_list:
    expression
    | argument_list ',' expression
    ;


/* Composite process */
composite_def:
    OR process_id param_OPT '=' composite_body priority_OPT hiding_OPT '.'
    ;

composite_body:
    prefix_label_OPT process_ref relabel_OPT
    | prefix_label_OPT '(' parallel_composition ')' relabel_OPT
    | FORALL ranges composite_body
    | IF expression THEN composite_body
    | IF expression THEN composite_body ELSE composite_body
    ;

parallel_composition:
    composite_body
    | parallel_composition OR composite_body
    ;

prefix_label_OPT:
    | prefix_label
    ;

// TODO add the third option
prefix_label:
    action_labels ':' 
    | action_labels SHARING
    ;

priority_OPT:
    | priority;

priority:
    RSHIFT set
    | LSHIFT set
    ;

ranges_OPT:
    | ranges;

ranges:
    '[' action_range ']'
    | ranges '[' action_range ']'
    ;


/* Parameters */
param_OPT:
    | param
    ;

param:
    '(' parameter_list ')'
    ;

parameter_list:
    parameter
    | parameter_list ',' parameter
    ;

parameter:
    parameter_id '=' expression {
	if ($3->v.size() != 1) {
	    // XXX this should never happen..
	    errstream << "Illegal use of variables in parameter declaration";
	    semantic_error();
	}
	ConstValue * cvp = err_if_not_const($3->v[0]);
	$3->detach(0);
	SymbolValue * svp = cvp;
	if (!identifiers.insert(*$1, svp)) {
	    errstream << "identifier " << *$1 << " already declared";
	    semantic_error();
	}
	parameters.push_back($1);
	delete $3;
    }	
    ;


/* Re-Labeling and Hiding */
relabel_OPT:
    | relabel
    ;

relabel:
    '/' '{' relabel_defs '}'
    ;

relabel_defs:
    relabel_def
    | relabel_defs ',' relabel_def
    ;

relabel_def:
    action_labels '/' action_labels
    | FORALL index_ranges '{' relabel_defs '}'
    ;

hiding_OPT:
    | hiding
    ;

hiding:
    '\\' set
    | '@' set
    ;


/* Property, Progress and Menu */
// TODO second form of progress (if S then C)
property_def:
    PROPERTY process_def
    ;

progress_def:
    PROGRESS progress_id ranges_OPT '=' set
    ;

menu_def:
    MENU menu_id '=' set
    ;


/* An expression or a simple_expression: standard operators and priorities. */
expression:
    or_expr {
	$$ = $1;
	cout << "<<B>> Expression(s): ";
	$1->print();
    }
    ;

simple_expression:
    additive_expr {
	$$ = $1;
	cout << "<<B>> Simple expression(s): ";
	$1->print();
    }
    ;

or_expr:
    and_expr
    | or_expr OR and_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = vpl->value || vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

and_expr:
    bitor_expr
    | and_expr AND bitor_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = vpl->value && vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

bitor_expr:
    bitxor_expr
    | bitor_expr '|' bitxor_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value |= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

bitxor_expr:
    bitand_expr
    | bitxor_expr '^' bitand_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value ^= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

bitand_expr:
    equality_expr
    | bitand_expr '&' equality_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value &= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

equality_expr:
    relational_expr
    | equality_expr EQUAL relational_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value == vpr->value);
	}
	delete $3;
	$$ = $1;
    }
    | equality_expr NOTEQUAL relational_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value != vpr->value);
	}
	delete $3;
	$$ = $1;
    }
    ;

relational_expr:
    shift_expr
    | relational_expr '<' shift_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value < vpr->value);
	}
	delete $3;
	$$ = $1;
    }
    | relational_expr '>' shift_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value > vpr->value);
	}
	delete $3;
	$$ = $1;
    }
    | relational_expr LOE shift_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value <= vpr->value);
	}
	delete $3;
	$$ = $1;
    }
    | relational_expr GOE shift_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value >= vpr->value);
	}
	delete $3;
	$$ = $1;
    }
    ;

shift_expr:
    additive_expr
    | shift_expr LSHIFT additive_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value <<= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    | shift_expr RSHIFT additive_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value >>= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

additive_expr:
    multiplicative_expr
    | additive_expr '+' multiplicative_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value += vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    | additive_expr '-' multiplicative_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value -= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

multiplicative_expr:
    unary_expr
    | multiplicative_expr '*' unary_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value *= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    | multiplicative_expr '/' unary_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value /= vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    | multiplicative_expr '%' unary_expr {
	if ($1->v.size() != $3->v.size()) {cout<<"FATAL\n";exit(1);}
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = vpl->value % vpr->value;
	}
	delete $3;
	$$ = $1;
    }
    ;

unary_expr:
    base_expr
    | '+' base_expr {
	for (int i=0; i<$2->v.size(); i++) {
	    err_if_not_const($2->v[i]);
	}
	$$ = $2;
    }
    | '-' base_expr {
	SvpVec * vp = new SvpVec;
	ConstValue * cvp;
	for (int i=0; i<$2->v.size(); i++) {
	    cvp = err_if_not_const($2->v[i]);
	    cvp->value *= -1;;
	    vp->v.push_back(cvp);
	}
	$$ = vp;
    }
    | '!' base_expr {
	SvpVec * vp = new SvpVec;
	ConstValue * cvp;
	for (int i=0; i<$2->v.size(); i++) {
	    cvp = err_if_not_const($2->v[i]);
	    cvp->value = !(cvp->value);
	    vp->v.push_back(cvp);
	}
	$$ = vp;
    }
    ;

/* TODO: complete base_expr */
base_expr:
    INTEGER {
	SvpVec * vp;
	ConstValue * cvp;

	/* Return a ConstValue* for each context (in non shared mode). */
	vp = new SvpVec;
	vp->shared = false;
	for (int c=0; c<current_contexts.size(); c++) {
	    cvp = new ConstValue;
	    cvp->value = $1;
	    vp->v.push_back(cvp);
	}
	$$ = vp;
    }
    | variable {
	/* Return a ConstValue* for each context (in non shared mode). */
	SvpVec * vp;

	vp = new SvpVec;
	vp->shared = false;
	for (int c=0; c<current_contexts.size(); c++) {
	    SymbolValue * svp;
	    if (!(current_contexts[c]->lookup(*$1, svp))) {
		errstream << "variable " << *$1 << " undeclared\n";
		semantic_error();
	    }
	    svp = svp->clone();
	    vp->v.push_back(svp);
	}
	delete $1;
	$$ = vp;
    }
    | const_range_set_parameter_id {
	SymbolValue * svp;
	SvpVec * vp; 
	
	/* Lookup the identifier and clone the associated object. */
	if (!identifiers.lookup(*$1, svp)) {
	    errstream << "const/range/set/parameter " << *$1
			    << " undeclared";
	    semantic_error();
	}
	delete $1;

	/* Return a ConstValue* for each context (in non shared mode). */
	vp = new SvpVec;
	vp->shared = false;
	for (int c=0; c<current_contexts.size(); c++)
	    vp->v.push_back(svp->clone());
	$$ = vp;
    }
    | '(' expression ')' { $$ = $2; }
    ;

/* Some useful alias for LowerCaseID and UpperCaseID. */
variable: LowerCaseID;
constant_id: UpperCaseID;
range_id: UpperCaseID;
set_id: UpperCaseID;
range_or_set_id: set_id;
const_range_set_parameter_id: set_id;
parameter_id: UpperCaseID;
process_id: UpperCaseID;
progress_id: UpperCaseID;
menu_id: UpperCaseID;

%%

void fix_unresolved_references(ProcessNode * pnp, void * opaque)
{
    ActionsTable * atp = (ActionsTable *)opaque;

    for (int i=0; i<pnp->children.size(); i++) {
	ProcessEdge& e = pnp->children[i];
	SymbolValue * svp;
	if (e.dest == NULL) {
	    cout << "Unref " << pnp << ": " << actions.reverse[e.action]
		<< " -> " << e.unresolved_reference << "\n";				
	    if (!processes.lookup(e.unresolved_reference, svp)) {
		errstream << "Local process " << pnp << ": "
		    << e.unresolved_reference << " undeclared\n";
		semantic_error();
	    }
	    e.dest = ((ProcessValue *)svp)->pnp;
	}
    }
}


int parser()
{
    FILE *fin = fopen("input", "r");
    if (!fin) {
	cout << "I can't open 'input'!" << endl;
	return -1;
    }

    /* Initialize shared data structures: A stack containing a single
       ContextsSet. This set contains a single empty Context. */
    ContextsSet * csp = new ContextsSet;
    csp->append(new Context);
    css.push(csp);


    /* Set flex to read from it instead of defaulting to STDIN. */
    yyin = fin;

    /* Parse through the input until there is no more. */
    do {
	yyparse();
    } while (!feof(yyin));
    
    return 0;
}

void yyerror(const char *s) {
    cout << "Syntax error:" << s << endl;
    // might as well halt now:
    exit(-1);
}

