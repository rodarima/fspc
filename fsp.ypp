/*
 *  fspc parser BISON template
 *
 *  Copyright (C) 2013  Vincenzo Maffione
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


%skeleton "glr.cc" /* -*- C++ -*- */
//%require "2.6.90.8-d4fe"

/* Generate a Generic LR parser, instead of a standard LR parser. We need
   this to resolve conflicts at runtime. */
%glr-parser

/* Create a parser header file. This is needed because we define yylex()
   in another source file (the FLEX generated scanner source file). */
%defines

/* Name of the parser implementation file. */
%output "parser.cpp"

/* Write an extra output file containing verbose descriptions of the parser
    states and what is done for each type of lookahead token in that state
%verbose
*/

%define parser_class_name "FspParser"
%code requires {
#include <string>
class FspDriver;
}
// The parsing context.
%parse-param { FspDriver& driver }
%lex-param   { FspDriver& driver }
%locations
%initial-action
{
  // Initialize the initial location.
  @$.begin.filename = @$.end.filename = &driver.current_file;
}
%debug
%error-verbose

%code top {
#include <cstdio>
#include <iostream>
#include <sstream>
#include <cstdlib>
#include <set>
#include <vector>
#include <string>

using namespace std;

//#define NDEBUG
#include <assert.h>

//#define YYERROR_VERBOSE

#include "driver.hpp"

}


%code requires {
/* This code will be added to the bison-generated header, included
   (among the others) by the FLEX scanner. */

/* Symbols tables. */
#include "symbols_table.hpp"

/* Circular tokens buffer for good error reporting. */
#include "circular_buffer.hpp"
extern class CircularBuffer last_tokens;
}



%{

/* Inline utilities. */
#include "utils.hpp"

/* Context, ContextsSet and ContextsSetStack. */
#include "context.hpp"

/* Definition of the FspTranslator class. */
#include "driver.hpp"

/* Lts definitions and operations. */
#include "lts.hpp"

/* Callbacks. */
#include "callbacks.hpp"

/* Compiler options. */
#include "interface.hpp"

/* Serialization and deserialization support. */
#include "serializer.hpp"

/* Interactive shell */
#include "shell.hpp"


/* A global data structure containing everything the compiler needs. */
//struct FspDriver c;


/* The 'ps' vector and the AA function are necessary in the debug phase in
   order to check that the callback playback systems can work properly. */
vector <void *> ps;
inline void AA(void * barg, int midx, int tot)
{
    assert(barg == ps[ps.size()-1-tot+(midx)]);
}


//#define DEBUG
#ifdef DEBUG
#define PROX(x) cout<<"PROX: ";x;cout<<"\n"
#define PROP(x) cout<<"PROP:==============================================================\n      " << x << "\n"
#else
#define PROP(x)
#define PROX(x)
#endif



/* Called after callback__15() and callback__88() to do common registration
   work. */
void post_process_definition(FspDriver& driver, yy::Lts * lts, const yy::location& loc) {
    string extension;

    /* Clear tr.alphabet_extension, so that the same translator can
       be used for other processes. */
    driver.tr.alphabet_extension.clear();

    /* Remove process parameters from driver.identifiers. */
    for (unsigned int i=0; i<driver.parametric->parameter_names.size(); i++)
	driver.identifiers.remove(driver.parametric->parameter_names[i]);

    /* Restore overridden identifiers. */
    for (unsigned int i=0; i<driver.tr.overridden_names.size(); i++)
	driver.identifiers.insert(driver.tr.overridden_names[i],
		driver.tr.overridden_values[i]);
    driver.tr.overridden_names.clear();
    driver.tr.overridden_values.clear();

    /* Store driver.parametric in parametric_processes. */
    if (!driver.parametric_processes.insert(lts->name, driver.parametric)) {
	stringstream errstream;
	errstream << "Parametric process " << lts->name
	    << " already declared";
	semantic_error(driver, errstream, loc);
    }
    PROX(driver.parametric->print());

    /* Compute the LTS name extension, but don't extend lts->name (pretty
       output). */
    lts_name_extension(driver.parametric->parameter_defaults, extension);

    /* Insert lts into the global 'processes' table. */
    if (!driver.processes.insert(lts->name + extension, lts)) {
	stringstream errstream;
	errstream << "Process " << lts->name << " already declared";
	semantic_error(driver, errstream, loc);
    }

    /* Prepare for the next parametric process. */
    driver.parametric = new ParametricProcess;
    driver.record_mode_on = 0;
}

%}



// Bison fundamentally works by asking flex to get the next token, which it
// returns as an object of type "YYSTYPE".  But tokens could be of any
// arbitrary data type!  So we deal with that in Bison by defining a C union
// holding each of the types of tokens that Flex could return, and have Bison
// use that union instead of "int" for the definition of "YYSTYPE":
%union {
    int int_value;
    float float_value;
    std::string *string_ptr;
    class SymbolValue *sv_ptr;
    struct SvpVec * svpvec_ptr;
    struct Pvec * pvec_ptr;
    class Lts * lts_ptr;
}



/* define the "terminal symbol", token types we're going to use (in CAPS
/ by convention), and associate each with a field of the union: */

%token ENDOF 0 "end of file"
%token IF "if"
%token ELSE "else"
%token THEN "then"
%token WHEN "when"
%token CONST "const"
%token RANGE "range"
%token SET "set"
%token ARROW "->"
%token DOTDOT ".."
%token END "END"
%token STOP "STOP"
%token ERROR "ERROR"
%token PROPERTY "property"
%token PROGRESS "progress"
%token MENU "menu"
%token FORALL "forall"
%token SHARING "::"
%token OR "||"
%token AND "&&"
%token EQUAL "=="
%token NOTEQUAL "!="
%token LOE "<="
%token GOE ">="
%token LSHIFT "<<"
%token RSHIFT ">>"
%token EXPECT_RANGE "$r"
%token EXPECT_SET "$s"
%token <int_value> INTEGER "integer"
%token <string_ptr> UpperCaseID "upper case identifier"
%token <string_ptr> LowerCaseID "lower case identifer"
%token <float_value> FLOAT "float"

%type <svpvec_ptr> expression base_expression

%type <string_ptr> parameter_id process_id progress_id
//%type <string_ptr> menu_id
%type <string_ptr> variable constant_id range_id set_id
%type <string_ptr> const_parameter_id

%type <svpvec_ptr> set set_elements set_expr
%type <svpvec_ptr> action_labels
%type <svpvec_ptr> alphabet_extension_OPT
%type <svpvec_ptr> action_range guard_OPT
%type <svpvec_ptr> range range_expr
%type <svpvec_ptr> index_ranges_OPT index_ranges indices_OPT indices

%type <pvec_ptr> choice action_prefix prefix_actions
%type <pvec_ptr> process_body local_process local_process_defs 
%type <pvec_ptr> local_process_def
%type <pvec_ptr> sequential_composition base_local_process else_OPT

%type <lts_ptr> process_def

%type <pvec_ptr> seq_process_list process_ref_seq
%type <svpvec_ptr> argument_list argument_OPT
%type <svpvec_ptr> process_ref composite_body parallel_composition
%type <svpvec_ptr> composite_else_OPT
%type <svpvec_ptr> labeling_OPT sharing_OPT
%type <svpvec_ptr> relabel_OPT relabel_def relabel_defs braces_relabel_defs
%type <svpvec_ptr> hiding_OPT hiding priority_OPT priority

%printer    { yyoutput << *$$; } <string_ptr>
%destructor { /*delete $$;*/ } <string_ptr>
%printer    { yyoutput << $$; } <int_value>


%%

/* Start symbol: an arbitrary long list of fsp_definitions */
fsp_description:
    fsp_definition
    | fsp_description fsp_definition
    ;

/* All the possible type of fsp_definitions */
fsp_definition:
    constant_def
    | range_def
    | set_def
    | property_def
    | progress_def
    | process_def
    | composite_def
//  | menu_def
    ;


/* Action labels TODO: fix */
action_labels:
    LowerCaseID {
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(
				    new Callback_V_S(&callback__1, *$1));
	$$ = callback__1(driver.tr, $1);
	ps.push_back($$);
    }
    | set {
	AA($1,1,1);
	$$ = $1;
    }
    | action_labels '.' LowerCaseID {
	AA($1,1,1);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(
				new Callback_V_VS(&callback__2, *$3));
	$$ = callback__2(driver.tr, $1, $3);
	
    }
    | action_labels '.' set {
	AA($1,1,2); AA($3,2,2);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_VV(&callback__3));
	$$ = callback__3(driver.tr, $1, $3);
	ps.pop_back();
    }
    | action_labels '[' action_range ']' {
	AA($1,1,2); AA($3,2,2);

	driver.tr.locations[0] = @3;
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_VV(&callback__4));
	$$ = callback__4(driver.tr, $1, $3);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

set:
    EXPECT_SET set_id {
	AA($2,1,1);

	driver.tr.locations[0] = @2;
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(
				    new Callback_V_S(&callback__5, *$2));
	$$ = callback__5(driver.tr, $2);
	ps.pop_back();
	ps.push_back($$);
    }
    | set_expr {
	AA($1,1,1);
	$$ = $1;
    }
    ;

set_expr:
    '{' {
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_pop_push(0, 1));
	Callback_pop_push::exe(driver.tr, 0, 1);
    } set_elements '}' {
	AA($3,1,1);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_V(&callback__75));
	$$ = callback__75(driver.tr, $3);
	$$ = $3;
    }
    ;

range:
    EXPECT_RANGE range_id {
	AA($2,1,1);

	driver.tr.locations[0] = @2;
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(
				    new Callback_V_S(&callback__11, *$2));
	$$ = callback__11(driver.tr, $2);
	ps.pop_back();
	ps.push_back($$);
    }
    | range_expr {
	AA($1,1,1);
	$$ = $1;
    }
    ;

action_range:
    expression {
	AA($1,1,1);
	$$ = $1;
    }
    | range {
	AA($1,1,1);
	$$ = $1;
    }
    | set {
	AA($1, 1, 1);
	$$ = $1;
    }
    | variable ':' range {
	AA($1,1,2); AA($3,2,2);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(
				    new Callback_V_SV(&callback__7, *$1));
	$$ = callback__7(driver.tr, $1, $3);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    | variable ':' set {
	AA($1,1,2); AA($3,2,2);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(
				    new Callback_V_SV(&callback__8, *$1));
	$$ = callback__8(driver.tr, $1, $3);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

range_expr:
    expression DOTDOT expression {
	AA($1,1,2); AA($3,2,2);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_VV(&callback__9));
	$$ = callback__9(driver.tr, $1, $3);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;


/* Const, Range, Set */
constant_def:
    CONST constant_id '=' expression {
	AA($2,1,2); AA($4,2,2);
	assert($4->v.size() == 1);

	ConstValue* cvp = is_const($4->v[0]);
	$4->detach(0);
	if (!driver.identifiers.insert(*$2, cvp)) {
	    stringstream errstream;
	    errstream << "const " << *$2 << " declared twice";
	    semantic_error(driver, errstream, @2);
	}
	delete $4;
	delete $2;
	ps.pop_back();
	ps.pop_back();
    };

range_def:
    RANGE EXPECT_RANGE range_id '=' expression DOTDOT expression {
	AA($3,1,3); AA($5,2,3); AA($7,3,3);
	assert($5->v.size() == 1 && $7->v.size() == 1);

	RangeValue* rvp = new RangeValue;
	ConstValue * cvp1 = is_const($5->v[0]);
	ConstValue * cvp2 = is_const($7->v[0]);
	rvp->low = cvp1->value;
	rvp->high = cvp2->value;
	delete $5;
	delete $7;
	if (!driver.identifiers.insert(*$3, rvp)) {
	    stringstream errstream;
	    errstream << "range " << *$3 << " declared twice";
	    semantic_error(driver, errstream, @3);
	}
	delete $3;
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
    };

set_def:
    SET EXPECT_SET set_id '=' set_expr {
	AA($3,1,2); AA($5,2,2);
	SetValue * setvp;

	assert($5->v.size() == 1);
	setvp = is_set($5->v[0]);
	if (!driver.identifiers.insert(*$3, setvp)) {
	    stringstream errstream;
	    errstream << "set " << *$3 << " declared twice";
	    semantic_error(driver, errstream, @3);
	}
	$5->detach(0);
	delete $5;
	delete $3;
	ps.pop_back();
	ps.pop_back();
    };

set_elements:
    action_labels {
	AA($1,1,1);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_V(&callback__10));
	$$ = callback__10(driver.tr, $1);
	ps.pop_back();
	ps.push_back($$);

    }
    | set_elements ',' {
	AA($1,1,1);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_pop_push(1, 1));
	Callback_pop_push::exe(driver.tr, 1, 1);
    }  action_labels {
	AA($1,1,2); AA($4,2,2);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_VV(&callback__13));
	$$ = callback__13(driver.tr, $1, $4);
	ps.pop_back();
    }
    ;


/* Processes */
process_def:
    process_id param_OPT {
	AA($1,1,1);
	driver.record_mode_on = 1;
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(
				    new Callback_N_S(&callback__14, *$1));
	callback__14(driver.tr, $1);
    }
    '=' process_body alphabet_extension_OPT relabel_OPT hiding_OPT '.' {
	AA($1,1,5); AA($5,2,5); AA($6,3,5); AA($7,4,5); AA($8,5,5);
	string name = *$1;
	yy::Lts * lts;

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(
				    new Callback_P_SPVVV(&callback__15, *$1));
	driver.tr.locations[0] = @1;
	lts = callback__15(driver.tr, $1, $5, $6, $7, $8);

	/* Clear and free 'local_processes'. */
	driver.tr.local_processes.clear();
	/* Clear 'aliases'. */
	driver.tr.aliases.clear();
	/* Free all the nodes allocated by driver.pna, and remove the from
	   the allocator itself. */
	driver.pna.clear();

	post_process_definition(driver, lts, @1);

	PROX(lts->print(); lts->graphvizOutput((name + ".gv").c_str()));
	$$ = lts;

	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
    }
    ;

process_body:
    local_process {
	AA($1,1,1);
	$$ = $1;
    }
    | local_process ',' local_process_defs {
	AA($1,1,2); AA($3,2,2);
	$$ = $1;
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_pop);
	ps.pop_back();
    }
    ;

local_process_defs:
    local_process_def {
	AA($1,1,1);
	$$ = $1;
    }
    | local_process_defs ',' local_process_def {
	AA($1,1,2); AA($3,2,2);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_pop);
	$$ = $1;
	ps.pop_back();
    }
    ;

local_process_def:
    process_id {
	AA($1,1,1);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(
			new Callback_pop_push(0, 1));
	/* The following nonterminal 'index_ranges_OPT' may result
	   in contexts ramifications, and so tr.css.update() must be called.
	   We therefore push a clone of the current ContextsSet, which is 
	   the initial empty one, so that the initial one is not modified. */
	Callback_pop_push::exe(driver.tr, 0, 1);
    } index_ranges_OPT '=' {
	AA($1,1,2); AA($3,2,2);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(
				    new Callback_N_SV(&callback__17, *$1));
	callback__17(driver.tr, $1, $3);
    } local_process {
	AA($1,1,3); AA($3,2,3); AA($6,3,3);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(
				    new Callback_P_SVP(&callback__18, *$1));
	driver.tr.locations[0] = @1;
	$$ = callback__18(driver.tr, $1, $3, $6);
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

alphabet_extension_OPT:
    {
	$$ = NULL;
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_null);
	ps.push_back($$);
    }
    | '+' set {
	AA($2,1,1);
	$$ = $2;
    }
    ;

local_process:
    base_local_process {
	AA($1,1,1);
	$$ = $1;
    }
    | sequential_composition {
	AA($1,1,1);
	$$ = $1;
    }
    | IF expression THEN {
	AA($2,1,1);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_N_V(&callback__19));
	callback__19(driver.tr, $2);
    } local_process {
	AA($2,1,2); AA($5,2,2);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_N_VP(&callback__20));
	callback__20(driver.tr, $2, $5);
    } else_OPT {
	AA($2,1,3); AA($5,2,3); AA($7,3,3);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_P_VPP(&callback__21));
	$$ = callback__21(driver.tr, $2, $5, $7);
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    | '(' {
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_pop_push(0, 1));
	/* Replicate the CSS stack top so that it can be used by 'choice'. */
	Callback_pop_push::exe(driver.tr, 0, 1);
	PROX(cout << "CSS height (push) " << driver.tr.css.stack.size());
	PROX(driver.tr.current_contexts().print());
    } choice ')' {
	AA($3,1,1);
	$$ = $3;
    }
    ;

else_OPT:
    {
	$$ = NULL;
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_null);
	ps.push_back($$);
    }
    | ELSE local_process {
	AA($2,1,1);
	$$ = $2;
    }

base_local_process:
    END {
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_P(&callback__23));
	$$ = callback__23(driver.tr);
	ps.push_back($$);
    }
    | STOP {
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_P(&callback__24));
	$$ = callback__24(driver.tr);
	ps.push_back($$);
    }
    | ERROR {
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_P(&callback__25));
	$$ = callback__25(driver.tr);
	ps.push_back($$);
    }
    | process_id indices_OPT {
	AA($1,1,2); AA($2,2,2);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(
				    new Callback_P_SV(&callback__26, *$1));
	$$ = callback__26(driver.tr, $1, $2);;
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

choice:
    action_prefix {
	AA($1,1,1);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_P_P(&callback__27));
	$$ = callback__27(driver.tr, $1);
	PROX(cout << "CSS height = (pop) " << driver.tr.css.stack.size());
    }
    | choice '|' {
	AA($1,1,1);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_pop_push(0, 1));
	Callback_pop_push::exe(driver.tr, 0, 1);
	PROX(cout << "CSS height (push) " << driver.tr.css.stack.size());
	PROX(driver.tr.current_contexts().print());
    } action_prefix {
	AA($1,1,2); AA($4,2,2);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_P_PP(&callback__29));
	$$ = callback__29(driver.tr, $1, $4);
	PROX(cout << "CSS height = (pop) " << driver.tr.css.stack.size() << "\n");
	ps.pop_back();
    }
    ;

action_prefix:
    guard_OPT {
	AA($1,1,1);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_N_V(&callback__30));
	callback__30(driver.tr, $1);
    } prefix_actions ARROW local_process {
	AA($1,1,3); AA($3,2,3); AA($5,3,3);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_P_VPP(&callback__31));
	$$ = callback__31(driver.tr, $1, $3, $5);
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

prefix_actions:
    action_labels {
	AA($1,1,1);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_P_V(&callback__32));
	$$ = callback__32(driver.tr, $1);
	ps.pop_back();
	ps.push_back($$);
    }
    | prefix_actions ARROW action_labels {
	AA($1,1,2); AA($3,2,2);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_P_PV(&callback__33));
	$$ = callback__33(driver.tr, $1, $3);
	ps.pop_back();
    }
    ;

guard_OPT:
    {
	$$ = NULL;
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_null);
	ps.push_back($$);
    }
    | WHEN expression {
	AA($2,1,1);
	$$ = $2;
    }
    ;

indices_OPT:
    {
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V(&callback__34));
	$$ = callback__34(driver.tr);
	ps.push_back($$);
    }
    | indices
    ;

indices:
    '[' expression ']' {
	AA($2,1,1);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_V(&callback__35));
	$$ = callback__35(driver.tr, $2);
	ps.pop_back();
	ps.push_back($$);
    }
    | indices '[' expression ']' {
	AA($1,1,2); AA($3,2,2);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_VV(&callback__36));
	$$ = callback__36(driver.tr, $1, $3);
	ps.pop_back();
    }
    ;

index_ranges_OPT:
    {
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V(&callback__37));
	$$ = callback__37(driver.tr);
	ps.push_back($$);
    }
    | index_ranges
    ;

index_ranges:
    '[' action_range ']' {
	AA($2,1,1);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_V(&callback__38));
	driver.tr.locations[0] = @2;
	$$ = callback__38(driver.tr, $2);
	ps.pop_back();
	ps.push_back($$);
    }
    | index_ranges '[' action_range ']' {
	AA($1,1,2); AA($3,2,2);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_VV(&callback__39));
	driver.tr.locations[0] = @3;
	$$ = callback__39(driver.tr, $1, $3);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

sequential_composition:
    seq_process_list ';' base_local_process {
	AA($1,1,2); AA($3,2,2);

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_P_PP(&callback__64));
	$$ = callback__64(driver.tr, $1, $3);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

seq_process_list:
    process_ref_seq {
	AA($1,1,1);
	$$ = $1;
    }
    | seq_process_list ';' process_ref_seq {
	AA($1,1,2); AA($3,2,2);

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_P_PP(&callback__65));
	driver.tr.locations[0] = @1;
	$$ = callback__65(driver.tr, $1, $3);
	ps.pop_back();
    }
    ;

process_ref_seq:
    process_id argument_OPT {
	AA($1,1,2); AA($2,2,2);

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(
				    new Callback_P_SV(&callback__66, *$1));
	driver.tr.locations[0] = @1;
	driver.tr.locations[1] = @2;
	$$ = callback__66(driver.tr, $1, $2);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

argument_OPT:
    {
	$$ = NULL;
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_null);
	ps.push_back($$);
    }
    |'(' argument_list ')' {
	@$ = @2;
	AA($2,1,1);
	$$ = $2;
    }
    ;

argument_list:
    expression {
	AA($1,1,1);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_V(&callback__67));
	$$ = callback__67(driver.tr, $1);
	ps.pop_back();
	ps.push_back($$);
    }
    | argument_list ',' expression {
	AA($1,1,2); AA($3,2,2);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_VV(&callback__68));
	$$ = callback__68(driver.tr, $1, $3);
	ps.pop_back();
    }
    ;


/* Composite processes */
composite_def:
    OR process_id param_OPT {
	driver.record_mode_on = 1;
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_pop_push(0, 1));
	Callback_pop_push::exe(driver.tr, 0, 1);
    } '=' composite_body priority_OPT hiding_OPT '.' {
	AA($2,1,4); AA($6,2,4); AA($7,3,4); AA($8,4,4);
	yy::Lts * lts;

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(
			new Callback_V_SVVV(&callback__88, *$2));
	lts = callback__88(driver.tr, $2, $6, $7, $8);

	post_process_definition(driver, lts, @2);

	PROX(cout << "#####################Composite process " << lts->name << " defined#############\n");
	PROX(lts->print(); lts->graphvizOutput((lts->name + ".gv").c_str()));

	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
    }
    ;

composite_body:
    sharing_OPT labeling_OPT process_ref {
	AA($1,1,3); AA($2,2,3); AA($3,3,3);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_np_V_VVV(&callback__76));
	$<svpvec_ptr>$ = callback__76(driver.tr, $1, $2, $3);
	ps.push_back($<svpvec_ptr>$);
    } relabel_OPT {
	AA($1,1,5); AA($2,2,5); AA($3,3,5); 
	AA($<svpvec_ptr>4,4,5); AA($5,5,5);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(
			    new Callback_V_VVVVV(&callback__77));
	$$ = callback__77(driver.tr, $1, $2, $3, $<svpvec_ptr>4, $5);
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    | sharing_OPT labeling_OPT '(' {
	AA($1,1,2); AA($2,2,2);
	/* Save the contexts modified by labeling_OPT. */
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_pop_push(0, 1));
	Callback_pop_push::exe(driver.tr, 0, 1);
    }  parallel_composition ')' {
	AA($1,1,3); AA($2,2,3); AA($5,3,3);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(
			    new Callback_np_V_VVV(&callback__78));
	$<svpvec_ptr>$ = callback__78(driver.tr, $1, $2, $5);
	ps.push_back($<svpvec_ptr>$);
    } relabel_OPT {
	AA($1,1,5); AA($2,2,5); AA($5,3,5);
	AA($<svpvec_ptr>7,4,5); AA($8,5,5);

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(
			    new Callback_V_VVVVV(&callback__79));
	$$ = callback__79(driver.tr, $1, $2, $5, $<svpvec_ptr>7, $8);
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    | FORALL {
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_pop_push(0, 1));
	Callback_pop_push::exe(driver.tr, 0, 1);
    } index_ranges {
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_pop_push(0, 1));
	Callback_pop_push::exe(driver.tr, 0, 1);
    } composite_body {
	/* Here there is an extension to the original grammar, since
	   we should have 'ranges' and not 'index_ranges'. */
	AA($3,1,2); AA($5,2,2);

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_VV(&callback__80));
	$$ = callback__80(driver.tr, $3, $5);
	driver.tr.css.pop();
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    | IF expression THEN composite_body composite_else_OPT {
	AA($2,1,3); AA($4,2,3); AA($5,3,3);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_VVV(&callback__81));
	$$ = callback__81(driver.tr, $2, $4, $5);
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

composite_else_OPT:
    {
	$$ = NULL;
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_null);
	ps.push_back($$);
    }
    | ELSE composite_body {
	AA($2,1,1);
	$$ = $2;
    }
    ;

parallel_composition:
    composite_body {
	AA($1,1,1);

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_V(&callback__82));
	$$ = callback__82(driver.tr, $1);
	ps.pop_back();
	ps.push_back($$);
    }
    | parallel_composition OR {
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_pop_push(1, 1));
	Callback_pop_push::exe(driver.tr, 1, 1);
    } composite_body {
	AA($1,1,2); AA($4,2,2);

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_VV(&callback__83));
	$$ = callback__83(driver.tr, $1, $4);
	ps.pop_back();
    }
    ;

process_ref:
    process_id argument_OPT {
	AA($1,1,2); AA($2,2,2);

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(
				new Callback_V_SV(&callback__84, *$1));
	driver.tr.locations[0] = @1;
	driver.tr.locations[1] = @2;
	$$ = callback__84(driver.tr, $1, $2);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

sharing_OPT:
    {
	$$ = NULL;
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_null);
	ps.push_back($$);
    }
    | action_labels SHARING {
	AA($1,1,1);

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_V(&callback__85));
	$$ = callback__85(driver.tr, $1);
	ps.pop_back();
	ps.push_back($$);
    }
    ;

labeling_OPT:
    {
	$$ = NULL;
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_null);
	ps.push_back($$);
    }
    | action_labels ':' {
	AA($1,1,1);
	assert($1->v.size() == driver.tr.current_contexts().size());
	$$ = $1;
    }
    ;

priority_OPT:
    {
	$$ = NULL;
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_null);
	ps.push_back($$);
    }
    | priority {
	AA($1,1,1);
	$$ = $1;
    }
    ;

priority:
    RSHIFT set {
	AA($2,1,1);

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_V(&callback__86));
	$$ = callback__86(driver.tr, $2);
    }
    | LSHIFT set {
	AA($2,1,1);

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_V(&callback__87));
	$$ = callback__87(driver.tr, $2);
    }
    ;


/* Parameters */
param_OPT:
    | param
    ;

param:
    '(' parameter_list ')' {
    }
    ;

parameter_list:
    parameter {
    }
    | parameter_list ',' parameter {
    }
    ;

parameter:
    parameter_id '=' expression {
	AA($1,1,2); AA($3,2,2);
	if ($3->v.size() != 1) {
	    // XXX this should never happen..
	    stringstream errstream;
	    errstream << "Illegal use of variables in parameter declaration";
	    semantic_error(driver, errstream, @3);
	}
	ConstValue * cvp = is_const($3->v[0]);
	SymbolValue * svp;
	$3->detach(0);
	if (driver.identifiers.lookup(*$1, svp)) {
	    /* Save the overridden identifier. */
	    driver.tr.overridden_names.push_back(*$1);
	    driver.tr.overridden_values.push_back(svp->clone());
	    driver.identifiers.remove(*$1);
	}
	if (!driver.identifiers.insert(*$1, cvp)) {
	    stringstream errstream;
	    errstream << "identifier " << *$1 << " already declared";
	    semantic_error(driver, errstream, @1);
	}

	/* Update driver.parametric-> */
	driver.parametric->parameter_names.push_back(*$1);
	driver.parametric->parameter_defaults.push_back(cvp->value);

	delete $1;
	delete $3;
	ps.pop_back();
	ps.pop_back();
    }	
    ;


/* Re-Labeling and Hiding */
relabel_OPT: {
	$$ = NULL;
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_null);
	ps.push_back($$);
    }
    | '/' braces_relabel_defs {
	AA($2,1,1);
	$$ = $2;
    }
    ;

braces_relabel_defs:
    '{' {
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_pop_push(0, 1));
	Callback_pop_push::exe(driver.tr, 0, 1);
    } relabel_defs '}' {
	AA($3,1,1);
	$$ = $3;
    }
    ;

relabel_defs:
    relabel_def {
	AA($1,1,1);
	$$ = $1;
    }
    | relabel_defs ',' {
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_pop_push(0, 1));
	Callback_pop_push::exe(driver.tr, 0, 1);
    }  relabel_def {
	AA($1,1,2); AA($4,2,2);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_VV(&callback__69));
	$$ = callback__69(driver.tr, $1, $4);
	ps.pop_back();
    }
    ;

relabel_def:
    action_labels '/' {
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_pop_push(1, 1));
	Callback_pop_push::exe(driver.tr, 1, 1);
    }  action_labels {
	AA($1,1,2); AA($4,2,2);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_VV(&callback__70));
	$$ = callback__70(driver.tr, $1, $4);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    | FORALL {
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_pop_push(0, 1));
	Callback_pop_push::exe(driver.tr, 0, 1);
    } index_ranges braces_relabel_defs {
	AA($3,1,2); AA($4,2,2);
	if (driver.record_mode_on) {
	    driver.parametric->record.push_back(new Callback_V_VV(&callback__73));
	}
	$$ = callback__73(driver.tr, $3, $4);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

hiding_OPT:
    {
	$$ = NULL;
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_null);
	ps.push_back($$);
    }
    | hiding {
	AA($1,1,1);
	$$ = $1;
    }
    ;

hiding:
    '\\' set {
	AA($2,1,1);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_V(&callback__71));
	$$ = callback__71(driver.tr, $2);
	ps.pop_back();
	ps.push_back($$);
    }
    | '@' set {
	AA($2,1,1);
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_V(&callback__72));
	$$ = callback__72(driver.tr, $2);
	ps.pop_back();
	ps.push_back($$);
    }
    ;


/* Property, Progress and Menu */
// TODO second form of progress (if S then C)
property_def:
    PROPERTY process_def {
	if ($2->isDeterministic()) {
	    $2->property();
	} else {
	    stringstream errstream;
	    errstream << "cannot apply the property keyword since "
		<< $2->name << " is a non-deterministic process";
	    semantic_error(driver, errstream, @2);
	}
	PROX($2->print(); $2->graphvizOutput(($2->name + ".gv").c_str()));
    }
    ;

progress_def:
    PROGRESS progress_id {
	driver.tr.css.push_clone();
    } index_ranges_OPT '=' set {
	AA($2,1,3); AA($4,2,3); AA($6,3,3);
	SetValue * setvp;
	SetValue * irp;
	string name;

	assert($4->v.size() == $6->v.size());
	for (unsigned int k=0; k<$6->v.size(); k++) {
	    irp = is_set($4->v[k]);
	    setvp = is_set($6->v[k]);
	    /* We discard irp->actions[i] for i>0. */
	    name = *$2 + irp->actions[0]; 
	    
	    if (!driver.progresses.insert(name, setvp)) {
		stringstream errstream;
		errstream << "progress " << name << " declared twice";
		semantic_error(driver, errstream, @2);
	    }
	}
	driver.tr.css.pop();
	delete $2;
	delete $4;

	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
    }
    ;

/*
menu_def:
    MENU menu_id '=' set
    ;
*/

%left OR;
%left AND;
%left '|';
%left '^';
%left '&';
%left EQUAL NOTEQUAL;
%left '<' '>' LOE GOE;
%left LSHIFT RSHIFT;
%left '+' '-';
%left '*' '/' '%';


/* An expression: standard operators and priorities. */
expression:
    '(' expression ')' {
	AA($2,1,1);

	$$ = $2;
    }
    | expression OR expression {
	AA($1,1,2); AA($3,2,2);

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_VV(&callback__41));
	$$ = callback__41(driver.tr, $1, $3);
	ps.pop_back();
    }
    | expression AND expression {
	AA($1,1,2); AA($3,2,2);

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_VV(&callback__42));
	$$ = callback__42(driver.tr, $1, $3);
	ps.pop_back();
    }
    | expression '|' expression {
	AA($1,1,2); AA($3,2,2);

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_VV(&callback__43));
	$$ = callback__43(driver.tr, $1, $3);
	ps.pop_back();
    }
    | expression '^' expression {
	AA($1,1,2); AA($3,2,2);

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_VV(&callback__44));
	$$ = callback__44(driver.tr, $1, $3);
	ps.pop_back();
    }
    | expression '&' expression {
	AA($1,1,2); AA($3,2,2);

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_VV(&callback__45));
	$$ = callback__45(driver.tr, $1, $3);
	ps.pop_back();
    }
    | expression EQUAL expression {
	AA($1,1,2); AA($3,2,2);

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_VV(&callback__46));
	$$ = callback__46(driver.tr, $1, $3);
	ps.pop_back();
    }
    | expression NOTEQUAL expression {
	AA($1,1,2); AA($3,2,2);

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_VV(&callback__47));
	$$ = callback__47(driver.tr, $1, $3);
	ps.pop_back();
    }
    | expression '<' expression {
	AA($1,1,2); AA($3,2,2);

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_VV(&callback__48));
	$$ = callback__48(driver.tr, $1, $3);
	ps.pop_back();
    }
    | expression '>' expression {
	AA($1,1,2); AA($3,2,2);

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_VV(&callback__49));
	$$ = callback__49(driver.tr, $1, $3);
	ps.pop_back();
    }
    | expression LOE expression {
	AA($1,1,2); AA($3,2,2);

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_VV(&callback__50));
	$$ = callback__50(driver.tr, $1, $3);
	ps.pop_back();
    }
    | expression GOE expression {
	AA($1,1,2); AA($3,2,2);

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_VV(&callback__51));
	$$ = callback__51(driver.tr, $1, $3);
	ps.pop_back();
    }
    | expression LSHIFT expression {
	AA($1,1,2); AA($3,2,2);

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_VV(&callback__52));
	$$ = callback__52(driver.tr, $1, $3);
	ps.pop_back();
    }
    | expression RSHIFT expression {
	AA($1,1,2); AA($3,2,2);

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_VV(&callback__53));
	$$ = callback__53(driver.tr, $1, $3);
	ps.pop_back();
    }
    | expression '+' expression {
	AA($1,1,2); AA($3,2,2);

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_VV(&callback__54));
	$$ = callback__54(driver.tr, $1, $3);
	ps.pop_back();
    }
    | expression '-' expression {
	AA($1,1,2); AA($3,2,2);

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_VV(&callback__55));
	$$ = callback__55(driver.tr, $1, $3);
	ps.pop_back();
    }
    | expression '*' expression {
	AA($1,1,2); AA($3,2,2);

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_VV(&callback__56));
	$$ = callback__56(driver.tr, $1, $3);
	ps.pop_back();
    }
    | expression '/' expression {
	AA($1,1,2); AA($3,2,2);

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_VV(&callback__57));
	$$ = callback__57(driver.tr, $1, $3);
	ps.pop_back();
    }
    | expression '%' expression {
	AA($1,1,2); AA($3,2,2);

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_VV(&callback__58));
	$$ = callback__58(driver.tr, $1, $3);
	ps.pop_back();
    }
    | base_expression {
	AA($1,1,1);
	$$ = $1;
    }
    | '+' base_expression {
	AA($2,1,1);

	$$ = $2;
    }
    | '-' base_expression {
	AA($2,1,1);

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_V(&callback__59));
	$$ = callback__59(driver.tr, $2);
    }
    | '!' base_expression {
	AA($2,1,1);

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(new Callback_V_V(&callback__60));
	$$ = callback__60(driver.tr, $2);
    }
    ;

base_expression:
    INTEGER {
	if (driver.record_mode_on)
	    driver.parametric->record.push_back(
				new Callback_V_I(&callback__61, $1));
	$$ = callback__61(driver.tr, $1);
	ps.push_back($$);
    }
    | variable {
	AA($1,1,1);

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(
				    new Callback_V_S(&callback__62, *$1));
	driver.tr.locations[0] = @1;
	$$ = callback__62(driver.tr, $1);
	ps.pop_back();
	ps.push_back($$);
    }
    | const_parameter_id {
	AA($1,1,1);

	if (driver.record_mode_on)
	    driver.parametric->record.push_back(
				    new Callback_V_S(&callback__63, *$1));
	driver.tr.locations[0] = @1;
	$$ = callback__63(driver.tr, $1);
	ps.pop_back();
	ps.push_back($$);
    }
    ;

/* Some useful alias for LowerCaseID and UpperCaseID. */
variable: LowerCaseID { ps.push_back($1); $$ = $1; };
constant_id: UpperCaseID { ps.push_back($1); $$ = $1; };
range_id: UpperCaseID { ps.push_back($1); $$ = $1; };
set_id: UpperCaseID { ps.push_back($1); $$ = $1; };
const_parameter_id: constant_id { AA($1,1,1); $$ = $1; };
parameter_id: UpperCaseID { ps.push_back($1); $$ = $1; };
process_id: UpperCaseID { ps.push_back($1); $$ = $1; };
progress_id: UpperCaseID { ps.push_back($1); $$ = $1; };
//menu_id: UpperCaseID { ps.push_back($1); $$ = $1;};

%%

void yy::FspParser::error (const yy::FspParser::location_type& l,
	const std::string& m)
{
    driver.error(l, m);
}

