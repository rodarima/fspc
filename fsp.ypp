%code top {
#include <cstdio>
#include <iostream>
#include <sstream>
#include <cstdlib>
#include <set>
#include <vector>

using namespace std;

//#define NDEBUG
#include <assert.h>

}


%code requires {
/* Symbols tables. */
#include "symbols_table.hpp"
}


// Bison fundamentally works by asking flex to get the next token, which it
// returns as an object of type "YYSTYPE".  But tokens could be of any
// arbitrary data type!  So we deal with that in Bison by defining a C union
// holding each of the types of tokens that Flex could return, and have Bison
// use that union instead of "int" for the definition of "YYSTYPE":
%union {
    int int_value;
    float float_value;
    std::string *string_ptr;
    class SymbolValue *sv_ptr;
    struct SvpVec * svpvec_ptr;
    struct Pvec * pvec_ptr;
}


%{

/* Inline utilities. */
#include "utils.hpp"

/* Context, ContextsSet and ContextsSetStack. */
#include "context.hpp"

/* Definition of the FspTranslator class. */
#include "translator.hpp"

/* Stuff from flex that bison needs to know about. */
#include "scanner.hpp"

/* Lts definitions and operations. */
#include "lts.hpp"

/* Callbacks. */
#include "callbacks.hpp"



/* A global data structure containing everything the compiler needs. */
struct FspCompiler c;


/* The 'ps' vector and the AA function are necessary in the debug phase in
   order to check that the callback playback systems can work properly. */
vector <void *> ps;
inline void AA(void * barg, int midx, int tot)
{
    assert(barg == ps[ps.size()-1-tot+(midx)]);
}


SvpVec * prefix_and_relabel(SvpVec * prefixv, SvpVec * ltsv, SvpVec * relabv)
{
    assert(ltsv->v.size() == c.tr.current_contexts().size());

    if (prefixv) {
	Lts * lts;
	LabelingSharingValue * lsv;

	assert(prefixv->v.size() == ltsv->v.size());
	for (int c=0; c<prefixv->v.size(); c++) {
	    lsv = err_if_not_labelingsharing(prefixv->v[c]);
	    lts = err_if_not_lts(ltsv->v[c]);
	    /* Apply process labeling. */
	    if (lsv->labeling)
		lts->labeling(*(lsv->labeling));
	    /* Apply process sharing. */
	    if (lsv->sharing)
		lts->sharing(*(lsv->sharing));
	}
    }

    if (relabv) {
	Lts * lts;
	RelabelingValue * rlv;

	assert(ltsv->v.size() == relabv->v.size());
	for (int c=0; c<relabv->v.size(); c++) {
	    lts = err_if_not_lts(ltsv->v[c]);
	    rlv = err_if_not_relabeling(relabv->v[c]);
	    /* Apply relabeling. */
	    if (rlv) {
		for (int i=0; i<rlv->size(); i++)
		    lts->relabeling(*(rlv->new_labels[i]),
						*(rlv->old_labels[i]));
	    }
	}
    }

    return ltsv;
}

#define DEBUG
#ifdef DEBUG
#define PROX(x) cout<<"PROX: ";x;cout<<"\n"
#define PROP(x) cout<<"PROP:==============================================================\n      " << x << "\n"
#else
#define PROP(x)
#define PROX(x)
#endif


void yyerror(const char *s);
%}


// define the "terminal symbol" token types I'm going to use (in CAPS
// by convention), and associate each with a field of the union:

%token IF THEN ELSE
%token WHEN
%token CONST RANGE SET
%token ARROW
%token DOTDOT
%token END STOP ERROR
%token PROPERTY PROGRESS MENU
%token FORALL
%token SHARING
%token OR AND EQUAL NOTEQUAL LOE GOE LSHIFT RSHIFT
%token <int_value> INTEGER
%token <float_value> FLOAT
%token <string_ptr> UpperCaseID
%token <string_ptr> LowerCaseID

%type <svpvec_ptr> simple_expression
%type <svpvec_ptr> base_expr expression unary_expr multiplicative_expr
%type <svpvec_ptr>  additive_expr shift_expr relational_expr equality_expr
%type <svpvec_ptr> bitand_expr bitxor_expr bitor_expr and_expr or_expr

%type <string_ptr> variable constant_id range_id set_id range_or_set_id
%type <string_ptr> parameter_id process_id progress_id menu_id
%type <string_ptr> const_range_set_parameter_id

%type <svpvec_ptr> set set_elements set_expr
%type <svpvec_ptr> action_labels
%type <svpvec_ptr> alphabet_extension_OPT
%type <svpvec_ptr> action_range guard_OPT
%type <svpvec_ptr> range_expr
%type <svpvec_ptr> index_ranges_OPT index_ranges indices_OPT indices

%type <pvec_ptr> choice action_prefix prefix_actions
%type <pvec_ptr> process_body local_process local_process_defs 
%type <pvec_ptr> local_process_def
%type <pvec_ptr> sequential_composition base_local_process else_OPT

%type <pvec_ptr> seq_process_list process_ref_seq
%type <svpvec_ptr> argument_list argument_OPT
%type <svpvec_ptr> process_ref composite_body parallel_composition
%type <svpvec_ptr> prefix_label_OPT prefix_label labeling_OPT labeling
%type <svpvec_ptr> relabel_OPT relabel relabel_def relabel_defs
%type <svpvec_ptr> hiding_OPT hiding

/* Generate a Generic LR parser, instead of a standard LR parser. We need
   this to resolve conflicts at runtime. */
%glr-parser

/* Name of the parser implementation file. */
%output "parser.cpp"

/* Create a parser header file. This is needed because we define yylex()
   in another source file (the FLEX generated scanner source file). */
%defines

/* Write an extra output file containing verbose descriptions of the parser
    states and what is done for each type of lookahead token in that state
%verbose
*/



%%

/* Start symbol: an arbitrary long list of fsp_definitions */
fsp_description:
    fsp_definition
    | fsp_description fsp_definition
    ;

/* All the possible type of fsp_definitions */
fsp_definition:
    constant_def
    | range_def
    | set_def
    | property_def
    | progress_def
    | menu_def
    | process_def
    | composite_def
    ;


/* Action labels TODO: fix */
action_labels:
    LowerCaseID {
	if (c.record_mode_on)
	    c.parametric->record.push_back(
				    new Callback_V_S(&callback__1, *$1));
	$$ = callback__1(c.tr, $1);
	ps.push_back($$);
    }
    | set {
	AA($1,1,1);
	$$ = $1;
    }
    | action_labels '.' LowerCaseID {
	AA($1,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(
				new Callback_V_VS(&callback__2, *$3));
	$$ = callback__2(c.tr, $1, $3);
	
    }
    | action_labels '.' set {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__3));
	$$ = callback__3(c.tr, $1, $3);
	ps.pop_back();
    }
    | action_labels '[' action_range ']' {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__4));
	$$ = callback__4(c.tr, $1, $3);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

set:
    set_id {
	AA($1,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(
				    new Callback_V_S(&callback__5, *$1));
	$$ = callback__5(c.tr, $1);
	ps.pop_back();
	ps.push_back($$);
    }
    | set_expr {
	AA($1,1,1);
	$$ = $1;
    }
    ;

set_expr:
    '{' set_elements '}' {
	AA($2,1,1);
	$2->print();
	$$ = $2;
    }
    ;

action_range:
    expression {
	AA($1,1,1);
	$$ = $1;
    }
    | range_expr {
	AA($1,1,1);
	$$ = $1;
    }
    | set_expr {
	AA($1,1,1);
	$$ = $1;
    }
    | variable ':' range_or_set_id {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(
				new Callback_V_SS(&callback__6, *$1, *$3));
	$$ = callback__6(c.tr, $1, $3);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    | variable ':' range_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(
				    new Callback_V_SV(&callback__7, *$1));
	$$ = callback__7(c.tr, $1, $3);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    | variable ':' set_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(
				    new Callback_V_SV(&callback__8, *$1));
	$$ = callback__8(c.tr, $1, $3);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

range_expr:
    expression DOTDOT expression {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__9));
	$$ = callback__9(c.tr, $1, $3);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;


/* Const, Range, Set */
constant_def:
    CONST constant_id '=' simple_expression {
	AA($2,1,2); AA($4,2,2);
	assert($4->v.size() == 1);

	ConstValue* cvp = err_if_not_const($4->v[0]);
	$4->detach(0);
	if (!c.identifiers.insert(*$2, cvp)) {
	    stringstream errstream;
	    errstream << "const " << *$2 << " declared twice";
	    semantic_error(errstream);
	}
	delete $4;
	delete $2;
	ps.pop_back();
	ps.pop_back();
    };

range_def:
    RANGE range_id '=' simple_expression DOTDOT simple_expression {
	AA($2,1,3); AA($4,2,3); AA($6,3,3);
	assert($4->v.size() == 1 && $6->v.size() == 1);

	RangeValue* rvp = new RangeValue;
	ConstValue * cvp1 = err_if_not_const($4->v[0]);
	ConstValue * cvp2 = err_if_not_const($6->v[0]);
	rvp->low = cvp1->value;
	rvp->high = cvp2->value;
	delete $4;
	delete $6;
	if (!c.identifiers.insert(*$2, rvp)) {
	    stringstream errstream;
	    errstream << "range " << *$2 << " declared twice";
	    semantic_error(errstream);
	}
	delete $2;
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
    };

set_def:
    SET set_id '=' '{' set_elements '}' {
	AA($2,1,2); AA($5,2,2);
	if (!c.identifiers.insert(*$2, $5->v[0])) {
	    stringstream errstream;
	    errstream << "set " << *$2 << " declared twice";
	    semantic_error(errstream);
	}
	$5->detach(0);
	delete $5;
	delete $2;
	ps.pop_back();
	ps.pop_back();
    };

set_elements:
    action_labels {
	AA($1,1,1);
	$$ = $1;
    }
    | set_elements ',' action_labels {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__13));
	$$ = callback__13(c.tr, $1, $3);
	ps.pop_back();
    }
    ;


/* Processes */
process_def:
    process_id param_OPT {
	AA($1,1,1);
	c.record_mode_on = 1;
	if (c.record_mode_on)
	    c.parametric->record.push_back(
				    new Callback_N_S(&callback__14, *$1));
	callback__14(c.tr, $1);
    }
    '=' process_body alphabet_extension_OPT relabel_OPT hiding_OPT '.' {
	AA($1,1,5); AA($5,2,5); AA($6,3,5); AA($7,4,5); AA($8,5,5);
	string name = *$1;
	Lts * lts;
	ProcessNode * pnp;
	SymbolValue * svp;
	SetValue * setvp;

	if (c.record_mode_on)
	    c.parametric->record.push_back(
				    new Callback_P_SPVVV(&callback__15, *$1));
	pnp = callback__15(c.tr, $1, $5, $6, $7, $8);

	/* Convert the collection of ProcessNodes in an Lts object. */
	lts = new Lts(pnp, &c.actions);

	/* Extend the alphabet if is the case. */
	if ($6) {
	    if ($6->v.size() != 1) {
		stringstream errstream;
		errstream << "Multiset alphabet extension";
		semantic_error(errstream);
	    }
	    setvp = err_if_not_set($6->v[0]);
	    for (int i=0; i<setvp->actions.size(); i++)
		lts->updateAlphabet(c.actions.insert(setvp->actions[i]));
	    c.parametric->alphabet_extension = *setvp;
	}

	/* Apply relabeling. */
	if ($7) {
	    RelabelingValue * rlv;

	    $7->print();
	    assert($7->v.size() == 1);
	    rlv = err_if_not_relabeling($7->v[0]);
	    for (int i=0; i<rlv->size(); i++)
		lts->relabeling(*(rlv->new_labels[i]), *(rlv->old_labels[i]));
	}

	/* Apply hiding. */
	if ($8) {
	    HidingValue * hvp = err_if_not_hiding($8->v[0]);

	    assert($8->v.size() == 1);
	    lts->hiding(*(hvp->setvp), hvp->interface);
	}
	delete $6;
	delete $7;
	delete $8;

	/* Don't delete pnp, since this has been inserted in
	   'local_processes', and will be thereafter deleted when the symbol
	   table will be destroyed. */

	/* Clear and free 'local_processes'. */
	c.tr.local_processes.clear();
	/* Clear 'aliases'. */
	c.tr.aliases.clear();
	/* Free all the nodes allocated by c.pna, and remove the from
	   the allocator itself. */
	c.pna.clear();

	lts->print();
	lts->graphvizOutput((name + ".gv").c_str());
	/* Remove process parameters from c.identifiers. */
	for (int i=0; i<c.parametric->parameter_names.size(); i++)
	    c.identifiers.remove(c.parametric->parameter_names[i]);

	/* Insert lts into the global 'processes' table. */
	if (!c.processes.insert(name, lts)) {
	    stringstream errstream;
	    errstream << "Process " << name << " already declared";
	    semantic_error(errstream);
	}

	if (c.record_mode_on) {
	    /* Store c.parametric in parametric_processes. */
	    if (!c.parametric_processes.insert(name, c.parametric)) {
		stringstream errstream;
		errstream << "Parametric process " << name
				<< " already declared";
		semantic_error(errstream);
	    }
	    c.parametric->print(); // XXX

	    /* Prepare for the next parametric process. */
	    c.parametric = new ParametricProcess;
	    c.record_mode_on = 0;
	}
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
    }
    ;

process_body:
    local_process {
	AA($1,1,1);
	$$ = $1;
    }
    | local_process ',' local_process_defs {
	AA($1,1,2); AA($3,2,2);
	$$ = $1;
	ps.pop_back();
    }
    ;

local_process_defs:
    local_process_def {
	AA($1,1,1);
	$$ = $1;
    }
    | local_process_defs ',' local_process_def {
	AA($1,1,2); AA($3,2,2);
	$$ = $1;
	ps.pop_back();
    }
    ;

local_process_def:
    process_id {
	AA($1,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(
				    new Callback_N_S(&callback__16, *$1));
	callback__16(c.tr, $1);
    } index_ranges_OPT '=' {
	AA($1,1,2); AA($3,2,2);
	cout << "index_ranges_OPT:\n";
	$3->print();
	if (c.record_mode_on)
	    c.parametric->record.push_back(
				    new Callback_N_SV(&callback__17, *$1));
	callback__17(c.tr, $1, $3);
    } local_process {
	AA($1,1,3); AA($3,2,3); AA($6,3,3);
	if (c.record_mode_on)
	    c.parametric->record.push_back(
				    new Callback_P_SVP(&callback__18, *$1));
	$$ = callback__18(c.tr, $1, $3, $6);
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

alphabet_extension_OPT:
    {
	$$ = NULL;
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_null);
	ps.push_back($$);
    }
    | '+' set {
	AA($2,1,1);
	$$ = $2;
    }
    ;

local_process:
    base_local_process {
	AA($1,1,1);
	$$ = $1;
    }
    | sequential_composition {
	AA($1,1,1);
	$$ = $1;
    }
    | IF expression THEN {
	AA($2,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_N_V(&callback__19));
	callback__19(c.tr, $2);
    } local_process {
	AA($2,1,2); AA($5,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_N_VP(&callback__20));
	callback__20(c.tr, $2, $5);
    } else_OPT {
	AA($2,1,3); AA($5,2,3); AA($7,3,3);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_P_VPP(&callback__21));
	$$ = callback__21(c.tr, $2, $5, $7);
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    | '(' {
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_N(&callback__22));
	callback__22(c.tr);
	PROX(cout << "CSS height (push) " << c.tr.css.stack.size());
	PROX(c.tr.current_contexts().print());
    } choice ')' {
	AA($3,1,1);
	//$3->print();
	$$ = $3;
    }
    ;

else_OPT:
    {
	$$ = NULL;
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_null);
	ps.push_back($$);
    }
    | ELSE local_process {
	AA($2,1,1);
	$$ = $2;
    }

base_local_process:
    END {
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_P(&callback__23));
	$$ = callback__23(c.tr);
	ps.push_back($$);
    }
    | STOP {
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_P(&callback__24));
	$$ = callback__24(c.tr);
	ps.push_back($$);
    }
    | ERROR {
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_P(&callback__25));
	$$ = callback__25(c.tr);
	ps.push_back($$);
    }
    | process_id indices_OPT {
	AA($1,1,2); AA($2,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(
				    new Callback_P_SV(&callback__26, *$1));
	$$ = callback__26(c.tr, $1, $2);;
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

choice:
    action_prefix {
	AA($1,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_P_P(&callback__27));
	$$ = callback__27(c.tr, $1);
	PROX(cout << "CSS height = (pop) " << c.tr.css.stack.size());
    }
    | choice '|' {
	AA($1,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_N_P(&callback__28));
	callback__28(c.tr, $1);
	PROX(cout << "CSS height (push) " << c.tr.css.stack.size());
	PROX(c.tr.current_contexts().print());
    } action_prefix {
	AA($1,1,2); AA($4,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_P_PP(&callback__29));
	$$ = callback__29(c.tr, $1, $4);
	cout << "CSS height = (pop) " << c.tr.css.stack.size() << "\n";
	ps.pop_back();
    }
    ;

action_prefix:
    guard_OPT {
	AA($1,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_N_V(&callback__30));
	callback__30(c.tr, $1);
    } prefix_actions ARROW local_process {
	AA($1,1,3); AA($3,2,3); AA($5,3,3);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_P_VPP(&callback__31));
	$$ = callback__31(c.tr, $1, $3, $5);
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

prefix_actions:
    action_labels {
	AA($1,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_P_V(&callback__32));
	$$ = callback__32(c.tr, $1);
	ps.pop_back();
	ps.push_back($$);
    }
    | prefix_actions ARROW action_labels {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_P_PV(&callback__33));
	$$ = callback__33(c.tr, $1, $3);
	ps.pop_back();
    }
    ;

guard_OPT:
    {
	$$ = NULL;
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_null);
	ps.push_back($$);
    }
    | WHEN expression {
	AA($2,1,1);
	$$ = $2;
    }
    ;

indices_OPT:
    {
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V(&callback__34));
	$$ = callback__34(c.tr);
	ps.push_back($$);
    }
    | indices
    ;

indices:
    '[' expression ']' {
	AA($2,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_V(&callback__35));
	$$ = callback__35(c.tr, $2);
	ps.pop_back();
	ps.push_back($$);
    }
    | indices '[' expression ']' {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__36));
	$$ = callback__36(c.tr, $1, $3);
	ps.pop_back();
    }
    ;

index_ranges_OPT:
    {
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V(&callback__37));
	$$ = callback__37(c.tr);
	ps.push_back($$);
    }
    | index_ranges
    ;

index_ranges:
    '[' action_range ']' {
	AA($2,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_V(&callback__38));
	$$ = callback__38(c.tr, $2);
	ps.pop_back();
	ps.push_back($$);
    }
    | index_ranges '[' action_range ']' {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__39));
	$$ = callback__39(c.tr, $1, $3);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

sequential_composition:
    seq_process_list ';' base_local_process {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_P_PP(&callback__64));
	$$ = callback__64(c.tr, $1, $3);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

seq_process_list:
    process_ref_seq {
	AA($1,1,1);
	$$ = $1;
    }
    | seq_process_list ';' process_ref_seq {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_P_PP(&callback__65));
	$$ = callback__65(c.tr, $1, $3);
	ps.pop_back();
    }
    ;

process_ref_seq:
    process_id argument_OPT {
	AA($1,1,2); AA($2,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(
				    new Callback_P_SV(&callback__66, *$1));
	$$ = callback__66(c.tr, $1, $2);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

argument_OPT:
    {
	$$ = NULL;
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_null);
	ps.push_back($$);
    }
    |'(' argument_list ')' {
	AA($2,1,1);
	$$ = $2;
    }
    ;

argument_list:
    expression {
	AA($1,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_V(&callback__67));
	$$ = callback__67(c.tr, $1);
	ps.pop_back();
	ps.push_back($$);
    }
    | argument_list ',' expression {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__68));
	$$ = callback__68(c.tr, $1, $3);
	ps.pop_back();
    }
    ;


/* Composite processes */
composite_def:
    OR process_id param_OPT {
	c.tr.init_fakenode();
    } '=' composite_body priority_OPT hiding_OPT '.' {
	// TODO OPT
	AA($2,1,3); AA($6,2,3); AA($8,3,3);
	assert($6->v.size() == 1);
	Lts * lts;

	lts = err_if_not_lts($6->v[0]);
	if (!c.processes.insert(*$2, lts)) {
	    stringstream errstream;
	    errstream << "Process " << *$2 << " already declared";
	    semantic_error(errstream);
	}
	cout << "#####################Composite process " << *$2 << " defined#############\n";
	lts->print();
	lts->graphvizOutput((*$2 + ".gv").c_str());
	
	delete $2;
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
    }
    ;

composite_body:
    prefix_label_OPT process_ref relabel_OPT {
	//TODO relabel_OPT
	AA($1,1,3); AA($2,2,3); AA($3,3,3);
	$$ = prefix_and_relabel($1, $2, $3);
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    | prefix_label_OPT '(' parallel_composition ')' relabel_OPT {
	AA($1,1,3); AA($3,2,3); AA($5,3,3);
	$$ = prefix_and_relabel($1, $3, $5);
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    | FORALL ranges composite_body {
	$$ = $3;
    }
    | IF expression THEN composite_body {
	$$ = $4;
    }
    | IF expression THEN composite_body ELSE composite_body {
	$$ = $4;
    }
    ;

process_ref:
    process_id argument_OPT {
	AA($1,1,2); AA($2,2,2);
	SymbolValue * svp;
	Lts * lts;
	ParametricProcess * ppp;
	SvpVec * vp = new SvpVec;
	SvpVec * argvp = $2;
	ArgumentsValue * avp;
	ProcessNode * pnp;

	/* Lookup 'process_id' in the 'parametric_process' table. */
	if (!c.parametric_processes.lookup(*$1, svp)) {
	    stringstream errstream;
	    errstream << "Process " << *$1 << " undeclared\n";
	    semantic_error(errstream);
	}
	ppp = err_if_not_parametric(svp);

	if (!argvp) {
	    /* 'argvp' is going to specify the default parameters for every
	       context. */
	    argvp = new SvpVec;
	    for (int k=0; k<c.tr.current_contexts().size(); k++) {
		avp = new ArgumentsValue;
		avp->args = ppp->parameter_defaults;
		argvp->v.push_back(avp);
	    }
	}

	for (int k=0; k<argvp->v.size(); k++) {
	    string name = *$1;

	    avp = err_if_not_arguments(argvp->v[k]);
	    if (avp->args.size() != ppp->parameter_names.size()) {
		stringstream errstream;
		errstream << "Parameters mismatch\n";
		semantic_error(errstream);
	    }
	    pnp = ppp->replay(c, avp->args);
	    /* Compute the process name. TODO */

	    /* Convert pnp to an Lts. */
	    lts = new Lts(pnp, &c.actions);

	    /* Extend the alphabet. */
	    for (int i=0; i<ppp->alphabet_extension.actions.size(); i++)
		lts->updateAlphabet(
			c.actions.insert(ppp->alphabet_extension.actions[i]));

	    vp->v.push_back(lts);
	}
	delete $1;
	delete argvp;

	$$ = vp;
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

parallel_composition:
    composite_body {
	AA($1,1,1);
	$$ = $1;
    }
    | parallel_composition OR composite_body {
	AA($1,1,2); AA($3,2,2);
	assert($1->v.size() == $3->v.size());
	SvpVec * vp = new SvpVec;
	Lts * lts;
	Lts * llts;
	Lts * rlts;

	for (int c=0; c<$1->v.size(); c++) {
	    llts = err_if_not_lts($1->v[c]);
	    rlts = err_if_not_lts($3->v[c]);
	    lts = new Lts(*llts, *rlts);
	    vp->v.push_back(lts);
	}
	delete $1;
	delete $3;

	$$ = vp;
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

prefix_label_OPT:
    {
	$$ = NULL;
	ps.push_back($$);
    }
    | prefix_label {
	AA($1,1,1);
	$$ = $1;
    }
    ;

prefix_label:
    labeling {
	AA($1,1,1);
	$$ = $1;
    } 
    | action_labels SHARING labeling_OPT{
	AA($1,1,2); AA($3,2,2);
	assert($1->v.size() == c.tr.current_contexts().size());
	SetValue * setvp;
	LabelingSharingValue * lsv;

	for (int c=0; c<$1->v.size(); c++) {
	    setvp = err_if_not_set($1->v[c]);
	    lsv = new LabelingSharingValue;
	    lsv->sharing = setvp;
	    $1->v[c] = lsv;
	}
	if ($3) {
	    LabelingSharingValue * rlsv;

	    assert($1->v.size() == $3->v.size());
	    for (int c=0; c<$3->v.size(); c++) {
		rlsv = err_if_not_labelingsharing($3->v[c]);
		assert(!rlsv->sharing);
		lsv->labeling = rlsv->labeling;
		rlsv->labeling = NULL; // detach
	    }
	    delete $3;
	}
	$$ = $1;
	ps.pop_back();
    }
    ;

labeling_OPT:
    {
	$$ = NULL;
	ps.push_back($$);
    }
    | labeling {
	AA($1,1,1);
	$$ = $1;
    }
    ;

labeling:
    action_labels ':' {
	AA($1,1,1);
	assert($1->v.size() == c.tr.current_contexts().size());
	SetValue * setvp;
	LabelingSharingValue * lsv;

	for (int c=0; c<$1->v.size(); c++) {
	    setvp = err_if_not_set($1->v[c]);
	    lsv = new LabelingSharingValue;
	    lsv->labeling = setvp;
	    $1->v[c] = lsv;
	}
	$$ = $1;
    }
    ;

priority_OPT:
    | priority;

priority:
    RSHIFT set
    | LSHIFT set
    ;

ranges_OPT:
    | ranges;

ranges:
    '[' action_range ']'
    | ranges '[' action_range ']'
    ;


/* Parameters */
param_OPT:
    | param
    ;

param:
    '(' parameter_list ')' {
    }
    ;

parameter_list:
    parameter {
    }
    | parameter_list ',' parameter {
    }
    ;

parameter:
    parameter_id '=' expression {
	AA($1,1,2); AA($3,2,2);
	if ($3->v.size() != 1) {
	    // XXX this should never happen..
	    stringstream errstream;
	    errstream << "Illegal use of variables in parameter declaration";
	    semantic_error(errstream);
	}
	ConstValue * cvp = err_if_not_const($3->v[0]);
	$3->detach(0);
	SymbolValue * svp = cvp;
	if (!c.identifiers.insert(*$1, svp)) {
	    stringstream errstream;
	    errstream << "identifier " << *$1 << " already declared";
	    semantic_error(errstream);
	}

	/* Update c.parametric-> */
	c.parametric->parameter_names.push_back(*$1);
	c.parametric->parameter_defaults.push_back(cvp->value);

	delete $1;
	delete $3;
	ps.pop_back();
	ps.pop_back();
    }	
    ;


/* Re-Labeling and Hiding */
relabel_OPT: {
	$$ = NULL;
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_null);
	ps.push_back($$);
    }
    | relabel {
	AA($1,1,1);
	$$ = $1;
    }
    ;

relabel:
    '/' '{' relabel_defs '}' {
	AA($3,1,1);
	$$ = $3;
    }
    ;

relabel_defs:
    relabel_def {
	AA($1,1,1);
	$$ = $1;
    }
    | relabel_defs ',' relabel_def {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__69));
	$$ = callback__69(c.tr, $1, $3);
	ps.pop_back();
    }
    ;

relabel_def:
    action_labels '/' action_labels {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__70));
	$$ = callback__70(c.tr, $1, $3);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    | FORALL index_ranges '{' relabel_defs '}' {
	// TODO
	$$ = $4;
    }
    ;

hiding_OPT:
    {
	$$ = NULL;
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_null);
	ps.push_back($$);
    }
    | hiding {
	AA($1,1,1);
	$$ = $1;
    }
    ;

hiding:
    '\\' set {
	AA($2,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_V(&callback__71));
	$$ = callback__71(c.tr, $2);
	ps.pop_back();
	ps.push_back($$);
    }
    | '@' set {
	AA($2,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_V(&callback__72));
	$$ = callback__72(c.tr, $2);
	ps.pop_back();
	ps.push_back($$);
    }
    ;


/* Property, Progress and Menu */
// TODO second form of progress (if S then C)
property_def:
    PROPERTY process_def
    ;

progress_def:
    PROGRESS progress_id ranges_OPT '=' set
    ;

menu_def:
    MENU menu_id '=' set
    ;


/* An expression or a simple_expression: standard operators and priorities. */
expression:
    or_expr {
	AA($1,1,1);
	$$ = $1;
    }
    ;

simple_expression:
    additive_expr {
	AA($1,1,1);
	$$ = $1;
    }
    ;

or_expr:
    and_expr
    | or_expr OR and_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__41));
	$$ = callback__41(c.tr, $1, $3);
	ps.pop_back();
    }
    ;

and_expr:
    bitor_expr
    | and_expr AND bitor_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__42));
	$$ = callback__42(c.tr, $1, $3);
	ps.pop_back();
    }
    ;

bitor_expr:
    bitxor_expr
    | bitor_expr '|' bitxor_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__43));
	$$ = callback__43(c.tr, $1, $3);
	ps.pop_back();
    }
    ;

bitxor_expr:
    bitand_expr
    | bitxor_expr '^' bitand_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__44));
	$$ = callback__44(c.tr, $1, $3);
	ps.pop_back();
    }
    ;

bitand_expr:
    equality_expr
    | bitand_expr '&' equality_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__45));
	$$ = callback__45(c.tr, $1, $3);
	ps.pop_back();
    }
    ;

equality_expr:
    relational_expr
    | equality_expr EQUAL relational_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__46));
	$$ = callback__46(c.tr, $1, $3);
	ps.pop_back();
    }
    | equality_expr NOTEQUAL relational_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__47));
	$$ = callback__47(c.tr, $1, $3);
	ps.pop_back();
    }
    ;

relational_expr:
    shift_expr
    | relational_expr '<' shift_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__48));
	$$ = callback__48(c.tr, $1, $3);
	ps.pop_back();
    }
    | relational_expr '>' shift_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__49));
	$$ = callback__49(c.tr, $1, $3);
	ps.pop_back();
    }
    | relational_expr LOE shift_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__50));
	$$ = callback__50(c.tr, $1, $3);
	ps.pop_back();
    }
    | relational_expr GOE shift_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__51));
	$$ = callback__51(c.tr, $1, $3);
	ps.pop_back();
    }
    ;

shift_expr:
    additive_expr
    | shift_expr LSHIFT additive_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__52));
	$$ = callback__52(c.tr, $1, $3);
	ps.pop_back();
    }
    | shift_expr RSHIFT additive_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__53));
	$$ = callback__53(c.tr, $1, $3);
	ps.pop_back();
    }
    ;

additive_expr:
    multiplicative_expr
    | additive_expr '+' multiplicative_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__54));
	$$ = callback__54(c.tr, $1, $3);
	ps.pop_back();
    }
    | additive_expr '-' multiplicative_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__55));
	$$ = callback__55(c.tr, $1, $3);
	ps.pop_back();
    }
    ;

multiplicative_expr:
    unary_expr
    | multiplicative_expr '*' unary_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__56));
	$$ = callback__56(c.tr, $1, $3);
	ps.pop_back();
    }
    | multiplicative_expr '/' unary_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__57));
	$$ = callback__57(c.tr, $1, $3);
	ps.pop_back();
    }
    | multiplicative_expr '%' unary_expr {
	AA($1,1,2); AA($3,2,2);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_VV(&callback__58));
	$$ = callback__58(c.tr, $1, $3);
	ps.pop_back();
    }
    ;

unary_expr:
    base_expr
    | '+' base_expr {
	AA($2,1,1);
	for (int i=0; i<$2->v.size(); i++) {
	    err_if_not_const($2->v[i]);
	}
	$$ = $2;
    }
    | '-' base_expr {
	AA($2,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_V(&callback__59));
	$$ = callback__59(c.tr, $2);
    }
    | '!' base_expr {
	AA($2,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(new Callback_V_V(&callback__60));
	$$ = callback__60(c.tr, $2);
    }
    ;

/* TODO: complete base_expr */
base_expr:
    INTEGER {
	if (c.record_mode_on)
	    c.parametric->record.push_back(
				new Callback_V_I(&callback__61, $1));
	$$ = callback__61(c.tr, $1);
	ps.push_back($$);
	//cout << "UU " << $1 << "\n";
    }
    | variable {
	AA($1,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(
				    new Callback_V_S(&callback__62, *$1));
	$$ = callback__62(c.tr, $1);
	ps.pop_back();
	ps.push_back($$);
    }
    | const_range_set_parameter_id {
	AA($1,1,1);
	if (c.record_mode_on)
	    c.parametric->record.push_back(
				    new Callback_V_S(&callback__63, *$1));
	$$ = callback__63(c.tr, $1);
	ps.pop_back();
	ps.push_back($$);
    }
    | '(' expression ')' {
	AA($2,1,1);
	$$ = $2;
    }
    ;

/* Some useful alias for LowerCaseID and UpperCaseID. */
variable: LowerCaseID { ps.push_back($1); };
constant_id: UpperCaseID { ps.push_back($1); };
range_id: UpperCaseID { ps.push_back($1); };
set_id: UpperCaseID { ps.push_back($1); };
range_or_set_id: set_id { AA($1,1,1); };
const_range_set_parameter_id: set_id { AA($1,1,1); };
parameter_id: UpperCaseID { ps.push_back($1); };
process_id: UpperCaseID { ps.push_back($1); };
progress_id: UpperCaseID { ps.push_back($1); };
menu_id: UpperCaseID { ps.push_back($1); };

%%


const char * ex = "P=(a->b->P).";

int parser()
{
    const char * input_name = "input";

    /*
    ScannerFileBuffer sfb(input_name);
    sfb.select();
    yyparse();

    ScannerStringBuffer ssb(ex,12);
    ssb.select();
    yyparse(); */

    InputBuffersStack ibs;

    ibs.push(input_name);
    yyparse();
    ibs.pop();

    return 0;
}


void yyerror(const char *s) {
    cout << "Syntax error:" << s << endl;
    // might as well halt now:
    exit(-1);
}

