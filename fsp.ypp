%code top {
#include <cstdio>
#include <iostream>
#include <sstream>
#include <cstdlib>
#include <set>
#include <vector>

using namespace std;

//#define NDEBUG
#include <assert.h>

}


%code requires {
/* Symbols tables. */
#include "symbols_table.hpp"
}


// Bison fundamentally works by asking flex to get the next token, which it
// returns as an object of type "YYSTYPE".  But tokens could be of any
// arbitrary data type!  So we deal with that in Bison by defining a C union
// holding each of the types of tokens that Flex could return, and have Bison
// use that union instead of "int" for the definition of "YYSTYPE":
%union {
    int int_value;
    float float_value;
    std::string *string_ptr;
    class SymbolValue *sv_ptr;
    struct SvpVec * svpvec_ptr;
    struct Pvec * pvec_ptr;
}


%{

/* Inline utilities. */
#include "utils.hpp"

/* Context, ContextsSet and ContextsSetStack. */
#include "context.hpp"

/* Definition of the FspTranslator class. */
#include "translator.hpp"

/* Stuff from flex that bison needs to know about. */
#include "scanner.hpp"

/* Lts definitions and operations. */
#include "lts.hpp"

/* Callbacks. */
#include "callbacks.hpp"



/* A global data structure containing everything the translator needs. */
struct FspTranslator tr;

vector <void *> ps;
inline void AA(void * barg, int midx, int tot)
{
    assert(barg == ps[ps.size()-1-tot+(midx)]);
}


#define DEBUG
#ifdef DEBUG
#define PROX(x) cout<<"PROX: ";x;cout<<"\n"
#define PROP(x) cout<<"PROP:==============================================================\n      " << x << "\n"
#else
#define PROP(x)
#define PROX(x)
#endif


void yyerror(const char *s);
%}


// define the "terminal symbol" token types I'm going to use (in CAPS
// by convention), and associate each with a field of the union:

%token IF THEN ELSE
%token WHEN
%token CONST RANGE SET
%token ARROW
%token DOTDOT
%token END STOP ERROR
%token PROPERTY PROGRESS MENU
%token FORALL
%token SHARING
%token OR AND EQUAL NOTEQUAL LOE GOE LSHIFT RSHIFT
%token <int_value> INTEGER
%token <float_value> FLOAT
%token <string_ptr> UpperCaseID
%token <string_ptr> LowerCaseID

%type <svpvec_ptr> simple_expression
%type <svpvec_ptr> base_expr expression unary_expr multiplicative_expr
%type <svpvec_ptr>  additive_expr shift_expr relational_expr equality_expr
%type <svpvec_ptr> bitand_expr bitxor_expr bitor_expr and_expr or_expr

%type <string_ptr> variable constant_id range_id set_id range_or_set_id
%type <string_ptr> parameter_id process_id progress_id menu_id
%type <string_ptr> const_range_set_parameter_id

%type <svpvec_ptr> set set_elements set_expr
%type <svpvec_ptr> action_labels
%type <svpvec_ptr> alphabet_extension_OPT
%type <svpvec_ptr> action_range guard_OPT
%type <svpvec_ptr> range_expr
%type <svpvec_ptr> index_ranges_OPT index_ranges indices_OPT indices

%type <pvec_ptr> choice action_prefix prefix_actions
%type <pvec_ptr> process_body local_process local_process_defs 
%type <pvec_ptr> local_process_def
%type <pvec_ptr> sequential_composition base_local_process else_OPT
%type <pvec_ptr> seq_process_list process_ref

/* Generate a Generic LR parser, instead of a standard LR parser. We need
   this to resolve conflicts at runtime. */
%glr-parser

/* Name of the parser implementation file. */
%output "parser.cpp"

/* Create a parser header file. This is needed because we define yylex()
   in another source file (the FLEX generated scanner source file). */
%defines

/* Write an extra output file containing verbose descriptions of the parser
    states and what is done for each type of lookahead token in that state
%verbose
*/



%%

/* Start symbol: an arbitrary long list of fsp_definitions */
fsp_description:
    fsp_definition
    | fsp_description fsp_definition
    ;

/* All the possible type of fsp_definitions */
fsp_definition:
    constant_def
    | range_def
    | set_def
    | property_def
    | progress_def
    | menu_def
    | process_def
    | composite_def
    ;


/* Action labels TODO: fix */
action_labels:
    LowerCaseID {
	$$ = callback__1(tr, $1);
	ps.push_back($$);
    }
    | set {
	AA($1,1,1);
	$$ = $1;
    }
    | action_labels '.' LowerCaseID {
	AA($1,1,1);
	$$ = callback__2(tr, $1, $3);
    }
    | action_labels '.' set {
	AA($1,1,2); AA($3,2,2);
	$$ = callback__3(tr, $1, $3);
	ps.pop_back();
    }
    | action_labels '[' action_range ']' {
	AA($1,1,2); AA($3,2,2);
	$$ = callback__4(tr, $1, $3);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

set:
    set_id {
	AA($1,1,1);
	$$ = callback__5(tr, $1);
	ps.pop_back();
	ps.push_back($$);
    }
    | set_expr {
	AA($1,1,1);
	$$ = $1;
    }
    ;

set_expr:
    '{' set_elements '}' {
	AA($2,1,1);
	$2->print();
	$$ = $2;
    }
    ;

action_range:
    expression {
	AA($1,1,1);
	$$ = $1;
    }
    | range_expr {
	AA($1,1,1);
	$$ = $1;
    }
    | set_expr {
	AA($1,1,1);
	$$ = $1;
    }
    | variable ':' range_or_set_id {
	AA($1,1,2); AA($3,2,2);
	$$ = callback__6(tr, $1, $3);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    | variable ':' range_expr {
	AA($1,1,2); AA($3,2,2);
	$$ = callback__7(tr, $1, $3);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    | variable ':' set_expr {
	AA($1,1,2); AA($3,2,2);
	$$ = callback__8(tr, $1, $3);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

range_expr:
    expression DOTDOT expression {
	AA($1,1,2); AA($3,2,2);
	$$ = callback__9(tr, $1, $3);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;


/* Const, Range, Set */
constant_def:
    CONST constant_id '=' simple_expression {
	AA($2,1,2); AA($4,2,2);
	if ($4->v.size() != 1) {
	    // XXX this should never happen, because we get an "undeclared"
	    stringstream errstream;
	    errstream << "Illegal use of variables in const declaration";
	    semantic_error(errstream);
	}
	ConstValue* cvp = err_if_not_const($4->v[0]);
	$4->detach(0);
	if (!tr.identifiers.insert(*$2, cvp)) {
	    stringstream errstream;
	    errstream << "const " << *$2 << " declared twice";
	    semantic_error(errstream);
	}
	delete $4;
	delete $2;
	ps.pop_back();
	ps.pop_back();
    };

range_def:
    RANGE range_id '=' simple_expression DOTDOT simple_expression {
	AA($2,1,3); AA($4,2,3); AA($6,3,3);
	if ($4->v.size() != 1 || $6->v.size() != 1) {
	    // XXX this should never happen, because we get an "undeclared"
	    stringstream errstream;
	    errstream << "Illegal use of variables in range declaration";
	    semantic_error(errstream);
	}
	RangeValue* rvp = new RangeValue;
	ConstValue * cvp1 = err_if_not_const($4->v[0]);
	ConstValue * cvp2 = err_if_not_const($6->v[0]);
	rvp->low = cvp1->value;
	rvp->high = cvp2->value;
	//delete cvp1; // done below
	//delete cvp2;
	delete $4;
	delete $6;
	if (!tr.identifiers.insert(*$2, rvp)) {
	    stringstream errstream;
	    errstream << "range " << *$2 << " declared twice";
	    semantic_error(errstream);
	}
	delete $2;
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
    };

set_def:
    SET set_id '=' '{' set_elements '}' {
	AA($2,1,2); AA($5,2,2);
	if (!tr.identifiers.insert(*$2, $5->v[0])) {
	    stringstream errstream;
	    errstream << "set " << *$2 << " declared twice";
	    semantic_error(errstream);
	}
	$5->detach(0);
	delete $5;
	delete $2;
	ps.pop_back();
	ps.pop_back();
    };

set_elements:
    action_labels {
	AA($1,1,1);
	$$ = $1;
    }
    | set_elements ',' action_labels {
	AA($1,1,2); AA($3,2,2);
	$$ = callback__13(tr, $1, $3);
	ps.pop_back();
    }
    ;


/* Processes */
process_def:
    process_id param_OPT {
	AA($1,1,1);
	callback__14(tr, $1);
    }
    '=' process_body alphabet_extension_OPT relabel_OPT hiding_OPT '.' {
	AA($1,1,3); AA($5,2,3); AA($6,3,3);
	callback__15(tr, $1, $5, $6);
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
    }
    ;

process_body:
    local_process {
	AA($1,1,1);
	$$ = $1;
    }
    | local_process ',' local_process_defs {
	AA($1,1,2); AA($3,2,2);
	$$ = $1;
	ps.pop_back();
    }
    ;

local_process_defs:
    local_process_def {
	AA($1,1,1);
	$$ = $1;
    }
    | local_process_defs ',' local_process_def {
	AA($1,1,2); AA($3,2,2);
	$$ = $1;
	ps.pop_back();
    }
    ;

local_process_def:
    process_id {
	AA($1,1,1);
	callback__16(tr, $1);
    } index_ranges_OPT '=' {
	AA($1,1,2); AA($3,2,2);
	cout << "index_ranges_OPT:\n";
	$3->print();
	callback__17(tr, $1, $3);
    } local_process {
	AA($1,1,3); AA($3,2,3); AA($6,3,3);
	$$ = callback__18(tr, $1, $3, $6);
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

alphabet_extension_OPT:
    {
	$$ = NULL;
	ps.push_back($$);
    }
    | '+' set {
	AA($2,1,1);
	$$ = $2;
    }
    ;

local_process:
    base_local_process {
	AA($1,1,1);
	$$ = $1;
    }
    | sequential_composition {
/*
	$$ = $1;
*/
    }
    | IF expression THEN {
	AA($2,1,1);
	callback__19(tr, $2);
    } local_process {
	AA($2,1,2); AA($5,2,2);
	callback__20(tr, $2, $5);
    } else_OPT {
	AA($2,1,3); AA($5,2,3); AA($7,3,3);
	$$ = callback__21(tr, $2, $5, $7);
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    | '(' {
	callback__22(tr);
	PROX(cout << "CSS height (push) " << tr.css.stack.size());
	PROX(tr.current_contexts().print());
    } choice ')' {
	AA($3,1,1);
	//$3->print();
	$$ = $3;
    }
    ;

else_OPT:
    {
	$$ = NULL;
	ps.push_back($$);
    }
    | ELSE local_process {
	AA($2,1,1);
	$$ = $2;
    }

base_local_process:
    END {
	$$ = callback__23(tr);
	ps.push_back($$);
    }
    | STOP {
	$$ = callback__24(tr);
	ps.push_back($$);
    }
    | ERROR {
	$$ = callback__25(tr);
	ps.push_back($$);
    }
    | process_id indices_OPT {
	AA($1,1,2); AA($2,2,2);
	$$ = callback__26(tr, $1, $2);;
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

choice:
    action_prefix {
	AA($1,1,1);
	$$ = callback__27(tr, $1);
	PROX(cout << "CSS height = (pop) " << tr.css.stack.size());
    }
    | choice '|' {
	AA($1,1,1);
	callback__28(tr, $1);
	PROX(cout << "CSS height (push) " << tr.css.stack.size());
	PROX(tr.current_contexts().print());
    } action_prefix {
	AA($1,1,2); AA($4,2,2);
	$$ = callback__29(tr, $1, $4);
	cout << "CSS height = (pop) " << tr.css.stack.size() << "\n";
	ps.pop_back();
    }
    ;

action_prefix:
    guard_OPT {
	AA($1,1,1);
	callback__30(tr, $1);
    } prefix_actions ARROW local_process {
	AA($1,1,3); AA($3,2,3); AA($5,3,3);
	$$ = callback__31(tr, $1, $3, $5);
	ps.pop_back();
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

prefix_actions:
    action_labels {
	AA($1,1,1);
	$$ = callback__32(tr, $1);
	ps.pop_back();
	ps.push_back($$);
    }
    | prefix_actions ARROW action_labels {
	AA($1,1,2); AA($3,2,2);
	$$ = callback__33(tr, $1, $3);
	ps.pop_back();
    }
    ;

guard_OPT:
    {
	$$ = NULL;
	ps.push_back($$);
    }
    | WHEN expression {
	AA($2,1,1);
	$$ = $2;
    }
    ;

indices_OPT:
    {
	$$ = callback__34(tr);
	ps.push_back($$);
    }
    | indices
    ;

indices:
    '[' expression ']' {
	AA($2,1,1);
	$$ = callback__35(tr, $2);
	ps.pop_back();
	ps.push_back($$);
    }
    | indices '[' expression ']' {
	AA($1,1,2); AA($3,2,2);
	$$ = callback__36(tr, $1, $3);
	ps.pop_back();
    }
    ;

index_ranges_OPT:
    {
	$$ = callback__37(tr);
	ps.push_back($$);
    }
    | index_ranges
    ;

index_ranges:
    '[' action_range ']' {
	AA($2,1,1);
	$$ = callback__38(tr, $2);
	ps.pop_back();
	ps.push_back($$);
    }
    | index_ranges '[' action_range ']' {
	AA($1,1,2); AA($3,2,2);
	$$ = callback__39(tr, $1, $3);
	ps.pop_back();
	ps.pop_back();
	ps.push_back($$);
    }
    ;

sequential_composition:
    seq_process_list ';' base_local_process {
	$$ = $1;
    }
    ;

seq_process_list:
    process_ref {
	$$ = $1;
    }
    | seq_process_list ';' process_ref {
	$$ = $1;
    }
    ;

process_ref:
    process_id argument_OPT {
	//TODO
    }
    ;

argument_OPT:
    |'(' argument_list ')' {
    }
    ;

argument_list:
    expression {
    }
    | argument_list ',' expression {
    }
    ;


/* Composite process */
composite_def:
    OR process_id param_OPT '=' composite_body priority_OPT hiding_OPT '.'
    ;

composite_body:
    prefix_label_OPT process_ref relabel_OPT
    | prefix_label_OPT '(' parallel_composition ')' relabel_OPT
    | FORALL ranges composite_body
    | IF expression THEN composite_body
    | IF expression THEN composite_body ELSE composite_body
    ;

parallel_composition:
    composite_body
    | parallel_composition OR composite_body
    ;

prefix_label_OPT:
    | prefix_label
    ;

// TODO add the third option
prefix_label:
    action_labels ':' 
    | action_labels SHARING
    ;

priority_OPT:
    | priority;

priority:
    RSHIFT set
    | LSHIFT set
    ;

ranges_OPT:
    | ranges;

ranges:
    '[' action_range ']'
    | ranges '[' action_range ']'
    ;


/* Parameters */
param_OPT:
    | param {
    }
    ;

param:
    '(' parameter_list ')' {
    }
    ;

parameter_list:
    parameter {
    }
    | parameter_list ',' parameter {
    }
    ;

parameter:
    parameter_id '=' expression {
	AA($1,1,2); AA($3,2,2);
	if ($3->v.size() != 1) {
	    // XXX this should never happen..
	    stringstream errstream;
	    errstream << "Illegal use of variables in parameter declaration";
	    semantic_error(errstream);
	}
	ConstValue * cvp = err_if_not_const($3->v[0]);
	$3->detach(0);
	SymbolValue * svp = cvp;
	if (!tr.identifiers.insert(*$1, svp)) {
	    stringstream errstream;
	    errstream << "identifier " << *$1 << " already declared";
	    semantic_error(errstream);
	}
	tr.parameters.push_back($1);
	delete $3;
	ps.pop_back();
	ps.pop_back();
    }	
    ;


/* Re-Labeling and Hiding */
relabel_OPT:
    | relabel
    ;

relabel:
    '/' '{' relabel_defs '}'
    ;

relabel_defs:
    relabel_def
    | relabel_defs ',' relabel_def
    ;

relabel_def:
    action_labels '/' action_labels
    | FORALL index_ranges '{' relabel_defs '}'
    ;

hiding_OPT:
    | hiding
    ;

hiding:
    '\\' set
    | '@' set
    ;


/* Property, Progress and Menu */
// TODO second form of progress (if S then C)
property_def:
    PROPERTY process_def
    ;

progress_def:
    PROGRESS progress_id ranges_OPT '=' set
    ;

menu_def:
    MENU menu_id '=' set
    ;


/* An expression or a simple_expression: standard operators and priorities. */
expression:
    or_expr {
	AA($1,1,1);
	$$ = $1;
    }
    ;

simple_expression:
    additive_expr {
	AA($1,1,1);
	$$ = $1;
    }
    ;

or_expr:
    and_expr
    | or_expr OR and_expr {
	AA($1,1,2); AA($3,2,2);
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = vpl->value || vpr->value;
	}
	delete $3;
	$$ = $1;
	ps.pop_back();
    }
    ;

and_expr:
    bitor_expr
    | and_expr AND bitor_expr {
	AA($1,1,2); AA($3,2,2);
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = vpl->value && vpr->value;
	}
	delete $3;
	$$ = $1;
	ps.pop_back();
    }
    ;

bitor_expr:
    bitxor_expr
    | bitor_expr '|' bitxor_expr {
	AA($1,1,2); AA($3,2,2);
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value |= vpr->value;
	}
	delete $3;
	$$ = $1;
	ps.pop_back();
    }
    ;

bitxor_expr:
    bitand_expr
    | bitxor_expr '^' bitand_expr {
	AA($1,1,2); AA($3,2,2);
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value ^= vpr->value;
	}
	delete $3;
	$$ = $1;
	ps.pop_back();
    }
    ;

bitand_expr:
    equality_expr
    | bitand_expr '&' equality_expr {
	AA($1,1,2); AA($3,2,2);
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value &= vpr->value;
	}
	delete $3;
	$$ = $1;
	ps.pop_back();
    }
    ;

equality_expr:
    relational_expr
    | equality_expr EQUAL relational_expr {
	AA($1,1,2); AA($3,2,2);
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value == vpr->value);
	}
	delete $3;
	$$ = $1;
	ps.pop_back();
    }
    | equality_expr NOTEQUAL relational_expr {
	AA($1,1,2); AA($3,2,2);
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value != vpr->value);
	}
	delete $3;
	$$ = $1;
	ps.pop_back();
    }
    ;

relational_expr:
    shift_expr
    | relational_expr '<' shift_expr {
	AA($1,1,2); AA($3,2,2);
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value < vpr->value);
	}
	delete $3;
	$$ = $1;
	ps.pop_back();
    }
    | relational_expr '>' shift_expr {
	AA($1,1,2); AA($3,2,2);
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value > vpr->value);
	}
	delete $3;
	$$ = $1;
	ps.pop_back();
    }
    | relational_expr LOE shift_expr {
	AA($1,1,2); AA($3,2,2);
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value <= vpr->value);
	}
	delete $3;
	$$ = $1;
	ps.pop_back();
    }
    | relational_expr GOE shift_expr {
	AA($1,1,2); AA($3,2,2);
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = (vpl->value >= vpr->value);
	}
	delete $3;
	$$ = $1;
	ps.pop_back();
    }
    ;

shift_expr:
    additive_expr
    | shift_expr LSHIFT additive_expr {
	AA($1,1,2); AA($3,2,2);
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value <<= vpr->value;
	}
	delete $3;
	$$ = $1;
	ps.pop_back();
    }
    | shift_expr RSHIFT additive_expr {
	AA($1,1,2); AA($3,2,2);
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value >>= vpr->value;
	}
	delete $3;
	$$ = $1;
	ps.pop_back();
    }
    ;

additive_expr:
    multiplicative_expr
    | additive_expr '+' multiplicative_expr {
	AA($1,1,2); AA($3,2,2);
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    //cout << vpl->value << " + " << vpr->value << "\n";
	    vpl->value += vpr->value;
	}
	delete $3;
	$$ = $1;
	ps.pop_back();
    }
    | additive_expr '-' multiplicative_expr {
	AA($1,1,2); AA($3,2,2);
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    //cout << vpl->value << " - " << vpr->value << "\n";
	    vpl->value -= vpr->value;
	}
	delete $3;
	$$ = $1;
	ps.pop_back();
    }
    ;

multiplicative_expr:
    unary_expr
    | multiplicative_expr '*' unary_expr {
	AA($1,1,2); AA($3,2,2);
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    //cout << vpl->value << " * " << vpr->value << "\n";
	    vpl->value *= vpr->value;
	}
	delete $3;
	$$ = $1;
	ps.pop_back();
    }
    | multiplicative_expr '/' unary_expr {
	AA($1,1,2); AA($3,2,2);
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    //cout << vpl->value << " / " << vpr->value << "\n";
	    vpl->value /= vpr->value;
	}
	delete $3;
	$$ = $1;
	ps.pop_back();
    }
    | multiplicative_expr '%' unary_expr {
	AA($1,1,2); AA($3,2,2);
	assert($1->v.size() == $3->v.size());
	for (int i=0; i<$1->v.size(); i++) {
	    ConstValue * vpl = err_if_not_const($1->v[i]);
	    ConstValue * vpr = err_if_not_const($3->v[i]);
	    vpl->value = vpl->value % vpr->value;
	}
	delete $3;
	$$ = $1;
	ps.pop_back();
    }
    ;

unary_expr:
    base_expr
    | '+' base_expr {
	AA($2,1,1);
	for (int i=0; i<$2->v.size(); i++) {
	    err_if_not_const($2->v[i]);
	}
	$$ = $2;
    }
    | '-' base_expr {
	AA($2,1,1);
	ConstValue * cvp;
	for (int i=0; i<$2->v.size(); i++) {
	    cvp = err_if_not_const($2->v[i]);
	    cvp->value *= -1;
	}
	$$ = $2;
    }
    | '!' base_expr {
	AA($2,1,1);
	ConstValue * cvp;
	for (int i=0; i<$2->v.size(); i++) {
	    cvp = err_if_not_const($2->v[i]);
	    cvp->value = !(cvp->value);
	    //cout << "UU ! " << cvp->value << "\n";
	}
	$$ = $2;
    }
    ;

/* TODO: complete base_expr */
base_expr:
    INTEGER {
	SvpVec * vp;
	ConstValue * cvp;

	/* Return a ConstValue* for each context (in non shared mode). */
	vp = new SvpVec;
	vp->shared = false;
	for (int c=0; c<tr.current_contexts().size(); c++) {
	    cvp = new ConstValue;
	    cvp->value = $1;
	    vp->v.push_back(cvp);
	}
	$$ = vp;
	ps.push_back($$);
	//cout << "UU " << $1 << "\n";
    }
    | variable {
	AA($1,1,1);
	/* Return a ConstValue* for each context (in non shared mode). */
	SvpVec * vp;

	vp = new SvpVec;
	vp->shared = false;
	for (int c=0; c<tr.current_contexts().size(); c++) {
	    SymbolValue * svp;
	    if (!(tr.current_contexts()[c]->lookup(*$1, svp))) {
		stringstream errstream;
errstream << "variable " << *$1 << " undeclared\n";
		semantic_error(errstream);
	    }
	    svp = svp->clone();
	    vp->v.push_back(svp);
	}
	delete $1;
	$$ = vp;
	ps.pop_back();
	ps.push_back($$);
    }
    | const_range_set_parameter_id {
	AA($1,1,1);
	SymbolValue * svp;
	SvpVec * vp; 
	
	/* Lookup the identifier and clone the associated object. */
	if (!tr.identifiers.lookup(*$1, svp)) {
	    stringstream errstream;
	    errstream << "const/range/set/parameter " << *$1
		<< " undeclared";
	    semantic_error(errstream);
	}
	delete $1;

	/* Return a ConstValue* for each context (in non shared mode). */
	vp = new SvpVec;
	vp->shared = false;
	for (int c=0; c<tr.current_contexts().size(); c++)
	    vp->v.push_back(svp->clone());
	$$ = vp;
	ps.pop_back();
	ps.push_back($$);
    }
    | '(' expression ')' {
	AA($2,1,1);
	$$ = $2;
    }
    ;

/* Some useful alias for LowerCaseID and UpperCaseID. */
variable: LowerCaseID { ps.push_back($1); };
constant_id: UpperCaseID { ps.push_back($1); };
range_id: UpperCaseID { ps.push_back($1); };
set_id: UpperCaseID { ps.push_back($1); };
range_or_set_id: set_id { AA($1,1,1); };
const_range_set_parameter_id: set_id { AA($1,1,1); };
parameter_id: UpperCaseID { ps.push_back($1); };
process_id: UpperCaseID { ps.push_back($1); };
progress_id: UpperCaseID { ps.push_back($1); };
menu_id: UpperCaseID { ps.push_back($1); };

%%


const char * ex = "P=(a->b->P).";

int parser()
{
    const char * input_name = "input";

    /* Initialize shared data structures: A stack containing a single
       ContextsSet. This set contains a single empty Context and an
       empty frontier. */
    ContextsSet * csp = new ContextsSet;
    csp->append(new Context);
    tr.css.push(csp);

    /*
    ScannerFileBuffer sfb(input_name);
    sfb.select();
    yyparse();

    ScannerStringBuffer ssb(ex,12);
    ssb.select();
    yyparse(); */

    InputBuffersStack ibs;

    ibs.push(input_name);
    yyparse();
    ibs.pop();

    return 0;
}


void yyerror(const char *s) {
    cout << "Syntax error:" << s << endl;
    // might as well halt now:
    exit(-1);
}

